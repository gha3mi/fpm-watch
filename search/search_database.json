var tipuesearch = {"pages":[{"title":" fpm-watch ","text":"fpm-watch fpm-watch is a plugin for the Fortran Package Manager (fpm) that automatically rebuilds, tests or runs your project whenever relevant source files change. It supports dependency awareness, low CPU idle mode and automatic restart capability. Requirements Fortran Package Manager (fpm) version 0.13.0 A supported Fortran compiler. Tested on Ubuntu with gfortran. Installation git clone https://github.com/gha3mi/fpm-watch.git cd fpm-watch\nfpm install --profile release Basic Usage fpm-watch build\nfpm-watch test fpm-watch run Everything after <build|test|run> is passed directly to fpm . Example: fpm-watch --watch-low-cpu --watch-auto-restart run --example my_example Watch Options -- watch - help Show help and exit . -- watch - quiet | - q Quiet mode ( errors only ) . -- watch - verbose [ = N ] | - v Increase verbosity ( 0 – 2 ) . -- watch - very - verbose | - vv Maximum verbosity ( prints watch list ) . -- watch - debug Enable debug logging . Dependency Watching --watch-deps\n    Also watch dependency source trees.\n\n--watch-no-deps\n    Disable dependency watching (default). CPU Mode --watch-low-cpu\n    Use OS sleep instead of busy-waiting (near 0% idle CPU).\n\n--watch-no-low-cpu\n    Use busy polling (default). Polling & Execution -- watch - poll < sec > Poll interval ( default : 0 . 5 ) . -- watch - debounce < sec > Debounce delay before running ( default : 0 . 2 ) . -- watch - rescan < sec > Periodically rebuild fpm model ( default : 0 = disabled ) . -- watch - no - rescan Disable periodic rescan . -- watch - run - on - start Run once immediately on startup ( default ) . -- watch - no - run - on - start Wait for first change before running . Output Control -- watch - silent - fpm Suppress fpm output ; show only fpm-watch status. -- watch - print - files Print watched file list at startup . Filtering -- watch - ignore < glob > Ignore matching files ( repeatable ) . -- watch - include < glob > Only watch matching files ( repeatable ) . -- watch - feature < name > Enable optional feature plugin ( repeatable ) . Auto-Restart (Supervisor Mode) -- watch - auto - restart Restart fpm - watch automatically if it crashes . -- watch - restart - delay < sec > Delay before restart ( default : 1 . 0 ) . -- watch - restart - max < N > Maximum restart attempts ( 0 = unlimited ) . -- watch - self < path > Explicit path to fpm - watch executable ( advanced ) . Configuration via fpm.toml Defaults can be defined in your project: [extra.fpm-watch] poll = 0.5 debounce = 0.2 rescan = 0.0 run-on-start = true silent-fpm = false print-files = false deps = false low-cpu = false auto-restart = false restart-delay = 1.0 restart-max = 0 self = \"\" debug = false verbosity = 0 ignore = [] include = [] features = [] Stopping Press: Ctrl+C Or create: touch .fpm-watch.stop Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"watch_feature_t – fpm-watch ","text":"type, public :: watch_feature_t Base feature type (override callbacks to implement behavior). Inherited by type~~watch_feature_t~~InheritedByGraph type~watch_feature_t watch_feature_t type~feature_box_t feature_box_t type~feature_box_t->type~watch_feature_t p type~stats_feature_t stats_feature_t type~stats_feature_t->type~watch_feature_t type~feature_manager_t feature_manager_t type~feature_manager_t->type~feature_box_t feat type~watcher_t watcher_t type~watcher_t->type~feature_manager_t fm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: init => feat_init_noop private  subroutine feat_init_noop (self, cfg) No-op init callback. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg procedure, public :: on_after_run => feat_after_noop private  subroutine feat_after_noop (self, exitstat, seconds) No-op callback invoked after executing the command. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds procedure, public :: on_before_run => feat_before_noop private  subroutine feat_before_noop (self, cmd) No-op callback invoked just before executing the command. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self character(len=:), intent(inout), allocatable :: cmd procedure, public :: on_change_detected => feat_change_noop private  subroutine feat_change_noop (self, changed) No-op callback for detected file changes. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(in), allocatable :: changed (:) procedure, public :: on_manifest_changed => feat_manifest_noop private  subroutine feat_manifest_noop (self, old_key, new_key) No-op callback for manifest key change. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self integer(kind=int64), intent(in) :: old_key integer(kind=int64), intent(in) :: new_key procedure, public :: on_start => feat_noop private  subroutine feat_noop (self) No-op start callback. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self procedure, public :: on_watch_list_built => feat_list_noop private  subroutine feat_list_noop (self, files, roots) No-op callback for watch list rebuild completion. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(inout), allocatable :: files (:) type( root_info_t ), intent(inout), allocatable :: roots (:) Source Code type watch_feature_t contains procedure :: init => feat_init_noop procedure :: on_start => feat_noop procedure :: on_watch_list_built => feat_list_noop procedure :: on_manifest_changed => feat_manifest_noop procedure :: on_change_detected => feat_change_noop procedure :: on_before_run => feat_before_noop procedure :: on_after_run => feat_after_noop end type watch_feature_t","tags":"","url":"type/watch_feature_t.html"},{"title":"string_accum_t – fpm-watch ","text":"type, public :: string_accum_t Simple amortized string accumulator. Used to build arrays of strings efficiently without repeated reallocation. Inherits type~~string_accum_t~~InheritsGraph type~string_accum_t string_accum_t string_t string_t type~string_accum_t->string_t a Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(string_t), public, allocatable :: a (:) integer, public :: n = 0 Type-Bound Procedures procedure, public :: push => accum_push private  subroutine accum_push (self, s) Append a string to the accumulator (grows capacity as needed). Arguments Type Intent Optional Attributes Name class( string_accum_t ), intent(inout) :: self character(len=*), intent(in) :: s procedure, public :: to_array => accum_to_array private  subroutine accum_to_array (self, out) Materialize the accumulator into a right-sized array. Read more… Arguments Type Intent Optional Attributes Name class( string_accum_t ), intent(inout) :: self type(string_t), intent(out), allocatable :: out (:) Source Code type string_accum_t type ( string_t ), allocatable :: a (:) integer :: n = 0 contains procedure :: push => accum_push procedure :: to_array => accum_to_array end type string_accum_t","tags":"","url":"type/string_accum_t.html"},{"title":"feature_manager_t – fpm-watch ","text":"type, public :: feature_manager_t Container for multiple feature instances and their callback fan-out. Inherits type~~feature_manager_t~~InheritsGraph type~feature_manager_t feature_manager_t type~feature_box_t feature_box_t type~feature_manager_t->type~feature_box_t feat type~watch_feature_t watch_feature_t type~feature_box_t->type~watch_feature_t p Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~feature_manager_t~~InheritedByGraph type~feature_manager_t feature_manager_t type~watcher_t watcher_t type~watcher_t->type~feature_manager_t fm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( feature_box_t ), public, allocatable :: feat (:) Type-Bound Procedures procedure, public :: add => fm_add private  subroutine fm_add (self, f) Add a feature instance to the manager, transferring ownership. Read more… Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self class( watch_feature_t ), intent(inout), allocatable :: f procedure, public :: init_all private  subroutine init_all (self, cfg) Call init(cfg) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg procedure, public :: on_after_run_all private  subroutine on_after_run_all (self, exitstat, seconds) Call on_after_run(exitstat, seconds) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds procedure, public :: on_before_run_all private  subroutine on_before_run_all (self, cmd) Call on_before_run(cmd) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self character(len=:), intent(inout), allocatable :: cmd procedure, public :: on_change_detected_all private  subroutine on_change_detected_all (self, changed) Call on_change_detected(changed) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type(string_t), intent(in), allocatable :: changed (:) procedure, public :: on_manifest_changed_all private  subroutine on_manifest_changed_all (self, old_key, new_key) Call on_manifest_changed(old_key, new_key) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self integer(kind=int64), intent(in) :: old_key integer(kind=int64), intent(in) :: new_key procedure, public :: on_start_all private  subroutine on_start_all (self) Call on_start() on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self procedure, public :: on_watch_list_built_all private  subroutine on_watch_list_built_all (self, files, roots) Call on_watch_list_built(files, roots) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type(string_t), intent(inout), allocatable :: files (:) type( root_info_t ), intent(inout), allocatable :: roots (:) Source Code type feature_manager_t type ( feature_box_t ), allocatable :: feat (:) contains procedure :: add => fm_add procedure :: init_all procedure :: on_start_all procedure :: on_watch_list_built_all procedure :: on_manifest_changed_all procedure :: on_change_detected_all procedure :: on_before_run_all procedure :: on_after_run_all end type feature_manager_t","tags":"","url":"type/feature_manager_t.html"},{"title":"feature_box_t – fpm-watch ","text":"type, private :: feature_box_t A thin wrapper to store an allocatable polymorphic feature instance. Inherits type~~feature_box_t~~InheritsGraph type~feature_box_t feature_box_t type~watch_feature_t watch_feature_t type~feature_box_t->type~watch_feature_t p Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~feature_box_t~~InheritedByGraph type~feature_box_t feature_box_t type~feature_manager_t feature_manager_t type~feature_manager_t->type~feature_box_t feat type~watcher_t watcher_t type~watcher_t->type~feature_manager_t fm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( watch_feature_t ), public, allocatable :: p Source Code type feature_box_t class ( watch_feature_t ), allocatable :: p end type feature_box_t","tags":"","url":"type/feature_box_t.html"},{"title":"watcher_t – fpm-watch ","text":"type, public :: watcher_t Main watcher state and methods. watcher_t owns:\n- The effective configuration ( cfg )\n- Feature plugins ( fm )\n- Watch list ( files ) plus per-file target masks ( file_mask )\n- Fingerprinting buffers for change detection ( fp_prev , fp_now )\n- The current manifest key used to detect \"rebuild needed\" events ( man_prev ) Inherits type~~watcher_t~~InheritsGraph type~watcher_t watcher_t string_t string_t type~watcher_t->string_t files type~feature_manager_t feature_manager_t type~watcher_t->type~feature_manager_t fm type~root_info_t root_info_t type~watcher_t->type~root_info_t roots type~watch_config_t watch_config_t type~watcher_t->type~watch_config_t cfg type~feature_box_t feature_box_t type~feature_manager_t->type~feature_box_t feat fpm_build_settings fpm_build_settings type~watch_config_t->fpm_build_settings settings type~watch_opts_t watch_opts_t type~watch_config_t->type~watch_opts_t w type~watch_feature_t watch_feature_t type~feature_box_t->type~watch_feature_t p type~watch_opts_t->string_t ignore, include, enabled_features Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( watch_config_t ), public :: cfg integer, public, allocatable :: changed_idx (:) integer(kind=int64), public, allocatable :: file_mask (:) type(string_t), public, allocatable :: files (:) type( feature_manager_t ), public :: fm integer(kind=int64), public, allocatable :: fp_now (:) integer(kind=int64), public, allocatable :: fp_prev (:) integer(kind=int64), public :: man_prev = 0_int64 type( root_info_t ), public, allocatable :: roots (:) Type-Bound Procedures procedure, public :: init => watcher_init private  subroutine watcher_init (self, cfg) Initialize a watcher instance from configuration. Read more… Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg procedure, public :: run => watcher_run private  subroutine watcher_run (self) Run the main watch loop until termination. Read more… Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self Source Code type watcher_t type ( watch_config_t ) :: cfg type ( feature_manager_t ) :: fm type ( string_t ), allocatable :: files (:) integer ( int64 ), allocatable :: file_mask (:) type ( root_info_t ), allocatable :: roots (:) integer ( int64 ), allocatable :: fp_prev (:) integer ( int64 ), allocatable :: fp_now (:) integer , allocatable :: changed_idx (:) integer ( int64 ) :: man_prev = 0_int64 contains procedure :: init => watcher_init procedure :: run => watcher_run end type watcher_t","tags":"","url":"type/watcher_t.html"},{"title":"timespec – fpm-watch ","text":"type, private, bind(C) :: timespec Components Type Visibility Attributes Name Initial integer(kind=c_long), public :: tv_nsec integer(kind=c_long), public :: tv_sec Source Code type , bind ( C ) :: timespec integer ( c_long ) :: tv_sec integer ( c_long ) :: tv_nsec end type timespec","tags":"","url":"type/timespec.html"},{"title":"root_info_t – fpm-watch ","text":"type, public :: root_info_t Root target metadata used for change → target mapping. The mask is a single-bit value used to mark membership of files and\ntarget closures. Inherited by type~~root_info_t~~InheritedByGraph type~root_info_t root_info_t type~watcher_t watcher_t type~watcher_t->type~root_info_t roots Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int64), public :: mask = 0_int64 character(len=:), public, allocatable :: name Source Code type root_info_t character ( len = :), allocatable :: name integer ( int64 ) :: mask = 0_int64 end type root_info_t","tags":"","url":"type/root_info_t.html"},{"title":"watch_config_t – fpm-watch ","text":"type, public :: watch_config_t Fully assembled watcher configuration. This record is the primary input to watcher_t%init() .\nWatcher options. Inherits type~~watch_config_t~~InheritsGraph type~watch_config_t watch_config_t fpm_build_settings fpm_build_settings type~watch_config_t->fpm_build_settings settings type~watch_opts_t watch_opts_t type~watch_config_t->type~watch_opts_t w string_t string_t type~watch_opts_t->string_t ignore, include, enabled_features Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~watch_config_t~~InheritedByGraph type~watch_config_t watch_config_t type~watcher_t watcher_t type~watcher_t->type~watch_config_t cfg Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cmd_prefix Cached remainder after the subcommand token (for injection). character(len=:), public, allocatable :: cmd_rest character(len=:), public, allocatable :: fpm_cmdline Selected fpm subcommand ( build , test , or run ). class(fpm_build_settings), public, allocatable :: settings Cached prefix up to and including the subcommand token (for injection). character(len=:), public, allocatable :: subcmd Typed fpm settings corresponding to subcmd . type( watch_opts_t ), public :: w Full command line string to execute (e.g., fpm test -- ... ). Source Code type watch_config_t !! Watcher options. type ( watch_opts_t ) :: w !! Full command line string to execute (e.g., `fpm test -- ...`). character ( len = :), allocatable :: fpm_cmdline !! Selected `fpm` subcommand (`build`, `test`, or `run`). character ( len = :), allocatable :: subcmd !! Typed `fpm` settings corresponding to `subcmd`. class ( fpm_build_settings ), allocatable :: settings !! Cached prefix up to and including the subcommand token (for injection). character ( len = :), allocatable :: cmd_prefix !! Cached remainder after the subcommand token (for injection). character ( len = :), allocatable :: cmd_rest end type watch_config_t","tags":"","url":"type/watch_config_t.html"},{"title":"watch_opts_t – fpm-watch ","text":"type, public :: watch_opts_t Watcher configuration options. Values are typically assembled from:\n- hard-coded defaults,\n- fpm.toml overrides ( [extra.fpm-watch] ),\n- command-line flags ( --watch-* ). Time values ( poll , debounce , rescan ) are in seconds.\nVerbosity level:\n- -1 : quiet (errors only)\n- 0 : normal\n- 1..2 : more detail Inherits type~~watch_opts_t~~InheritsGraph type~watch_opts_t watch_opts_t string_t string_t type~watch_opts_t->string_t ignore, include, enabled_features Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~watch_opts_t~~InheritedByGraph type~watch_opts_t watch_opts_t type~watch_config_t watch_config_t type~watch_config_t->type~watch_opts_t w type~watcher_t watcher_t type~watcher_t->type~watch_config_t cfg Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real, public :: debounce = 0.2 Optional periodic rescan interval (seconds). 0 disables periodic rescans. logical, public :: debug = .false. Poll interval (seconds) between change scans. type(string_t), public, allocatable :: enabled_features (:) Run once (init + optional run-on-start) and exit (CI-friendly). type(string_t), public, allocatable :: ignore (:) Glob patterns to include; if empty, includes all. type(string_t), public, allocatable :: include (:) Names of optional feature plugins to enable. logical, public :: low_cpu = .false. Glob patterns to ignore. logical, public :: once = .false. real, public :: poll = 0.5 Debounce interval (seconds) used after the first detected change. logical, public :: print_files_once = .false. Suppress fpm output; keep only fpm-watch status lines. real, public :: rescan = 0.0 Run the command once immediately on startup. logical, public :: run_on_start = .true. Print the watched file list once at startup (requires high verbosity). logical, public :: silent_fpm = .false. Also watch dependency project sources (can include paths under build dir). integer, public :: verbosity = 0 Enable extra debug output and internal timing/status messages. logical, public :: watch_deps = .false. Use OS sleep for waiting to minimize idle CPU usage. Source Code type watch_opts_t !! Verbosity level: !! - `-1`: quiet (errors only) !! - `0`: normal !! - `1..2`: more detail integer :: verbosity = 0 !! Enable extra debug output and internal timing/status messages. logical :: debug = . false . !! Poll interval (seconds) between change scans. real :: poll = 0.5 !! Debounce interval (seconds) used after the first detected change. real :: debounce = 0.2 !! Optional periodic rescan interval (seconds). `0` disables periodic rescans. real :: rescan = 0.0 !! Run the command once immediately on startup. logical :: run_on_start = . true . !! Print the watched file list once at startup (requires high verbosity). logical :: print_files_once = . false . !! Suppress `fpm` output; keep only `fpm-watch` status lines. logical :: silent_fpm = . false . !! Also watch dependency project sources (can include paths under build dir). logical :: watch_deps = . false . !! Use OS sleep for waiting to minimize idle CPU usage. logical :: low_cpu = . false . !! Glob patterns to ignore. type ( string_t ), allocatable :: ignore (:) !! Glob patterns to include; if empty, includes all. type ( string_t ), allocatable :: include (:) !! Names of optional feature plugins to enable. type ( string_t ), allocatable :: enabled_features (:) !! Run once (init + optional run-on-start) and exit (CI-friendly). logical :: once = . false . end type watch_opts_t","tags":"","url":"type/watch_opts_t.html"},{"title":"stats_feature_t – fpm-watch ","text":"type, private, extends( watch_feature_t ) :: stats_feature_t A feature that counts how many command runs have completed. Inherits type~~stats_feature_t~~InheritsGraph type~stats_feature_t stats_feature_t type~watch_feature_t watch_feature_t type~stats_feature_t->type~watch_feature_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: runs = 0 Type-Bound Procedures procedure, public :: init => stats_init private  subroutine stats_init (self, cfg) Initialize the stats feature. Read more… Arguments Type Intent Optional Attributes Name class( stats_feature_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg procedure, public :: on_after_run => stats_after private  subroutine stats_after (self, exitstat, seconds) Update run counter after each completed command execution. Read more… Arguments Type Intent Optional Attributes Name class( stats_feature_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds procedure, public :: on_before_run => feat_before_noop private  subroutine feat_before_noop (self, cmd) No-op callback invoked just before executing the command. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self character(len=:), intent(inout), allocatable :: cmd procedure, public :: on_change_detected => feat_change_noop private  subroutine feat_change_noop (self, changed) No-op callback for detected file changes. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(in), allocatable :: changed (:) procedure, public :: on_manifest_changed => feat_manifest_noop private  subroutine feat_manifest_noop (self, old_key, new_key) No-op callback for manifest key change. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self integer(kind=int64), intent(in) :: old_key integer(kind=int64), intent(in) :: new_key procedure, public :: on_start => feat_noop private  subroutine feat_noop (self) No-op start callback. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self procedure, public :: on_watch_list_built => feat_list_noop private  subroutine feat_list_noop (self, files, roots) No-op callback for watch list rebuild completion. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(inout), allocatable :: files (:) type( root_info_t ), intent(inout), allocatable :: roots (:) Source Code type , extends ( watch_feature_t ) :: stats_feature_t integer :: runs = 0 contains procedure :: init => stats_init procedure :: on_after_run => stats_after end type stats_feature_t","tags":"","url":"type/stats_feature_t.html"},{"title":"get_arg – fpm-watch","text":"public  function get_arg(i) result(a) Retrieve a command-line argument as an allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i 0-based/1-based index passed to get_command_argument . Return Value character(len=:), allocatable Called by proc~~get_arg~~CalledByGraph proc~get_arg get_arg proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~get_arg proc~build_child_command build_child_command proc~build_child_command->proc~get_arg proc~choose_self_exe choose_self_exe proc~build_child_command->proc~choose_self_exe proc~choose_self_exe->proc~get_arg proc~join_argv join_argv proc~join_argv->proc~get_arg proc~parse_cli parse_cli proc~parse_cli->proc~get_arg proc~parse_cli->proc~apply_watch_flag proc~parse_cli->proc~join_argv proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~get_arg proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~supervisor_loop supervisor_loop proc~maybe_supervise->proc~supervisor_loop proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli proc~supervisor_loop->proc~build_child_command Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_arg ( i ) result ( a ) integer , intent ( in ) :: i !! 0-based/1-based index passed to `get_command_argument`. character ( len = :), allocatable :: a integer :: n , istat n = 0 call get_command_argument ( i , length = n , status = istat ) if ( istat /= 0 . or . n <= 0 ) then a = \"\" return end if allocate ( character ( len = n ) :: a ) call get_command_argument ( i , value = a , status = istat ) if ( istat /= 0 ) a = \"\" end function get_arg","tags":"","url":"proc/get_arg.html"},{"title":"is_windows_os – fpm-watch","text":"public  function is_windows_os() Return whether the current OS should be treated as Windows for quoting. Arguments None Return Value logical Calls proc~~is_windows_os~~CallsGraph proc~is_windows_os is_windows_os get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_windows_os~~CalledByGraph proc~is_windows_os is_windows_os proc~quote_arg quote_arg proc~quote_arg->proc~is_windows_os proc~build_child_command build_child_command proc~build_child_command->proc~quote_arg proc~join_argv join_argv proc~join_argv->proc~quote_arg proc~parse_cli parse_cli proc~parse_cli->proc~join_argv proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~build_child_command proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code logical function is_windows_os () is_windows_os = ( get_os_type () == OS_WINDOWS ) end function is_windows_os","tags":"","url":"proc/is_windows_os.html"},{"title":"join_argv – fpm-watch","text":"public  function join_argv(i1, i2) result(s) Join a range of argv entries into a single command-line string. Each token is quoted when needed, using quote_arg() ; quoting rules are\nplatform-dependent (Windows vs POSIX). Arguments Type Intent Optional Attributes Name integer, intent(in) :: i1 Inclusive range of argv indices to join. integer, intent(in) :: i2 Inclusive range of argv indices to join. Return Value character(len=:), allocatable Calls proc~~join_argv~~CallsGraph proc~join_argv join_argv proc~get_arg get_arg proc~join_argv->proc~get_arg proc~needs_quotes needs_quotes proc~join_argv->proc~needs_quotes proc~quote_arg quote_arg proc~join_argv->proc~quote_arg proc~is_windows_os is_windows_os proc~quote_arg->proc~is_windows_os get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~join_argv~~CalledByGraph proc~join_argv join_argv proc~parse_cli parse_cli proc~parse_cli->proc~join_argv proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function join_argv ( i1 , i2 ) result ( s ) integer , intent ( in ) :: i1 , i2 !! Inclusive range of argv indices to join. character ( len = :), allocatable :: s character ( len = :), allocatable :: a integer :: i s = \"\" do i = i1 , i2 a = get_arg ( i ) if ( len_trim ( a ) == 0 ) cycle if ( needs_quotes ( a )) then s = s // quote_arg ( a ) // \" \" else s = s // trim ( a ) // \" \" end if end do s = trim ( s ) end function join_argv","tags":"","url":"proc/join_argv.html"},{"title":"needs_quotes – fpm-watch","text":"public pure function needs_quotes(a) result(q) Determine whether an argument requires quoting for safe shell parsing. A conservative check: any whitespace or quotes trigger quoting. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a Return Value logical Called by proc~~needs_quotes~~CalledByGraph proc~needs_quotes needs_quotes proc~join_argv join_argv proc~join_argv->proc~needs_quotes proc~parse_cli parse_cli proc~parse_cli->proc~join_argv proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function needs_quotes ( a ) result ( q ) character ( len =* ), intent ( in ) :: a q = ( index ( a , ' ' ) /= 0 ) . or . ( index ( a , char ( 9 )) /= 0 ) . or . ( index ( a , '\"' ) /= 0 ) . or . ( index ( a , \"'\" ) /= 0 ) end function needs_quotes","tags":"","url":"proc/needs_quotes.html"},{"title":"parse_int – fpm-watch","text":"public pure function parse_int(s, default) result(v) Parse an integer with a default fallback on I/O error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: default Return Value integer Called by proc~~parse_int~~CalledByGraph proc~parse_int parse_int proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~parse_int proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~parse_int proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure integer function parse_int ( s , default ) result ( v ) character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: default integer :: ios read ( s , * , iostat = ios ) v if ( ios /= 0 ) v = default end function parse_int","tags":"","url":"proc/parse_int.html"},{"title":"parse_real – fpm-watch","text":"public pure function parse_real(s, default) result(v) Parse a real with a default fallback on I/O error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: default Return Value real Called by proc~~parse_real~~CalledByGraph proc~parse_real parse_real proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~parse_real proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~parse_real proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure real function parse_real ( s , default ) result ( v ) character ( len =* ), intent ( in ) :: s real , intent ( in ) :: default integer :: ios read ( s , * , iostat = ios ) v if ( ios /= 0 ) v = default end function parse_real","tags":"","url":"proc/parse_real.html"},{"title":"quote_arg – fpm-watch","text":"public  function quote_arg(a) result(q) Quote an argument for the host shell, escaping embedded quotes as needed. On Windows, \" is doubled. On POSIX shells, ' is escaped using a standard ' → '\"'\"' pattern. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a Return Value character(len=:), allocatable Calls proc~~quote_arg~~CallsGraph proc~quote_arg quote_arg proc~is_windows_os is_windows_os proc~quote_arg->proc~is_windows_os get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~quote_arg~~CalledByGraph proc~quote_arg quote_arg proc~build_child_command build_child_command proc~build_child_command->proc~quote_arg proc~join_argv join_argv proc~join_argv->proc~quote_arg proc~parse_cli parse_cli proc~parse_cli->proc~join_argv proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~build_child_command proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function quote_arg ( a ) result ( q ) character ( len =* ), intent ( in ) :: a character ( len = :), allocatable :: q if ( is_windows_os ()) then q = '\"' // escape_quotes_win ( trim ( a )) // '\"' else q = \"'\" // escape_quotes_sh ( trim ( a )) // \"'\" end if contains pure function escape_quotes_win ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: j r = \"\" do j = 1 , len_trim ( s ) if ( s ( j : j ) == '\"' ) then r = r // '\"\"' else r = r // s ( j : j ) end if end do end function escape_quotes_win pure function escape_quotes_sh ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: j r = \"\" do j = 1 , len_trim ( s ) if ( s ( j : j ) == \"'\" ) then r = r // \"'\"\"'\"\"'\" else r = r // s ( j : j ) end if end do end function escape_quotes_sh end function quote_arg","tags":"","url":"proc/quote_arg.html"},{"title":"starts_with – fpm-watch","text":"public pure function starts_with(s, prefix) result(ok) Check whether a string begins with a given prefix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: prefix Return Value logical Called by proc~~starts_with~~CalledByGraph proc~starts_with starts_with proc~build_child_command build_child_command proc~build_child_command->proc~starts_with proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~starts_with proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~supervisor_loop supervisor_loop proc~maybe_supervise->proc~supervisor_loop proc~supervisor_loop->proc~build_child_command Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function starts_with ( s , prefix ) result ( ok ) character ( len =* ), intent ( in ) :: s , prefix integer :: n n = len_trim ( prefix ) if ( n <= 0 ) then ok = . true . else if ( len_trim ( s ) < n ) then ok = . false . else ok = ( s ( 1 : n ) == prefix ( 1 : n )) end if end function starts_with","tags":"","url":"proc/starts_with.html"},{"title":"feat_after_noop – fpm-watch","text":"private  subroutine feat_after_noop(self, exitstat, seconds) No-op callback invoked after executing the command. Type Bound watch_feature_t Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds Called by proc~~feat_after_noop~~CalledByGraph proc~feat_after_noop watch_feature_t%feat_after_noop proc~on_after_run_all feature_manager_t%on_after_run_all proc~on_after_run_all->proc~feat_after_noop proc~run_once run_once proc~run_once->proc~on_after_run_all proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~on_after_run_all proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~run_once Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine feat_after_noop ( self , exitstat , seconds ) class ( watch_feature_t ), intent ( inout ) :: self integer , intent ( in ) :: exitstat real , intent ( in ) :: seconds if (. false .) then if ( exitstat /= 0 ) continue if ( seconds < 0.0 ) continue end if end subroutine feat_after_noop","tags":"","url":"proc/feat_after_noop.html"},{"title":"feat_before_noop – fpm-watch","text":"private  subroutine feat_before_noop(self, cmd) No-op callback invoked just before executing the command. Type Bound watch_feature_t Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self character(len=:), intent(inout), allocatable :: cmd Called by proc~~feat_before_noop~~CalledByGraph proc~feat_before_noop watch_feature_t%feat_before_noop proc~on_before_run_all feature_manager_t%on_before_run_all proc~on_before_run_all->proc~feat_before_noop proc~run_once run_once proc~run_once->proc~on_before_run_all proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~on_before_run_all proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~run_once Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine feat_before_noop ( self , cmd ) class ( watch_feature_t ), intent ( inout ) :: self character ( len = :), allocatable , intent ( inout ) :: cmd if (. false .) then if ( allocated ( cmd )) continue end if end subroutine feat_before_noop","tags":"","url":"proc/feat_before_noop.html"},{"title":"feat_change_noop – fpm-watch","text":"private  subroutine feat_change_noop(self, changed) No-op callback for detected file changes. Type Bound watch_feature_t Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(in), allocatable :: changed (:) Called by proc~~feat_change_noop~~CalledByGraph proc~feat_change_noop watch_feature_t%feat_change_noop proc~on_change_detected_all feature_manager_t%on_change_detected_all proc~on_change_detected_all->proc~feat_change_noop proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~on_change_detected_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine feat_change_noop ( self , changed ) class ( watch_feature_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( in ) :: changed (:) if (. false .) then if ( allocated ( changed )) continue end if end subroutine feat_change_noop","tags":"","url":"proc/feat_change_noop.html"},{"title":"feat_init_noop – fpm-watch","text":"private  subroutine feat_init_noop(self, cfg) No-op init callback. Type Bound watch_feature_t Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg Called by proc~~feat_init_noop~~CalledByGraph proc~feat_init_noop watch_feature_t%feat_init_noop proc~init_all feature_manager_t%init_all proc~init_all->proc~feat_init_noop proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~init_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine feat_init_noop ( self , cfg ) class ( watch_feature_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg if (. false .) then if ( cfg % w % verbosity < - 1 ) continue end if end subroutine feat_init_noop","tags":"","url":"proc/feat_init_noop.html"},{"title":"feat_list_noop – fpm-watch","text":"private  subroutine feat_list_noop(self, files, roots) No-op callback for watch list rebuild completion. Type Bound watch_feature_t Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(inout), allocatable :: files (:) type( root_info_t ), intent(inout), allocatable :: roots (:) Called by proc~~feat_list_noop~~CalledByGraph proc~feat_list_noop watch_feature_t%feat_list_noop proc~on_watch_list_built_all feature_manager_t%on_watch_list_built_all proc~on_watch_list_built_all->proc~feat_list_noop proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~on_watch_list_built_all proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine feat_list_noop ( self , files , roots ) class ( watch_feature_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( inout ) :: files (:) type ( root_info_t ), allocatable , intent ( inout ) :: roots (:) if (. false .) then if ( allocated ( files )) continue if ( allocated ( roots )) continue end if end subroutine feat_list_noop","tags":"","url":"proc/feat_list_noop.html"},{"title":"feat_manifest_noop – fpm-watch","text":"private  subroutine feat_manifest_noop(self, old_key, new_key) No-op callback for manifest key change. Type Bound watch_feature_t Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self integer(kind=int64), intent(in) :: old_key integer(kind=int64), intent(in) :: new_key Called by proc~~feat_manifest_noop~~CalledByGraph proc~feat_manifest_noop watch_feature_t%feat_manifest_noop proc~on_manifest_changed_all feature_manager_t%on_manifest_changed_all proc~on_manifest_changed_all->proc~feat_manifest_noop proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~on_manifest_changed_all proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine feat_manifest_noop ( self , old_key , new_key ) class ( watch_feature_t ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: old_key , new_key if (. false .) then if ( old_key == new_key ) continue end if end subroutine feat_manifest_noop","tags":"","url":"proc/feat_manifest_noop.html"},{"title":"feat_noop – fpm-watch","text":"private  subroutine feat_noop(self) No-op start callback. Type Bound watch_feature_t Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self Called by proc~~feat_noop~~CalledByGraph proc~feat_noop watch_feature_t%feat_noop proc~on_start_all feature_manager_t%on_start_all proc~on_start_all->proc~feat_noop proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~on_start_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine feat_noop ( self ) class ( watch_feature_t ), intent ( inout ) :: self end subroutine feat_noop","tags":"","url":"proc/feat_noop.html"},{"title":"ftoa – fpm-watch","text":"public pure function ftoa(x) result(s) Format a real number with two decimal places. Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value character(len=:), allocatable Called by proc~~ftoa~~CalledByGraph proc~ftoa ftoa proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~ftoa proc~print_banner print_banner proc~print_banner->proc~ftoa proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~ftoa proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~rebuild_watch_list->proc~print_banner proc~report_changes report_changes proc~report_changes->proc~ftoa proc~run_command_and_report run_command_and_report proc~run_command_and_report->proc~ftoa proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~run_once run_once proc~run_once->proc~run_command_and_report proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_init->proc~run_once proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~report_changes proc~watcher_run->proc~run_command_and_report proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function ftoa ( x ) result ( s ) real , intent ( in ) :: x character ( len = :), allocatable :: s character ( len = 64 ) :: buf write ( buf , '(f0.2)' ) x s = trim ( buf ) end function ftoa","tags":"","url":"proc/ftoa.html"},{"title":"join_csv – fpm-watch","text":"public pure function join_csv(a, empty) result(s) Join a list of strings into a comma-separated value string. Empty entries are skipped. If all entries are empty (or the array is not\nallocated), returns the provided empty placeholder string. Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: a (:) character(len=*), intent(in) :: empty Return Value character(len=:), allocatable Called by proc~~join_csv~~CalledByGraph proc~join_csv join_csv proc~active_features active_features proc~active_features->proc~join_csv proc~print_banner print_banner proc~print_banner->proc~active_features proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~print_banner proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function join_csv ( a , empty ) result ( s ) type ( string_t ), allocatable , intent ( in ) :: a (:) character ( len =* ), intent ( in ) :: empty character ( len = :), allocatable :: s character ( len = :), allocatable :: tmp integer :: i tmp = \"\" if ( allocated ( a )) then do i = 1 , size ( a ) if ( len_trim ( a ( i )% s ) == 0 ) cycle if ( len ( tmp ) > 0 ) tmp = tmp // \",\" tmp = tmp // trim ( a ( i )% s ) end do end if if ( len ( tmp ) == 0 ) then s = empty else s = tmp end if end function join_csv","tags":"","url":"proc/join_csv.html"},{"title":"trim_or_default – fpm-watch","text":"public pure function trim_or_default(s, default) result(r) Trim an allocatable string or return a default if empty/unallocated. Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: s character(len=*), intent(in) :: default Return Value character(len=:), allocatable Called by proc~~trim_or_default~~CalledByGraph proc~trim_or_default trim_or_default proc~active_profile active_profile proc~active_profile->proc~trim_or_default proc~print_banner print_banner proc~print_banner->proc~trim_or_default proc~print_banner->proc~active_profile proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~print_banner proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function trim_or_default ( s , default ) result ( r ) character ( len = :), allocatable , intent ( in ) :: s character ( len =* ), intent ( in ) :: default character ( len = :), allocatable :: r if ( allocated ( s )) then if ( len_trim ( s ) > 0 ) then r = trim ( s ) else r = default end if else r = default end if end function trim_or_default","tags":"","url":"proc/trim_or_default.html"},{"title":"trim_or_empty – fpm-watch","text":"public pure function trim_or_empty(s) result(r) Trim an allocatable string or return an empty string if unallocated. Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: s Return Value character(len=:), allocatable Called by proc~~trim_or_empty~~CalledByGraph proc~trim_or_empty trim_or_empty proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~trim_or_empty proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function trim_or_empty ( s ) result ( r ) character ( len = :), allocatable , intent ( in ) :: s character ( len = :), allocatable :: r if ( allocated ( s )) then r = trim ( s ) else r = \"\" end if end function trim_or_empty","tags":"","url":"proc/trim_or_empty.html"},{"title":"sort_unique_strings – fpm-watch","text":"public  subroutine sort_unique_strings(a) Sort an array of strings and remove duplicates. Sorting is lexicographic on string_t%s . Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: a (:) Source Code subroutine sort_unique_strings ( a ) type ( string_t ), allocatable , intent ( inout ) :: a (:) type ( string_t ), allocatable :: out (:) integer :: i , nuniq if (. not . allocated ( a )) return if ( size ( a ) <= 1 ) return call qsort ( a , 1 , size ( a )) nuniq = 1 do i = 2 , size ( a ) if ( a ( i )% s /= a ( i - 1 )% s ) nuniq = nuniq + 1 end do if ( nuniq == size ( a )) return allocate ( out ( nuniq )) out ( 1 ) = a ( 1 ) nuniq = 1 do i = 2 , size ( a ) if ( a ( i )% s == a ( i - 1 )% s ) cycle nuniq = nuniq + 1 out ( nuniq ) = a ( i ) end do call move_alloc ( out , a ) contains recursive subroutine qsort ( x , lo , hi ) type ( string_t ), intent ( inout ) :: x (:) integer , intent ( in ) :: lo , hi integer :: i , j character ( len = :), allocatable :: p type ( string_t ) :: t if ( lo >= hi ) return i = lo j = hi p = x (( lo + hi ) / 2 )% s do do while ( x ( i )% s < p ) i = i + 1 end do do while ( p < x ( j )% s ) j = j - 1 end do if ( i <= j ) then t = x ( i ) x ( i ) = x ( j ) x ( j ) = t i = i + 1 j = j - 1 end if if ( i > j ) exit end do if ( lo < j ) call qsort ( x , lo , j ) if ( i < hi ) call qsort ( x , i , hi ) end subroutine qsort end subroutine sort_unique_strings","tags":"","url":"proc/sort_unique_strings.html"},{"title":"accum_push – fpm-watch","text":"private  subroutine accum_push(self, s) Append a string to the accumulator (grows capacity as needed). Type Bound string_accum_t Arguments Type Intent Optional Attributes Name class( string_accum_t ), intent(inout) :: self character(len=*), intent(in) :: s Source Code subroutine accum_push ( self , s ) class ( string_accum_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: s type ( string_t ), allocatable :: tmp (:) integer :: cap if ( len_trim ( s ) == 0 ) return if (. not . allocated ( self % a )) then allocate ( self % a ( 256 )) self % n = 0 end if cap = size ( self % a ) if ( self % n >= cap ) then allocate ( tmp ( max ( 1 , 2 * cap ))) if ( cap > 0 ) tmp ( 1 : cap ) = self % a ( 1 : cap ) call move_alloc ( tmp , self % a ) end if self % n = self % n + 1 self % a ( self % n )% s = s end subroutine accum_push","tags":"","url":"proc/accum_push.html"},{"title":"accum_to_array – fpm-watch","text":"private  subroutine accum_to_array(self, out) Materialize the accumulator into a right-sized array. The accumulator storage is released after conversion. Type Bound string_accum_t Arguments Type Intent Optional Attributes Name class( string_accum_t ), intent(inout) :: self type(string_t), intent(out), allocatable :: out (:) Source Code subroutine accum_to_array ( self , out ) class ( string_accum_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( out ) :: out (:) if (. not . allocated ( self % a ) . or . self % n <= 0 ) then allocate ( out ( 0 )) return end if allocate ( out ( self % n )) out = self % a ( 1 : self % n ) deallocate ( self % a ) self % n = 0 end subroutine accum_to_array","tags":"","url":"proc/accum_to_array.html"},{"title":"fm_add – fpm-watch","text":"private  subroutine fm_add(self, f) Add a feature instance to the manager, transferring ownership. The f argument is moved into internal storage using move_alloc . Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self class( watch_feature_t ), intent(inout), allocatable :: f Called by proc~~fm_add~~CalledByGraph proc~fm_add feature_manager_t%fm_add proc~add_stats add_stats proc~add_stats->proc~fm_add proc~enable_features enable_features proc~enable_features->proc~add_stats proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~enable_features Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fm_add ( self , f ) class ( feature_manager_t ), intent ( inout ) :: self class ( watch_feature_t ), allocatable , intent ( inout ) :: f type ( feature_box_t ), allocatable :: tmp (:) integer :: n , i if (. not . allocated ( self % feat )) then allocate ( self % feat ( 1 )) call move_alloc ( f , self % feat ( 1 )% p ) return end if n = size ( self % feat ) allocate ( tmp ( n + 1 )) do i = 1 , n call move_alloc ( self % feat ( i )% p , tmp ( i )% p ) end do call move_alloc ( f , tmp ( n + 1 )% p ) call move_alloc ( tmp , self % feat ) end subroutine fm_add","tags":"","url":"proc/fm_add.html"},{"title":"init_all – fpm-watch","text":"private  subroutine init_all(self, cfg) Call init(cfg) on all registered features. Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg Calls proc~~init_all~~CallsGraph proc~init_all feature_manager_t%init_all proc~feat_init_noop watch_feature_t%feat_init_noop proc~init_all->proc~feat_init_noop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_all~~CalledByGraph proc~init_all feature_manager_t%init_all proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~init_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_all ( self , cfg ) class ( feature_manager_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % init ( cfg ) end do end subroutine init_all","tags":"","url":"proc/init_all.html"},{"title":"on_after_run_all – fpm-watch","text":"private  subroutine on_after_run_all(self, exitstat, seconds) Call on_after_run(exitstat, seconds) on all registered features. Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds Calls proc~~on_after_run_all~~CallsGraph proc~on_after_run_all feature_manager_t%on_after_run_all proc~feat_after_noop watch_feature_t%feat_after_noop proc~on_after_run_all->proc~feat_after_noop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~on_after_run_all~~CalledByGraph proc~on_after_run_all feature_manager_t%on_after_run_all proc~run_once run_once proc~run_once->proc~on_after_run_all proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~on_after_run_all proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~run_once Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine on_after_run_all ( self , exitstat , seconds ) class ( feature_manager_t ), intent ( inout ) :: self integer , intent ( in ) :: exitstat real , intent ( in ) :: seconds integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_after_run ( exitstat , seconds ) end do end subroutine on_after_run_all","tags":"","url":"proc/on_after_run_all.html"},{"title":"on_before_run_all – fpm-watch","text":"private  subroutine on_before_run_all(self, cmd) Call on_before_run(cmd) on all registered features. Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self character(len=:), intent(inout), allocatable :: cmd Calls proc~~on_before_run_all~~CallsGraph proc~on_before_run_all feature_manager_t%on_before_run_all proc~feat_before_noop watch_feature_t%feat_before_noop proc~on_before_run_all->proc~feat_before_noop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~on_before_run_all~~CalledByGraph proc~on_before_run_all feature_manager_t%on_before_run_all proc~run_once run_once proc~run_once->proc~on_before_run_all proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~on_before_run_all proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~run_once Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine on_before_run_all ( self , cmd ) class ( feature_manager_t ), intent ( inout ) :: self character ( len = :), allocatable , intent ( inout ) :: cmd integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_before_run ( cmd ) end do end subroutine on_before_run_all","tags":"","url":"proc/on_before_run_all.html"},{"title":"on_change_detected_all – fpm-watch","text":"private  subroutine on_change_detected_all(self, changed) Call on_change_detected(changed) on all registered features. Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type(string_t), intent(in), allocatable :: changed (:) Calls proc~~on_change_detected_all~~CallsGraph proc~on_change_detected_all feature_manager_t%on_change_detected_all proc~feat_change_noop watch_feature_t%feat_change_noop proc~on_change_detected_all->proc~feat_change_noop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~on_change_detected_all~~CalledByGraph proc~on_change_detected_all feature_manager_t%on_change_detected_all proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~on_change_detected_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine on_change_detected_all ( self , changed ) class ( feature_manager_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( in ) :: changed (:) integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_change_detected ( changed ) end do end subroutine on_change_detected_all","tags":"","url":"proc/on_change_detected_all.html"},{"title":"on_manifest_changed_all – fpm-watch","text":"private  subroutine on_manifest_changed_all(self, old_key, new_key) Call on_manifest_changed(old_key, new_key) on all registered features. Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self integer(kind=int64), intent(in) :: old_key integer(kind=int64), intent(in) :: new_key Calls proc~~on_manifest_changed_all~~CallsGraph proc~on_manifest_changed_all feature_manager_t%on_manifest_changed_all proc~feat_manifest_noop watch_feature_t%feat_manifest_noop proc~on_manifest_changed_all->proc~feat_manifest_noop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~on_manifest_changed_all~~CalledByGraph proc~on_manifest_changed_all feature_manager_t%on_manifest_changed_all proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~on_manifest_changed_all proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine on_manifest_changed_all ( self , old_key , new_key ) class ( feature_manager_t ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: old_key , new_key integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_manifest_changed ( old_key , new_key ) end do end subroutine on_manifest_changed_all","tags":"","url":"proc/on_manifest_changed_all.html"},{"title":"on_start_all – fpm-watch","text":"private  subroutine on_start_all(self) Call on_start() on all registered features. Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self Calls proc~~on_start_all~~CallsGraph proc~on_start_all feature_manager_t%on_start_all proc~feat_noop watch_feature_t%feat_noop proc~on_start_all->proc~feat_noop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~on_start_all~~CalledByGraph proc~on_start_all feature_manager_t%on_start_all proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~on_start_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine on_start_all ( self ) class ( feature_manager_t ), intent ( inout ) :: self integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_start () end do end subroutine on_start_all","tags":"","url":"proc/on_start_all.html"},{"title":"on_watch_list_built_all – fpm-watch","text":"private  subroutine on_watch_list_built_all(self, files, roots) Call on_watch_list_built(files, roots) on all registered features. Type Bound feature_manager_t Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type(string_t), intent(inout), allocatable :: files (:) type( root_info_t ), intent(inout), allocatable :: roots (:) Calls proc~~on_watch_list_built_all~~CallsGraph proc~on_watch_list_built_all feature_manager_t%on_watch_list_built_all proc~feat_list_noop watch_feature_t%feat_list_noop proc~on_watch_list_built_all->proc~feat_list_noop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~on_watch_list_built_all~~CalledByGraph proc~on_watch_list_built_all feature_manager_t%on_watch_list_built_all proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~on_watch_list_built_all proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine on_watch_list_built_all ( self , files , roots ) class ( feature_manager_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( inout ) :: files (:) type ( root_info_t ), allocatable , intent ( inout ) :: roots (:) integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_watch_list_built ( files , roots ) end do end subroutine on_watch_list_built_all","tags":"","url":"proc/on_watch_list_built_all.html"},{"title":"any_manifest_changed – fpm-watch","text":"private  function any_manifest_changed(files, changed_idx, changed_count) result(hit) Return whether the changed set contains fpm.toml . This detection is based on the basename only and therefore triggers if\nany watched file named fpm.toml changes (main or dependency manifests). Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count Return Value logical Calls proc~~any_manifest_changed~~CallsGraph proc~any_manifest_changed any_manifest_changed basename basename proc~any_manifest_changed->basename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~any_manifest_changed~~CalledByGraph proc~any_manifest_changed any_manifest_changed proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~any_manifest_changed Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code logical function any_manifest_changed ( files , changed_idx , changed_count ) result ( hit ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count integer :: j , idx character ( len = :), allocatable :: b hit = . false . if (. not . allocated ( files )) return do j = 1 , changed_count idx = changed_idx ( j ) if ( idx < 1 . or . idx > size ( files )) cycle b = basename ( files ( idx )% s ) if ( b == \"fpm.toml\" ) then hit = . true . return end if end do end function any_manifest_changed","tags":"","url":"proc/any_manifest_changed.html"},{"title":"handle_manifest_change – fpm-watch","text":"private  subroutine handle_manifest_change(self) Handle a manifest change ( fpm.toml ) by rebuilding the watch list. This also notifies feature plugins via on_manifest_changed . Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self Calls proc~~handle_manifest_change~~CallsGraph proc~handle_manifest_change handle_manifest_change proc~log_info log_info proc~handle_manifest_change->proc~log_info proc~manifest_key_from_files manifest_key_from_files proc~handle_manifest_change->proc~manifest_key_from_files proc~on_manifest_changed_all feature_manager_t%on_manifest_changed_all proc~handle_manifest_change->proc~on_manifest_changed_all proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change->proc~rebuild_watch_list colorize colorize proc~log_info->colorize basename basename proc~manifest_key_from_files->basename features features proc~manifest_key_from_files->features proc~file_fingerprint file_fingerprint proc~manifest_key_from_files->proc~file_fingerprint proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~manifest_key_from_files->proc~fnv1a_mix_i64 proc~fnv1a_mix_str fnv1a_mix_str proc~manifest_key_from_files->proc~fnv1a_mix_str proc~feat_manifest_noop watch_feature_t%feat_manifest_noop proc~on_manifest_changed_all->proc~feat_manifest_noop proc~rebuild_watch_list->proc~log_info proc~rebuild_watch_list->proc~manifest_key_from_files proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~ftoa ftoa proc~rebuild_watch_list->proc~ftoa proc~init_fingerprints init_fingerprints proc~rebuild_watch_list->proc~init_fingerprints proc~on_watch_list_built_all feature_manager_t%on_watch_list_built_all proc~rebuild_watch_list->proc~on_watch_list_built_all proc~print_banner print_banner proc~rebuild_watch_list->proc~print_banner proc~print_file_list print_file_list proc~rebuild_watch_list->proc~print_file_list str str proc~rebuild_watch_list->str proc~compute_watch_files_from_settings->proc~log_info proc~compute_watch_files_from_settings->basename proc~compute_watch_files_from_settings->proc~ftoa proc~compute_watch_files_from_settings->str add add proc~compute_watch_files_from_settings->add build_model build_model proc~compute_watch_files_from_settings->build_model dep dep proc~compute_watch_files_from_settings->dep get_package_data get_package_data proc~compute_watch_files_from_settings->get_package_data is_executable_target is_executable_target proc~compute_watch_files_from_settings->is_executable_target join_path join_path proc~compute_watch_files_from_settings->join_path new_dependency_tree new_dependency_tree proc~compute_watch_files_from_settings->new_dependency_tree proc~dfs_mark_bool dfs_mark_bool proc~compute_watch_files_from_settings->proc~dfs_mark_bool proc~dfs_mark_mask dfs_mark_mask proc~compute_watch_files_from_settings->proc~dfs_mark_mask proc~filter_watch_files filter_watch_files proc~compute_watch_files_from_settings->proc~filter_watch_files proc~gather_files_with_mask gather_files_with_mask proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~is_run_or_test is_run_or_test proc~compute_watch_files_from_settings->proc~is_run_or_test proc~normalize_path normalize_path proc~compute_watch_files_from_settings->proc~normalize_path proc~push_file_with_mask push_file_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~select_names_or_all select_names_or_all proc~compute_watch_files_from_settings->proc~select_names_or_all proc~trim_or_empty trim_or_empty proc~compute_watch_files_from_settings->proc~trim_or_empty targets_from_sources targets_from_sources proc~compute_watch_files_from_settings->targets_from_sources proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~fnv1a_mix_str->proc~fnv1a_mix_i64 proc~init_fingerprints->proc~file_fingerprint proc~feat_list_noop watch_feature_t%feat_list_noop proc~on_watch_list_built_all->proc~feat_list_noop proc~print_banner->colorize proc~print_banner->proc~ftoa proc~print_banner->str proc~active_features active_features proc~print_banner->proc~active_features proc~active_profile active_profile proc~print_banner->proc~active_profile proc~command_mode command_mode proc~print_banner->proc~command_mode proc~trim_or_default trim_or_default proc~print_banner->proc~trim_or_default proc~print_file_list->colorize proc~print_file_list->str proc~join_csv join_csv proc~active_features->proc~join_csv proc~active_profile->proc~trim_or_default proc~dfs_mark_bool->proc~dfs_mark_bool dependencies dependencies proc~dfs_mark_bool->dependencies proc~find_ptr_index find_ptr_index proc~dfs_mark_bool->proc~find_ptr_index proc~dfs_mark_mask->proc~dfs_mark_mask proc~dfs_mark_mask->dependencies proc~dfs_mark_mask->proc~find_ptr_index proc~filter_watch_files->basename proc~filter_watch_files->proc~normalize_path glob glob proc~filter_watch_files->glob include_dependencies include_dependencies proc~gather_files_with_mask->include_dependencies proc~vec_push_unique vec_push_unique proc~gather_files_with_mask->proc~vec_push_unique proc~hash_block->proc~fnv1a_mix_i64 proc~push_file_with_mask->proc~vec_push_unique proc~select_names_or_all->basename proc~select_names_or_all->is_executable_target proc~select_names_or_all->glob proc~vec_push_unique->proc~normalize_path exists exists proc~vec_push_unique->exists proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~handle_manifest_change~~CalledByGraph proc~handle_manifest_change handle_manifest_change proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine handle_manifest_change ( self ) class ( watcher_t ), intent ( inout ) :: self integer ( int64 ) :: man_now man_now = manifest_key_from_files ( self % cfg % settings , self % files ) if ( man_now /= self % man_prev ) then call self % fm % on_manifest_changed_all ( self % man_prev , man_now ) self % man_prev = man_now end if call log_info ( self % cfg % w , \"manifest changed -> rebuilding watch list\" ) call rebuild_watch_list ( self , print_header = . false .) end subroutine handle_manifest_change","tags":"","url":"proc/handle_manifest_change.html"},{"title":"rebuild_watch_list – fpm-watch","text":"private  subroutine rebuild_watch_list(self, print_header) Recompute the watch list, rebuild fingerprints, and print/log the result. Called:\n- During initialization,\n- When the manifest changes,\n- Periodically when rescan > 0 . Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self logical, intent(in) :: print_header Calls proc~~rebuild_watch_list~~CallsGraph proc~rebuild_watch_list rebuild_watch_list proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~ftoa ftoa proc~rebuild_watch_list->proc~ftoa proc~init_fingerprints init_fingerprints proc~rebuild_watch_list->proc~init_fingerprints proc~log_info log_info proc~rebuild_watch_list->proc~log_info proc~manifest_key_from_files manifest_key_from_files proc~rebuild_watch_list->proc~manifest_key_from_files proc~on_watch_list_built_all feature_manager_t%on_watch_list_built_all proc~rebuild_watch_list->proc~on_watch_list_built_all proc~print_banner print_banner proc~rebuild_watch_list->proc~print_banner proc~print_file_list print_file_list proc~rebuild_watch_list->proc~print_file_list str str proc~rebuild_watch_list->str proc~compute_watch_files_from_settings->proc~ftoa proc~compute_watch_files_from_settings->proc~log_info proc~compute_watch_files_from_settings->str add add proc~compute_watch_files_from_settings->add basename basename proc~compute_watch_files_from_settings->basename build_model build_model proc~compute_watch_files_from_settings->build_model dep dep proc~compute_watch_files_from_settings->dep get_package_data get_package_data proc~compute_watch_files_from_settings->get_package_data is_executable_target is_executable_target proc~compute_watch_files_from_settings->is_executable_target join_path join_path proc~compute_watch_files_from_settings->join_path new_dependency_tree new_dependency_tree proc~compute_watch_files_from_settings->new_dependency_tree proc~dfs_mark_bool dfs_mark_bool proc~compute_watch_files_from_settings->proc~dfs_mark_bool proc~dfs_mark_mask dfs_mark_mask proc~compute_watch_files_from_settings->proc~dfs_mark_mask proc~filter_watch_files filter_watch_files proc~compute_watch_files_from_settings->proc~filter_watch_files proc~gather_files_with_mask gather_files_with_mask proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~is_run_or_test is_run_or_test proc~compute_watch_files_from_settings->proc~is_run_or_test proc~normalize_path normalize_path proc~compute_watch_files_from_settings->proc~normalize_path proc~push_file_with_mask push_file_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~select_names_or_all select_names_or_all proc~compute_watch_files_from_settings->proc~select_names_or_all proc~trim_or_empty trim_or_empty proc~compute_watch_files_from_settings->proc~trim_or_empty targets_from_sources targets_from_sources proc~compute_watch_files_from_settings->targets_from_sources proc~file_fingerprint file_fingerprint proc~init_fingerprints->proc~file_fingerprint colorize colorize proc~log_info->colorize proc~manifest_key_from_files->basename features features proc~manifest_key_from_files->features proc~manifest_key_from_files->proc~file_fingerprint proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~manifest_key_from_files->proc~fnv1a_mix_i64 proc~fnv1a_mix_str fnv1a_mix_str proc~manifest_key_from_files->proc~fnv1a_mix_str proc~feat_list_noop watch_feature_t%feat_list_noop proc~on_watch_list_built_all->proc~feat_list_noop proc~print_banner->proc~ftoa proc~print_banner->str proc~print_banner->colorize proc~active_features active_features proc~print_banner->proc~active_features proc~active_profile active_profile proc~print_banner->proc~active_profile proc~command_mode command_mode proc~print_banner->proc~command_mode proc~trim_or_default trim_or_default proc~print_banner->proc~trim_or_default proc~print_file_list->str proc~print_file_list->colorize proc~join_csv join_csv proc~active_features->proc~join_csv proc~active_profile->proc~trim_or_default proc~dfs_mark_bool->proc~dfs_mark_bool dependencies dependencies proc~dfs_mark_bool->dependencies proc~find_ptr_index find_ptr_index proc~dfs_mark_bool->proc~find_ptr_index proc~dfs_mark_mask->proc~dfs_mark_mask proc~dfs_mark_mask->dependencies proc~dfs_mark_mask->proc~find_ptr_index proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~filter_watch_files->basename proc~filter_watch_files->proc~normalize_path glob glob proc~filter_watch_files->glob proc~fnv1a_mix_str->proc~fnv1a_mix_i64 include_dependencies include_dependencies proc~gather_files_with_mask->include_dependencies proc~vec_push_unique vec_push_unique proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask->proc~vec_push_unique proc~select_names_or_all->basename proc~select_names_or_all->is_executable_target proc~select_names_or_all->glob proc~hash_block->proc~fnv1a_mix_i64 proc~vec_push_unique->proc~normalize_path exists exists proc~vec_push_unique->exists proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rebuild_watch_list~~CalledByGraph proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine rebuild_watch_list ( self , print_header ) class ( watcher_t ), intent ( inout ) :: self logical , intent ( in ) :: print_header integer ( int64 ) :: rate , t0 , t1 real :: build_secs_total real :: secs_model , secs_targets , secs_watch integer :: nfiles , nroots real :: dummy_build type ( string_t ), allocatable :: new_files (:) integer ( int64 ), allocatable :: new_mask (:) type ( root_info_t ), allocatable :: new_roots (:) call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 call system_clock ( t0 ) call compute_watch_files_from_settings ( & settings = self % cfg % settings , & w = self % cfg % w , & files = new_files , & file_mask = new_mask , & roots = new_roots , & manifest_key = self % man_prev , & build_secs = dummy_build , & secs_model = secs_model , & secs_targets = secs_targets , & secs_watch = secs_watch ) call move_alloc ( new_files , self % files ) call move_alloc ( new_mask , self % file_mask ) call move_alloc ( new_roots , self % roots ) call self % fm % on_watch_list_built_all ( self % files , self % roots ) self % man_prev = manifest_key_from_files ( self % cfg % settings , self % files ) call init_fingerprints ( self % files , self % fp_prev , self % fp_now , self % changed_idx ) call system_clock ( t1 ) build_secs_total = real ( t1 - t0 ) / real ( rate ) nfiles = 0 if ( allocated ( self % files )) nfiles = size ( self % files ) nroots = 0 if ( allocated ( self % roots )) nroots = size ( self % roots ) if ( self % cfg % w % debug ) then call log_info ( self % cfg % w , \"debug: manifest_key=\" // str ( self % man_prev )) call log_info ( self % cfg % w , \"debug: roots=\" // str ( nroots ) // \" files=\" // str ( nfiles )) end if if ( print_header ) then call print_banner ( & full_cmdline = self % cfg % fpm_cmdline , & settings = self % cfg % settings , & w = self % cfg % w , & files = self % files , & build_secs = build_secs_total , & roots_count = nroots , & secs_model = secs_model , & secs_targets = secs_targets , & secs_watch = secs_watch ) if ( self % cfg % w % print_files_once ) call print_file_list ( self % files , self % cfg % w ) else call log_info ( self % cfg % w , \"watch list updated in \" // ftoa ( build_secs_total ) // \"s; files=\" // str ( nfiles )) if ( self % cfg % w % verbosity >= 2 ) call print_file_list ( self % files , self % cfg % w ) end if end subroutine rebuild_watch_list","tags":"","url":"proc/rebuild_watch_list.html"},{"title":"run_once – fpm-watch","text":"private  subroutine run_once(self, cmd0) Run the configured command once without change detection. Used for the optional \"run on start\" behavior. Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self character(len=*), intent(in) :: cmd0 Calls proc~~run_once~~CallsGraph proc~run_once run_once proc~on_after_run_all feature_manager_t%on_after_run_all proc~run_once->proc~on_after_run_all proc~on_before_run_all feature_manager_t%on_before_run_all proc~run_once->proc~on_before_run_all proc~run_command_and_report run_command_and_report proc~run_once->proc~run_command_and_report proc~feat_after_noop watch_feature_t%feat_after_noop proc~on_after_run_all->proc~feat_after_noop proc~feat_before_noop watch_feature_t%feat_before_noop proc~on_before_run_all->proc~feat_before_noop colorize colorize proc~run_command_and_report->colorize proc~ftoa ftoa proc~run_command_and_report->proc~ftoa run run proc~run_command_and_report->run str str proc~run_command_and_report->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_once~~CalledByGraph proc~run_once run_once proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~run_once Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine run_once ( self , cmd0 ) class ( watcher_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: cmd0 character ( len = :), allocatable :: cmd integer :: exitstat real :: secs cmd = trim ( cmd0 ) call self % fm % on_before_run_all ( cmd ) call run_command_and_report ( cmd , self % cfg % w , exitstat , secs ) call self % fm % on_after_run_all ( exitstat , secs ) end subroutine run_once","tags":"","url":"proc/run_once.html"},{"title":"watcher_init – fpm-watch","text":"private  subroutine watcher_init(self, cfg) Initialize a watcher instance from configuration. This routine:\n- Applies low-CPU mode selection to the sleep implementation.\n- Enables requested feature plugins and calls their init/start callbacks.\n- Builds the initial watch list and fingerprints.\n- Optionally performs an initial run ( w%run_on_start ). Type Bound watcher_t Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg Calls proc~~watcher_init~~CallsGraph proc~watcher_init watcher_t%watcher_init proc~enable_features enable_features proc~watcher_init->proc~enable_features proc~init_all feature_manager_t%init_all proc~watcher_init->proc~init_all proc~on_start_all feature_manager_t%on_start_all proc~watcher_init->proc~on_start_all proc~rebuild_watch_list rebuild_watch_list proc~watcher_init->proc~rebuild_watch_list proc~run_once run_once proc~watcher_init->proc~run_once proc~set_low_cpu set_low_cpu proc~watcher_init->proc~set_low_cpu proc~add_stats add_stats proc~enable_features->proc~add_stats proc~log_warn log_warn proc~enable_features->proc~log_warn proc~feat_init_noop watch_feature_t%feat_init_noop proc~init_all->proc~feat_init_noop proc~feat_noop watch_feature_t%feat_noop proc~on_start_all->proc~feat_noop proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~ftoa ftoa proc~rebuild_watch_list->proc~ftoa proc~init_fingerprints init_fingerprints proc~rebuild_watch_list->proc~init_fingerprints proc~log_info log_info proc~rebuild_watch_list->proc~log_info proc~manifest_key_from_files manifest_key_from_files proc~rebuild_watch_list->proc~manifest_key_from_files proc~on_watch_list_built_all feature_manager_t%on_watch_list_built_all proc~rebuild_watch_list->proc~on_watch_list_built_all proc~print_banner print_banner proc~rebuild_watch_list->proc~print_banner proc~print_file_list print_file_list proc~rebuild_watch_list->proc~print_file_list str str proc~rebuild_watch_list->str proc~on_after_run_all feature_manager_t%on_after_run_all proc~run_once->proc~on_after_run_all proc~on_before_run_all feature_manager_t%on_before_run_all proc~run_once->proc~on_before_run_all proc~run_command_and_report run_command_and_report proc~run_once->proc~run_command_and_report proc~fm_add feature_manager_t%fm_add proc~add_stats->proc~fm_add proc~new_stats_feature new_stats_feature proc~add_stats->proc~new_stats_feature proc~compute_watch_files_from_settings->proc~ftoa proc~compute_watch_files_from_settings->proc~log_info proc~compute_watch_files_from_settings->str add add proc~compute_watch_files_from_settings->add basename basename proc~compute_watch_files_from_settings->basename build_model build_model proc~compute_watch_files_from_settings->build_model dep dep proc~compute_watch_files_from_settings->dep get_package_data get_package_data proc~compute_watch_files_from_settings->get_package_data is_executable_target is_executable_target proc~compute_watch_files_from_settings->is_executable_target join_path join_path proc~compute_watch_files_from_settings->join_path new_dependency_tree new_dependency_tree proc~compute_watch_files_from_settings->new_dependency_tree proc~dfs_mark_bool dfs_mark_bool proc~compute_watch_files_from_settings->proc~dfs_mark_bool proc~dfs_mark_mask dfs_mark_mask proc~compute_watch_files_from_settings->proc~dfs_mark_mask proc~filter_watch_files filter_watch_files proc~compute_watch_files_from_settings->proc~filter_watch_files proc~gather_files_with_mask gather_files_with_mask proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~is_run_or_test is_run_or_test proc~compute_watch_files_from_settings->proc~is_run_or_test proc~normalize_path normalize_path proc~compute_watch_files_from_settings->proc~normalize_path proc~push_file_with_mask push_file_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~select_names_or_all select_names_or_all proc~compute_watch_files_from_settings->proc~select_names_or_all proc~trim_or_empty trim_or_empty proc~compute_watch_files_from_settings->proc~trim_or_empty targets_from_sources targets_from_sources proc~compute_watch_files_from_settings->targets_from_sources proc~file_fingerprint file_fingerprint proc~init_fingerprints->proc~file_fingerprint colorize colorize proc~log_info->colorize proc~log_warn->colorize proc~manifest_key_from_files->basename features features proc~manifest_key_from_files->features proc~manifest_key_from_files->proc~file_fingerprint proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~manifest_key_from_files->proc~fnv1a_mix_i64 proc~fnv1a_mix_str fnv1a_mix_str proc~manifest_key_from_files->proc~fnv1a_mix_str proc~feat_after_noop watch_feature_t%feat_after_noop proc~on_after_run_all->proc~feat_after_noop proc~feat_before_noop watch_feature_t%feat_before_noop proc~on_before_run_all->proc~feat_before_noop proc~feat_list_noop watch_feature_t%feat_list_noop proc~on_watch_list_built_all->proc~feat_list_noop proc~print_banner->proc~ftoa proc~print_banner->str proc~print_banner->colorize proc~active_features active_features proc~print_banner->proc~active_features proc~active_profile active_profile proc~print_banner->proc~active_profile proc~command_mode command_mode proc~print_banner->proc~command_mode proc~trim_or_default trim_or_default proc~print_banner->proc~trim_or_default proc~print_file_list->str proc~print_file_list->colorize proc~run_command_and_report->proc~ftoa proc~run_command_and_report->str proc~run_command_and_report->colorize run run proc~run_command_and_report->run proc~join_csv join_csv proc~active_features->proc~join_csv proc~active_profile->proc~trim_or_default proc~dfs_mark_bool->proc~dfs_mark_bool dependencies dependencies proc~dfs_mark_bool->dependencies proc~find_ptr_index find_ptr_index proc~dfs_mark_bool->proc~find_ptr_index proc~dfs_mark_mask->proc~dfs_mark_mask proc~dfs_mark_mask->dependencies proc~dfs_mark_mask->proc~find_ptr_index proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~filter_watch_files->basename proc~filter_watch_files->proc~normalize_path glob glob proc~filter_watch_files->glob proc~fnv1a_mix_str->proc~fnv1a_mix_i64 include_dependencies include_dependencies proc~gather_files_with_mask->include_dependencies proc~vec_push_unique vec_push_unique proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask->proc~vec_push_unique proc~select_names_or_all->basename proc~select_names_or_all->is_executable_target proc~select_names_or_all->glob proc~hash_block->proc~fnv1a_mix_i64 proc~vec_push_unique->proc~normalize_path exists exists proc~vec_push_unique->exists proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine watcher_init ( self , cfg ) class ( watcher_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg self % cfg = cfg call set_low_cpu ( self % cfg % w % low_cpu ) call enable_features ( self % fm , self % cfg % w ) call self % fm % init_all ( self % cfg ) call self % fm % on_start_all () call rebuild_watch_list ( self , print_header = . true .) if ( self % cfg % w % run_on_start ) then call run_once ( self , trim ( self % cfg % fpm_cmdline )) end if end subroutine watcher_init","tags":"","url":"proc/watcher_init.html"},{"title":"watcher_run – fpm-watch","text":"private  subroutine watcher_run(self) Run the main watch loop until termination. Termination conditions:\n- The sentinel file .fpm-watch.stop exists, or\n- The process receives an external termination (e.g., Ctrl+C). Each iteration performs:\n1. Sleep for poll seconds.\n2. Scan for changes (fingerprints).\n3. If changes were found, sleep for debounce seconds and rescan.\n4. If fpm.toml changed, rebuild watch list.\n5. Otherwise, run the computed fpm command (with target injection\n   for run/test), notify plugins, and accept fingerprints. Type Bound watcher_t Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self Calls proc~~watcher_run~~CallsGraph proc~watcher_run watcher_t%watcher_run exists exists proc~watcher_run->exists proc~accept_changes accept_changes proc~watcher_run->proc~accept_changes proc~any_manifest_changed any_manifest_changed proc~watcher_run->proc~any_manifest_changed proc~build_run_command build_run_command proc~watcher_run->proc~build_run_command proc~handle_manifest_change handle_manifest_change proc~watcher_run->proc~handle_manifest_change proc~log_info log_info proc~watcher_run->proc~log_info proc~on_after_run_all feature_manager_t%on_after_run_all proc~watcher_run->proc~on_after_run_all proc~on_before_run_all feature_manager_t%on_before_run_all proc~watcher_run->proc~on_before_run_all proc~on_change_detected_all feature_manager_t%on_change_detected_all proc~watcher_run->proc~on_change_detected_all proc~rebuild_watch_list rebuild_watch_list proc~watcher_run->proc~rebuild_watch_list proc~report_changes report_changes proc~watcher_run->proc~report_changes proc~run_command_and_report run_command_and_report proc~watcher_run->proc~run_command_and_report proc~scan_changes scan_changes proc~watcher_run->proc~scan_changes proc~sleep_seconds sleep_seconds proc~watcher_run->proc~sleep_seconds basename basename proc~any_manifest_changed->basename proc~inject_names_into_cmd inject_names_into_cmd proc~build_run_command->proc~inject_names_into_cmd proc~handle_manifest_change->proc~log_info proc~handle_manifest_change->proc~rebuild_watch_list proc~manifest_key_from_files manifest_key_from_files proc~handle_manifest_change->proc~manifest_key_from_files proc~on_manifest_changed_all feature_manager_t%on_manifest_changed_all proc~handle_manifest_change->proc~on_manifest_changed_all colorize colorize proc~log_info->colorize proc~feat_after_noop watch_feature_t%feat_after_noop proc~on_after_run_all->proc~feat_after_noop proc~feat_before_noop watch_feature_t%feat_before_noop proc~on_before_run_all->proc~feat_before_noop proc~feat_change_noop watch_feature_t%feat_change_noop proc~on_change_detected_all->proc~feat_change_noop proc~rebuild_watch_list->proc~log_info proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~ftoa ftoa proc~rebuild_watch_list->proc~ftoa proc~init_fingerprints init_fingerprints proc~rebuild_watch_list->proc~init_fingerprints proc~rebuild_watch_list->proc~manifest_key_from_files proc~on_watch_list_built_all feature_manager_t%on_watch_list_built_all proc~rebuild_watch_list->proc~on_watch_list_built_all proc~print_banner print_banner proc~rebuild_watch_list->proc~print_banner proc~print_file_list print_file_list proc~rebuild_watch_list->proc~print_file_list str str proc~rebuild_watch_list->str proc~report_changes->colorize proc~report_changes->proc~ftoa proc~report_changes->str proc~run_command_and_report->colorize proc~run_command_and_report->proc~ftoa run run proc~run_command_and_report->run proc~run_command_and_report->str proc~file_fingerprint file_fingerprint proc~scan_changes->proc~file_fingerprint proc~sleep_os sleep_os proc~sleep_seconds->proc~sleep_os proc~sleep_spin sleep_spin proc~sleep_seconds->proc~sleep_spin proc~compute_watch_files_from_settings->proc~log_info proc~compute_watch_files_from_settings->basename proc~compute_watch_files_from_settings->proc~ftoa proc~compute_watch_files_from_settings->str add add proc~compute_watch_files_from_settings->add build_model build_model proc~compute_watch_files_from_settings->build_model dep dep proc~compute_watch_files_from_settings->dep get_package_data get_package_data proc~compute_watch_files_from_settings->get_package_data is_executable_target is_executable_target proc~compute_watch_files_from_settings->is_executable_target join_path join_path proc~compute_watch_files_from_settings->join_path new_dependency_tree new_dependency_tree proc~compute_watch_files_from_settings->new_dependency_tree proc~dfs_mark_bool dfs_mark_bool proc~compute_watch_files_from_settings->proc~dfs_mark_bool proc~dfs_mark_mask dfs_mark_mask proc~compute_watch_files_from_settings->proc~dfs_mark_mask proc~filter_watch_files filter_watch_files proc~compute_watch_files_from_settings->proc~filter_watch_files proc~gather_files_with_mask gather_files_with_mask proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~is_run_or_test is_run_or_test proc~compute_watch_files_from_settings->proc~is_run_or_test proc~normalize_path normalize_path proc~compute_watch_files_from_settings->proc~normalize_path proc~push_file_with_mask push_file_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~select_names_or_all select_names_or_all proc~compute_watch_files_from_settings->proc~select_names_or_all proc~trim_or_empty trim_or_empty proc~compute_watch_files_from_settings->proc~trim_or_empty targets_from_sources targets_from_sources proc~compute_watch_files_from_settings->targets_from_sources proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~init_fingerprints->proc~file_fingerprint proc~manifest_key_from_files->basename proc~manifest_key_from_files->proc~file_fingerprint features features proc~manifest_key_from_files->features proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~manifest_key_from_files->proc~fnv1a_mix_i64 proc~fnv1a_mix_str fnv1a_mix_str proc~manifest_key_from_files->proc~fnv1a_mix_str proc~feat_manifest_noop watch_feature_t%feat_manifest_noop proc~on_manifest_changed_all->proc~feat_manifest_noop proc~feat_list_noop watch_feature_t%feat_list_noop proc~on_watch_list_built_all->proc~feat_list_noop proc~print_banner->colorize proc~print_banner->proc~ftoa proc~print_banner->str proc~active_features active_features proc~print_banner->proc~active_features proc~active_profile active_profile proc~print_banner->proc~active_profile proc~command_mode command_mode proc~print_banner->proc~command_mode proc~trim_or_default trim_or_default proc~print_banner->proc~trim_or_default proc~print_file_list->colorize proc~print_file_list->str interface~c_nanosleep c_nanosleep proc~sleep_os->interface~c_nanosleep proc~join_csv join_csv proc~active_features->proc~join_csv proc~active_profile->proc~trim_or_default proc~dfs_mark_bool->proc~dfs_mark_bool dependencies dependencies proc~dfs_mark_bool->dependencies proc~find_ptr_index find_ptr_index proc~dfs_mark_bool->proc~find_ptr_index proc~dfs_mark_mask->proc~dfs_mark_mask proc~dfs_mark_mask->dependencies proc~dfs_mark_mask->proc~find_ptr_index proc~filter_watch_files->basename proc~filter_watch_files->proc~normalize_path glob glob proc~filter_watch_files->glob proc~fnv1a_mix_str->proc~fnv1a_mix_i64 include_dependencies include_dependencies proc~gather_files_with_mask->include_dependencies proc~vec_push_unique vec_push_unique proc~gather_files_with_mask->proc~vec_push_unique proc~hash_block->proc~fnv1a_mix_i64 proc~push_file_with_mask->proc~vec_push_unique proc~select_names_or_all->basename proc~select_names_or_all->is_executable_target proc~select_names_or_all->glob proc~vec_push_unique->exists proc~vec_push_unique->proc~normalize_path proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine watcher_run ( self ) class ( watcher_t ), intent ( inout ) :: self integer :: changed_count type ( string_t ), allocatable :: changed (:) character ( len = :), allocatable :: cmd integer :: exitstat , j , idx real :: secs integer ( int64 ) :: rate , t_last_rescan , t_now real :: dt if ( self % cfg % w % once ) return call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 call system_clock ( t_last_rescan ) do if ( exists ( \".fpm-watch.stop\" )) exit call sleep_seconds ( self % cfg % w % poll ) call scan_changes ( self % files , self % fp_prev , self % fp_now , self % changed_idx , changed_count ) if ( changed_count > 0 ) then call sleep_seconds ( self % cfg % w % debounce ) call scan_changes ( self % files , self % fp_prev , self % fp_now , self % changed_idx , changed_count ) end if if ( changed_count > 0 ) then if ( any_manifest_changed ( self % files , self % changed_idx , changed_count )) then call handle_manifest_change ( self ) cycle end if allocate ( changed ( changed_count )) do j = 1 , changed_count idx = self % changed_idx ( j ) if ( idx >= 1 . and . idx <= size ( self % files )) then changed ( j )% s = self % files ( idx )% s else changed ( j )% s = \"\" end if end do call self % fm % on_change_detected_all ( changed ) call report_changes ( self % files , self % changed_idx , changed_count , self % cfg % w ) cmd = build_run_command ( & settings = self % cfg % settings , & full_cmdline = self % cfg % fpm_cmdline , & cmd_prefix = self % cfg % cmd_prefix , & cmd_rest = self % cfg % cmd_rest , & roots = self % roots , & file_mask = self % file_mask , & changed_idx = self % changed_idx , & changed_count = changed_count ) call self % fm % on_before_run_all ( cmd ) call run_command_and_report ( cmd , self % cfg % w , exitstat , secs ) call self % fm % on_after_run_all ( exitstat , secs ) call accept_changes ( self % fp_prev , self % fp_now , self % changed_idx , changed_count ) deallocate ( changed ) end if if ( self % cfg % w % rescan > 0.0 ) then call system_clock ( t_now ) if ( t_now < t_last_rescan ) then t_last_rescan = t_now else dt = real ( t_now - t_last_rescan ) / real ( rate ) if ( dt >= self % cfg % w % rescan ) then call log_info ( self % cfg % w , \"rescan triggered -> rebuilding watch list\" ) call rebuild_watch_list ( self , print_header = . false .) call system_clock ( t_last_rescan ) end if end if end if end do end subroutine watcher_run","tags":"","url":"proc/watcher_run.html"},{"title":"find_ptr_index – fpm-watch","text":"private  function find_ptr_index(p, all) result(idx) Uses fpm_targets proc~~find_ptr_index~~UsesGraph proc~find_ptr_index find_ptr_index fpm_targets fpm_targets proc~find_ptr_index->fpm_targets Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(build_target_t), intent(in), pointer :: p type(build_target_ptr), intent(in) :: all (:) Return Value integer Called by proc~~find_ptr_index~~CalledByGraph proc~find_ptr_index find_ptr_index proc~dfs_mark_bool dfs_mark_bool proc~dfs_mark_bool->proc~find_ptr_index proc~dfs_mark_bool->proc~dfs_mark_bool proc~dfs_mark_mask dfs_mark_mask proc~dfs_mark_mask->proc~find_ptr_index proc~dfs_mark_mask->proc~dfs_mark_mask proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~dfs_mark_bool proc~compute_watch_files_from_settings->proc~dfs_mark_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code integer function find_ptr_index ( p , all ) result ( idx ) use fpm_targets , only : build_target_t type ( build_target_t ), pointer , intent ( in ) :: p type ( build_target_ptr ), intent ( in ) :: all (:) integer :: i idx = 0 do i = 1 , size ( all ) if ( associated ( all ( i )% ptr , p )) then idx = i return end if end do end function find_ptr_index","tags":"","url":"proc/find_ptr_index.html"},{"title":"is_in_dep_dirs – fpm-watch","text":"private pure function is_in_dep_dirs(p, dep_dirs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: p type(string_t), intent(in), allocatable :: dep_dirs (:) Return Value logical Calls proc~~is_in_dep_dirs~~CallsGraph proc~is_in_dep_dirs is_in_dep_dirs proc~normalize_path normalize_path proc~is_in_dep_dirs->proc~normalize_path proc~starts_with~2 starts_with proc~is_in_dep_dirs->proc~starts_with~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_in_dep_dirs~~CalledByGraph proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique vec_push_unique proc~vec_push_unique->proc~is_in_dep_dirs proc~gather_files_with_mask gather_files_with_mask proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask push_file_with_mask proc~push_file_with_mask->proc~vec_push_unique proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function is_in_dep_dirs ( p , dep_dirs ) result ( ok ) character ( len =* ), intent ( in ) :: p type ( string_t ), allocatable , intent ( in ) :: dep_dirs (:) integer :: j character ( len = :), allocatable :: d ok = . false . if (. not . allocated ( dep_dirs )) return if ( size ( dep_dirs ) == 0 ) return do j = 1 , size ( dep_dirs ) if ( len_trim ( dep_dirs ( j )% s ) == 0 ) cycle d = normalize_path ( trim ( dep_dirs ( j )% s )) if ( len_trim ( d ) == 0 ) cycle if ( p == d ) then ok = . true . return end if if ( starts_with ( p , d // \"/\" )) then ok = . true . return end if end do end function is_in_dep_dirs","tags":"","url":"proc/is_in_dep_dirs.html"},{"title":"is_run_or_test – fpm-watch","text":"private  function is_run_or_test(settings) Return whether the settings correspond to fpm run or fpm test . Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value logical Called by proc~~is_run_or_test~~CalledByGraph proc~is_run_or_test is_run_or_test proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~is_run_or_test proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code logical function is_run_or_test ( settings ) class ( fpm_build_settings ), intent ( in ) :: settings is_run_or_test = . false . select type ( settings ) type is ( fpm_test_settings ) is_run_or_test = . true . type is ( fpm_run_settings ) is_run_or_test = . true . end select end function is_run_or_test","tags":"","url":"proc/is_run_or_test.html"},{"title":"compute_watch_files_from_settings – fpm-watch","text":"public  subroutine compute_watch_files_from_settings(settings, w, files, file_mask, roots, manifest_key, build_secs, secs_model, secs_targets, secs_watch) Compute watched files and masks from current fpm settings. This is the primary \"graph to watchlist\" entry point. Outputs files : normalized, unique file paths to watch. file_mask : a bitmask per file that encodes which root target(s) the\n  file belongs to (used for name injection on run/test). roots : root executable/test targets. roots(r)%mask is a 1-bit mask. manifest_key : placeholder output (computed elsewhere); set to 0 here. build_secs : sum of secs_model + secs_targets + secs_watch . secs_model : time spent building the fpm model. secs_targets : time spent expanding sources into targets. secs_watch : time spent collecting and filtering file paths. Notes Root bitmasks are limited to bit_size(0_int64) (typically 64 roots). Build directory paths are excluded from the watch list unless dependency\n  watching is enabled and the path is identified as belonging to a dep. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(inout) :: settings type( watch_opts_t ), intent(in) :: w type(string_t), intent(out), allocatable :: files (:) integer(kind=int64), intent(out), allocatable :: file_mask (:) type( root_info_t ), intent(out), allocatable :: roots (:) integer(kind=int64), intent(out) :: manifest_key real, intent(out) :: build_secs real, intent(out) :: secs_model real, intent(out) :: secs_targets real, intent(out) :: secs_watch Calls proc~~compute_watch_files_from_settings~~CallsGraph proc~compute_watch_files_from_settings compute_watch_files_from_settings add add proc~compute_watch_files_from_settings->add basename basename proc~compute_watch_files_from_settings->basename build_model build_model proc~compute_watch_files_from_settings->build_model dep dep proc~compute_watch_files_from_settings->dep get_package_data get_package_data proc~compute_watch_files_from_settings->get_package_data is_executable_target is_executable_target proc~compute_watch_files_from_settings->is_executable_target join_path join_path proc~compute_watch_files_from_settings->join_path new_dependency_tree new_dependency_tree proc~compute_watch_files_from_settings->new_dependency_tree proc~dfs_mark_bool dfs_mark_bool proc~compute_watch_files_from_settings->proc~dfs_mark_bool proc~dfs_mark_mask dfs_mark_mask proc~compute_watch_files_from_settings->proc~dfs_mark_mask proc~filter_watch_files filter_watch_files proc~compute_watch_files_from_settings->proc~filter_watch_files proc~ftoa ftoa proc~compute_watch_files_from_settings->proc~ftoa proc~gather_files_with_mask gather_files_with_mask proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~is_run_or_test is_run_or_test proc~compute_watch_files_from_settings->proc~is_run_or_test proc~log_info log_info proc~compute_watch_files_from_settings->proc~log_info proc~normalize_path normalize_path proc~compute_watch_files_from_settings->proc~normalize_path proc~push_file_with_mask push_file_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~select_names_or_all select_names_or_all proc~compute_watch_files_from_settings->proc~select_names_or_all proc~trim_or_empty trim_or_empty proc~compute_watch_files_from_settings->proc~trim_or_empty str str proc~compute_watch_files_from_settings->str targets_from_sources targets_from_sources proc~compute_watch_files_from_settings->targets_from_sources proc~dfs_mark_bool->proc~dfs_mark_bool dependencies dependencies proc~dfs_mark_bool->dependencies proc~find_ptr_index find_ptr_index proc~dfs_mark_bool->proc~find_ptr_index proc~dfs_mark_mask->proc~dfs_mark_mask proc~dfs_mark_mask->dependencies proc~dfs_mark_mask->proc~find_ptr_index proc~filter_watch_files->basename proc~filter_watch_files->proc~normalize_path glob glob proc~filter_watch_files->glob include_dependencies include_dependencies proc~gather_files_with_mask->include_dependencies proc~vec_push_unique vec_push_unique proc~gather_files_with_mask->proc~vec_push_unique colorize colorize proc~log_info->colorize proc~push_file_with_mask->proc~vec_push_unique proc~select_names_or_all->basename proc~select_names_or_all->is_executable_target proc~select_names_or_all->glob proc~vec_push_unique->proc~normalize_path exists exists proc~vec_push_unique->exists proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_watch_files_from_settings~~CalledByGraph proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine compute_watch_files_from_settings ( settings , w , files , file_mask , roots , manifest_key , build_secs , secs_model , secs_targets , secs_watch ) class ( fpm_build_settings ), intent ( inout ) :: settings type ( watch_opts_t ), intent ( in ) :: w type ( string_t ), allocatable , intent ( out ) :: files (:) integer ( int64 ), allocatable , intent ( out ) :: file_mask (:) type ( root_info_t ), allocatable , intent ( out ) :: roots (:) integer ( int64 ), intent ( out ) :: manifest_key real , intent ( out ) :: build_secs real , intent ( out ) :: secs_model , secs_targets , secs_watch type ( package_config_t ), allocatable :: package type ( fpm_model_t ), allocatable :: model type ( build_target_ptr ), allocatable :: targets (:) type ( error_t ), allocatable :: err type ( dependency_tree_t ) :: tree logical , allocatable :: keep (:) logical , allocatable :: visited (:) integer ( int64 ), allocatable :: target_mask (:) type ( string_t ), allocatable :: dep_dirs (:) integer :: i , r , nroots integer ( int64 ) :: rate , t0 , t1 , tw0 , tw1 integer :: n_before , n_after secs_model = 0.0 secs_targets = 0.0 secs_watch = 0.0 build_secs = 0.0 call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 allocate ( package , model ) call get_package_data ( package , \"fpm.toml\" , err , apply_defaults = . true .) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: manifest error: \" // err % message stop 1 end if call new_dependency_tree ( tree , build_dir = trim_or_empty ( settings % build_dir ), path_to_config = trim_or_empty ( settings % path_to_config )) call tree % add ( package , err ) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: dependency error: \" // err % message stop 1 end if if ( w % watch_deps ) then call collect_dep_dirs ( tree , dep_dirs ) if ( w % verbosity >= 1 ) then call log_info ( w , \"deps: watching dependency sources (deps=\" // str ( size ( dep_dirs )) // \")\" ) end if else if ( allocated ( dep_dirs )) deallocate ( dep_dirs ) allocate ( dep_dirs ( 0 )) end if call system_clock ( t0 ) call build_model ( model , settings , package , err ) call system_clock ( t1 ) secs_model = real ( t1 - t0 ) / real ( rate ) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: model error: \" // err % message stop 1 end if call system_clock ( t0 ) call targets_from_sources ( targets , model , settings % prune , package % library , err ) call system_clock ( t1 ) secs_targets = real ( t1 - t0 ) / real ( rate ) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: targets error: \" // err % message stop 1 end if call system_clock ( tw0 ) allocate ( keep ( size ( targets ))) keep = . false . select type ( s => settings ) type is ( fpm_test_settings ) do i = 1 , size ( targets ) if ( targets ( i )% ptr % is_executable_target ( FPM_SCOPE_TEST )) keep ( i ) = . true . end do type is ( fpm_run_settings ) if ( s % example ) then call select_names_or_all ( targets , FPM_SCOPE_EXAMPLE , s % name , keep ) else call select_names_or_all ( targets , FPM_SCOPE_APP , s % name , keep ) end if class default keep = . true . end select nroots = count ( keep ) allocate ( visited ( size ( targets ))) visited = . false . if ( is_run_or_test ( settings ) . and . nroots > 0 . and . nroots <= bit_size ( 0_int64 )) then allocate ( roots ( nroots )) allocate ( target_mask ( size ( targets ))) target_mask = 0_int64 r = 0 do i = 1 , size ( targets ) if (. not . keep ( i )) cycle r = r + 1 roots ( r )% name = basename ( targets ( i )% ptr % output_file , suffix = . false .) roots ( r )% mask = shiftl ( 1_int64 , r - 1 ) call dfs_mark_mask ( targets ( i )% ptr , targets , target_mask , roots ( r )% mask ) end do visited = ( target_mask /= 0_int64 ) else if ( allocated ( roots )) deallocate ( roots ) allocate ( roots ( 0 )) if ( allocated ( target_mask )) deallocate ( target_mask ) if ( all ( keep )) then visited = . true . else do i = 1 , size ( targets ) if ( keep ( i )) call dfs_mark_bool ( targets ( i )% ptr , targets , visited ) end do end if end if if ( w % watch_deps ) then call gather_files_with_mask ( targets , visited , target_mask , files , file_mask , trim_or_empty ( settings % build_dir ), dep_dirs ) else call gather_files_with_mask ( targets , visited , target_mask , files , file_mask , trim_or_empty ( settings % build_dir )) end if if ( w % watch_deps ) then call push_file_with_mask ( files , file_mask , \"fpm.toml\" , trim_or_empty ( settings % build_dir ), 0_int64 , dep_dirs ) else call push_file_with_mask ( files , file_mask , \"fpm.toml\" , trim_or_empty ( settings % build_dir ), 0_int64 ) end if do i = 1 , tree % ndep if (. not . allocated ( tree % dep ( i )% proj_dir )) cycle if ( len_trim ( tree % dep ( i )% proj_dir ) == 0 ) cycle if ( w % watch_deps ) then call push_file_with_mask ( files , file_mask , join_path ( tree % dep ( i )% proj_dir , \"fpm.toml\" ), trim_or_empty ( settings % build_dir ), 0_int64 , dep_dirs ) else call push_file_with_mask ( files , file_mask , join_path ( tree % dep ( i )% proj_dir , \"fpm.toml\" ), trim_or_empty ( settings % build_dir ), 0_int64 ) end if end do n_before = 0 if ( allocated ( files )) n_before = size ( files ) call filter_watch_files ( files , w % include , w % ignore , file_mask ) n_after = 0 if ( allocated ( files )) n_after = size ( files ) if ( w % debug ) then call log_info ( w , \"debug: watch files filtered: \" // str ( n_before ) // \" -> \" // str ( n_after )) end if call system_clock ( tw1 ) secs_watch = real ( tw1 - tw0 ) / real ( rate ) build_secs = secs_model + secs_targets + secs_watch manifest_key = 0_int64 if ( w % verbosity >= 1 ) then call log_info ( w , \"timings: model=\" // ftoa ( secs_model ) // \"s targets=\" // ftoa ( secs_targets ) // \"s watchlist=\" // ftoa ( secs_watch ) // \"s\" ) call log_info ( w , \"targets: total=\" // str ( size ( targets )) // \" closure=\" // str ( count ( visited ))) end if deallocate ( package , model ) if ( allocated ( targets )) deallocate ( targets ) if ( allocated ( keep )) deallocate ( keep ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( target_mask )) deallocate ( target_mask ) if ( allocated ( dep_dirs )) deallocate ( dep_dirs ) contains subroutine collect_dep_dirs ( tree , dep_dirs ) type ( dependency_tree_t ), intent ( in ) :: tree type ( string_t ), allocatable , intent ( out ) :: dep_dirs (:) integer :: i if ( tree % ndep <= 0 ) then allocate ( dep_dirs ( 0 )) return end if allocate ( dep_dirs ( tree % ndep )) do i = 1 , tree % ndep if ( allocated ( tree % dep ( i )% proj_dir )) then dep_dirs ( i )% s = normalize_path ( trim ( tree % dep ( i )% proj_dir )) else dep_dirs ( i )% s = \"\" end if end do end subroutine collect_dep_dirs end subroutine compute_watch_files_from_settings","tags":"","url":"proc/compute_watch_files_from_settings.html"},{"title":"dfs_mark_bool – fpm-watch","text":"private recursive subroutine dfs_mark_bool(node, all, visited) Uses fpm_targets proc~~dfs_mark_bool~~UsesGraph proc~dfs_mark_bool dfs_mark_bool fpm_targets fpm_targets proc~dfs_mark_bool->fpm_targets Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(build_target_t), intent(in), pointer :: node type(build_target_ptr), intent(in) :: all (:) logical, intent(inout) :: visited (:) Calls proc~~dfs_mark_bool~~CallsGraph proc~dfs_mark_bool dfs_mark_bool proc~dfs_mark_bool->proc~dfs_mark_bool dependencies dependencies proc~dfs_mark_bool->dependencies proc~find_ptr_index find_ptr_index proc~dfs_mark_bool->proc~find_ptr_index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dfs_mark_bool~~CalledByGraph proc~dfs_mark_bool dfs_mark_bool proc~dfs_mark_bool->proc~dfs_mark_bool proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~dfs_mark_bool proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code recursive subroutine dfs_mark_bool ( node , all , visited ) use fpm_targets , only : build_target_t type ( build_target_t ), pointer , intent ( in ) :: node type ( build_target_ptr ), intent ( in ) :: all (:) logical , intent ( inout ) :: visited (:) integer :: idx , i idx = find_ptr_index ( node , all ) if ( idx <= 0 ) return if ( visited ( idx )) return visited ( idx ) = . true . if ( allocated ( node % dependencies )) then do i = 1 , size ( node % dependencies ) if ( associated ( node % dependencies ( i )% ptr )) call dfs_mark_bool ( node % dependencies ( i )% ptr , all , visited ) end do end if end subroutine dfs_mark_bool","tags":"","url":"proc/dfs_mark_bool.html"},{"title":"dfs_mark_mask – fpm-watch","text":"private recursive subroutine dfs_mark_mask(node, all, tmask, mask) Uses fpm_targets proc~~dfs_mark_mask~~UsesGraph proc~dfs_mark_mask dfs_mark_mask fpm_targets fpm_targets proc~dfs_mark_mask->fpm_targets Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name type(build_target_t), intent(in), pointer :: node type(build_target_ptr), intent(in) :: all (:) integer(kind=int64), intent(inout) :: tmask (:) integer(kind=int64), intent(in) :: mask Calls proc~~dfs_mark_mask~~CallsGraph proc~dfs_mark_mask dfs_mark_mask proc~dfs_mark_mask->proc~dfs_mark_mask dependencies dependencies proc~dfs_mark_mask->dependencies proc~find_ptr_index find_ptr_index proc~dfs_mark_mask->proc~find_ptr_index Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dfs_mark_mask~~CalledByGraph proc~dfs_mark_mask dfs_mark_mask proc~dfs_mark_mask->proc~dfs_mark_mask proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~dfs_mark_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code recursive subroutine dfs_mark_mask ( node , all , tmask , mask ) use fpm_targets , only : build_target_t type ( build_target_t ), pointer , intent ( in ) :: node type ( build_target_ptr ), intent ( in ) :: all (:) integer ( int64 ), intent ( inout ) :: tmask (:) integer ( int64 ), intent ( in ) :: mask integer :: idx , i idx = find_ptr_index ( node , all ) if ( idx <= 0 ) return if ( iand ( tmask ( idx ), mask ) /= 0_int64 ) return tmask ( idx ) = ior ( tmask ( idx ), mask ) if ( allocated ( node % dependencies )) then do i = 1 , size ( node % dependencies ) if ( associated ( node % dependencies ( i )% ptr )) call dfs_mark_mask ( node % dependencies ( i )% ptr , all , tmask , mask ) end do end if end subroutine dfs_mark_mask","tags":"","url":"proc/dfs_mark_mask.html"},{"title":"gather_files_with_mask – fpm-watch","text":"private  subroutine gather_files_with_mask(targets, visited, target_mask, files, file_mask, build_dir, dep_dirs) Arguments Type Intent Optional Attributes Name type(build_target_ptr), intent(in) :: targets (:) logical, intent(in) :: visited (:) integer(kind=int64), intent(in), optional, allocatable :: target_mask (:) type(string_t), intent(out), allocatable :: files (:) integer(kind=int64), intent(out), allocatable :: file_mask (:) character(len=*), intent(in) :: build_dir type(string_t), intent(in), optional, allocatable :: dep_dirs (:) Calls proc~~gather_files_with_mask~~CallsGraph proc~gather_files_with_mask gather_files_with_mask include_dependencies include_dependencies proc~gather_files_with_mask->include_dependencies proc~vec_push_unique vec_push_unique proc~gather_files_with_mask->proc~vec_push_unique exists exists proc~vec_push_unique->exists proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~normalize_path normalize_path proc~vec_push_unique->proc~normalize_path proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gather_files_with_mask~~CalledByGraph proc~gather_files_with_mask gather_files_with_mask proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine gather_files_with_mask ( targets , visited , target_mask , files , file_mask , build_dir , dep_dirs ) type ( build_target_ptr ), intent ( in ) :: targets (:) logical , intent ( in ) :: visited (:) integer ( int64 ), allocatable , intent ( in ), optional :: target_mask (:) type ( string_t ), allocatable , intent ( out ) :: files (:) integer ( int64 ), allocatable , intent ( out ) :: file_mask (:) character ( len =* ), intent ( in ) :: build_dir type ( string_t ), allocatable , intent ( in ), optional :: dep_dirs (:) type ( string_t ), allocatable :: buf (:) integer ( int64 ), allocatable :: mbuf (:) integer :: n , cap integer :: i , j integer ( int64 ) :: m n = 0 cap = 256 allocate ( buf ( cap ), mbuf ( cap )) do i = 1 , size ( targets ) if (. not . visited ( i )) cycle if (. not . allocated ( targets ( i )% ptr % source )) cycle m = 0_int64 if ( present ( target_mask )) then if ( allocated ( target_mask )) m = target_mask ( i ) end if if ( present ( dep_dirs )) then call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % file_name , build_dir , m , dep_dirs ) else call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % file_name , build_dir , m ) end if if ( allocated ( targets ( i )% ptr % source % include_dependencies )) then do j = 1 , size ( targets ( i )% ptr % source % include_dependencies ) if ( present ( dep_dirs )) then call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % include_dependencies ( j )% s , build_dir , m , dep_dirs ) else call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % include_dependencies ( j )% s , build_dir , m ) end if end do end if end do call finalize_vec ( buf , mbuf , n , files , file_mask ) contains subroutine finalize_vec ( buf , mbuf , n , files , file_mask ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( in ) :: n type ( string_t ), allocatable , intent ( out ) :: files (:) integer ( int64 ), allocatable , intent ( out ) :: file_mask (:) integer :: k if ( n <= 0 ) then allocate ( files ( 0 ), file_mask ( 0 )) deallocate ( buf , mbuf ) return end if allocate ( files ( n ), file_mask ( n )) do k = 1 , n call move_alloc ( buf ( k )% s , files ( k )% s ) file_mask ( k ) = mbuf ( k ) end do deallocate ( buf , mbuf ) end subroutine finalize_vec end subroutine gather_files_with_mask","tags":"","url":"proc/gather_files_with_mask.html"},{"title":"push_file_with_mask – fpm-watch","text":"private  subroutine push_file_with_mask(files, file_mask, path, build_dir, mask, dep_dirs) Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: files (:) integer(kind=int64), intent(inout), allocatable :: file_mask (:) character(len=*), intent(in) :: path character(len=*), intent(in) :: build_dir integer(kind=int64), intent(in) :: mask type(string_t), intent(in), optional, allocatable :: dep_dirs (:) Calls proc~~push_file_with_mask~~CallsGraph proc~push_file_with_mask push_file_with_mask proc~vec_push_unique vec_push_unique proc~push_file_with_mask->proc~vec_push_unique exists exists proc~vec_push_unique->exists proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~normalize_path normalize_path proc~vec_push_unique->proc~normalize_path proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~push_file_with_mask~~CalledByGraph proc~push_file_with_mask push_file_with_mask proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine push_file_with_mask ( files , file_mask , path , build_dir , mask , dep_dirs ) type ( string_t ), allocatable , intent ( inout ) :: files (:) integer ( int64 ), allocatable , intent ( inout ) :: file_mask (:) character ( len =* ), intent ( in ) :: path character ( len =* ), intent ( in ) :: build_dir integer ( int64 ), intent ( in ) :: mask type ( string_t ), allocatable , intent ( in ), optional :: dep_dirs (:) type ( string_t ), allocatable :: buf (:) integer ( int64 ), allocatable :: mbuf (:) integer :: n , cap , i if (. not . allocated ( files )) then n = 0 cap = 8 allocate ( buf ( cap ), mbuf ( cap )) else n = size ( files ) cap = max ( 8 , n ) allocate ( buf ( cap ), mbuf ( cap )) do i = 1 , n buf ( i )% s = files ( i )% s mbuf ( i ) = file_mask ( i ) end do end if if ( present ( dep_dirs )) then call vec_push_unique ( buf , mbuf , n , cap , path , build_dir , mask , dep_dirs ) else call vec_push_unique ( buf , mbuf , n , cap , path , build_dir , mask ) end if call finalize_vec ( buf , mbuf , n , files , file_mask ) contains subroutine finalize_vec ( buf , mbuf , n , files , file_mask ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( in ) :: n type ( string_t ), allocatable , intent ( inout ) :: files (:) integer ( int64 ), allocatable , intent ( inout ) :: file_mask (:) type ( string_t ), allocatable :: out (:) integer ( int64 ), allocatable :: outm (:) integer :: k if ( allocated ( files )) deallocate ( files ) if ( allocated ( file_mask )) deallocate ( file_mask ) if ( n <= 0 ) then allocate ( files ( 0 ), file_mask ( 0 )) deallocate ( buf , mbuf ) return end if allocate ( out ( n ), outm ( n )) do k = 1 , n call move_alloc ( buf ( k )% s , out ( k )% s ) outm ( k ) = mbuf ( k ) end do deallocate ( buf , mbuf ) call move_alloc ( out , files ) call move_alloc ( outm , file_mask ) end subroutine finalize_vec end subroutine push_file_with_mask","tags":"","url":"proc/push_file_with_mask.html"},{"title":"select_names_or_all – fpm-watch","text":"private  subroutine select_names_or_all(targets, scope, names, keep) Arguments Type Intent Optional Attributes Name type(build_target_ptr), intent(in) :: targets (:) integer, intent(in) :: scope character(len=*), intent(in), optional :: names (:) logical, intent(inout) :: keep (:) Calls proc~~select_names_or_all~~CallsGraph proc~select_names_or_all select_names_or_all basename basename proc~select_names_or_all->basename glob glob proc~select_names_or_all->glob is_executable_target is_executable_target proc~select_names_or_all->is_executable_target Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~select_names_or_all~~CalledByGraph proc~select_names_or_all select_names_or_all proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~select_names_or_all proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine select_names_or_all ( targets , scope , names , keep ) type ( build_target_ptr ), intent ( in ) :: targets (:) integer , intent ( in ) :: scope character ( len =* ), intent ( in ), optional :: names (:) logical , intent ( inout ) :: keep (:) integer :: i , j character ( len = :), allocatable :: outbase_full , outbase_stem logical :: any_name any_name = . false . if ( present ( names )) then if ( size ( names ) > 0 ) then do j = 1 , size ( names ) if ( len_trim ( names ( j )) > 0 ) then any_name = . true . exit end if end do end if end if if (. not . any_name ) then do i = 1 , size ( targets ) if ( targets ( i )% ptr % is_executable_target ( scope )) keep ( i ) = . true . end do return end if do i = 1 , size ( targets ) if (. not . targets ( i )% ptr % is_executable_target ( scope )) cycle outbase_full = basename ( targets ( i )% ptr % output_file ) outbase_stem = basename ( targets ( i )% ptr % output_file , suffix = . false .) do j = 1 , size ( names ) if ( len_trim ( names ( j )) == 0 ) cycle if ( glob ( trim ( names ( j )), outbase_full ) . or . glob ( trim ( names ( j )), outbase_stem )) then keep ( i ) = . true . exit end if end do end do end subroutine select_names_or_all","tags":"","url":"proc/select_names_or_all.html"},{"title":"vec_grow – fpm-watch","text":"private  subroutine vec_grow(buf, mbuf, cap) Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: buf (:) integer(kind=int64), intent(inout), allocatable :: mbuf (:) integer, intent(inout) :: cap Called by proc~~vec_grow~~CalledByGraph proc~vec_grow vec_grow proc~vec_push_unique vec_push_unique proc~vec_push_unique->proc~vec_grow proc~gather_files_with_mask gather_files_with_mask proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask push_file_with_mask proc~push_file_with_mask->proc~vec_push_unique proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine vec_grow ( buf , mbuf , cap ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( inout ) :: cap type ( string_t ), allocatable :: nb (:) integer ( int64 ), allocatable :: nm (:) integer :: newcap , i newcap = max ( 16 , cap + cap / 2 ) allocate ( nb ( newcap ), nm ( newcap )) do i = 1 , cap nb ( i )% s = buf ( i )% s nm ( i ) = mbuf ( i ) end do call move_alloc ( nb , buf ) call move_alloc ( nm , mbuf ) cap = newcap end subroutine vec_grow","tags":"","url":"proc/vec_grow.html"},{"title":"vec_push_unique – fpm-watch","text":"private  subroutine vec_push_unique(buf, mbuf, n, cap, path, build_dir, mask, dep_dirs) Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: buf (:) integer(kind=int64), intent(inout), allocatable :: mbuf (:) integer, intent(inout) :: n integer, intent(inout) :: cap character(len=*), intent(in) :: path character(len=*), intent(in) :: build_dir integer(kind=int64), intent(in) :: mask type(string_t), intent(in), optional, allocatable :: dep_dirs (:) Calls proc~~vec_push_unique~~CallsGraph proc~vec_push_unique vec_push_unique exists exists proc~vec_push_unique->exists proc~is_ignored_path is_ignored_path proc~vec_push_unique->proc~is_ignored_path proc~is_in_dep_dirs is_in_dep_dirs proc~vec_push_unique->proc~is_in_dep_dirs proc~normalize_path normalize_path proc~vec_push_unique->proc~normalize_path proc~vec_grow vec_grow proc~vec_push_unique->proc~vec_grow proc~is_ignored_path->proc~normalize_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs->proc~normalize_path proc~is_in_dep_dirs->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~vec_push_unique~~CalledByGraph proc~vec_push_unique vec_push_unique proc~gather_files_with_mask gather_files_with_mask proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask push_file_with_mask proc~push_file_with_mask->proc~vec_push_unique proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine vec_push_unique ( buf , mbuf , n , cap , path , build_dir , mask , dep_dirs ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( inout ) :: n , cap character ( len =* ), intent ( in ) :: path character ( len =* ), intent ( in ) :: build_dir integer ( int64 ), intent ( in ) :: mask type ( string_t ), allocatable , intent ( in ), optional :: dep_dirs (:) character ( len = :), allocatable :: p integer :: i p = normalize_path ( path ) if ( len_trim ( p ) == 0 ) return if ( is_ignored_path ( p , build_dir )) then if (. not . present ( dep_dirs )) return if (. not . is_in_dep_dirs ( p , dep_dirs )) return end if if (. not . exists ( p )) return do i = 1 , n if ( buf ( i )% s == p ) then mbuf ( i ) = ior ( mbuf ( i ), mask ) return end if end do if ( n >= cap ) call vec_grow ( buf , mbuf , cap ) n = n + 1 buf ( n )% s = p mbuf ( n ) = mask end subroutine vec_push_unique","tags":"","url":"proc/vec_push_unique.html"},{"title":"active_features – fpm-watch","text":"private pure function active_features(settings) result(f) Return a comma-separated feature list for banner display. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value character(len=:), allocatable Calls proc~~active_features~~CallsGraph proc~active_features active_features proc~join_csv join_csv proc~active_features->proc~join_csv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~active_features~~CalledByGraph proc~active_features active_features proc~print_banner print_banner proc~print_banner->proc~active_features proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~print_banner proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function active_features ( settings ) result ( f ) class ( fpm_build_settings ), intent ( in ) :: settings character ( len = :), allocatable :: f if ( allocated ( settings % features )) then f = join_csv ( settings % features , \"(none)\" ) else f = \"(none)\" end if end function active_features","tags":"","url":"proc/active_features.html"},{"title":"active_profile – fpm-watch","text":"private pure function active_profile(settings) result(p) Return the active build profile for banner display. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value character(len=:), allocatable Calls proc~~active_profile~~CallsGraph proc~active_profile active_profile proc~trim_or_default trim_or_default proc~active_profile->proc~trim_or_default Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~active_profile~~CalledByGraph proc~active_profile active_profile proc~print_banner print_banner proc~print_banner->proc~active_profile proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~print_banner proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function active_profile ( settings ) result ( p ) class ( fpm_build_settings ), intent ( in ) :: settings character ( len = :), allocatable :: p p = trim_or_default ( settings % profile , \"default\" ) end function active_profile","tags":"","url":"proc/active_profile.html"},{"title":"command_mode – fpm-watch","text":"private pure function command_mode(settings) result(mode) Derive a human-readable mode label from fpm settings. The returned string is used only for banner presentation. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value character(len=:), allocatable Called by proc~~command_mode~~CalledByGraph proc~command_mode command_mode proc~print_banner print_banner proc~print_banner->proc~command_mode proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~print_banner proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function command_mode ( settings ) result ( mode ) class ( fpm_build_settings ), intent ( in ) :: settings character ( len = :), allocatable :: mode select type ( s => settings ) type is ( fpm_test_settings ) mode = \"test\" type is ( fpm_run_settings ) if ( s % example ) then mode = \"run --example\" else mode = \"run\" end if class default mode = \"build\" end select end function command_mode","tags":"","url":"proc/command_mode.html"},{"title":"print_banner – fpm-watch","text":"public  subroutine print_banner(full_cmdline, settings, w, files, build_secs, roots_count, secs_model, secs_targets, secs_watch) Print the startup banner and an initialization timing summary. The banner is a compact summary of the effective configuration and the\ncomputed watch set. Verbosity rules If w%verbosity < 0 , this routine returns without printing. If w%debug is enabled, an extra debug line is printed. Arguments full_cmdline : Full command that will be executed (typically fpm ... ). settings : Effective fpm settings used to build the model. w : Watcher options (verbosity, polling, flags shown in banner). files : Computed list of watched file paths (may be unallocated). build_secs : Total init time (seconds). roots_count : Number of root targets included in the watch closure. secs_model , secs_targets , secs_watch : Timing breakdown (seconds). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_cmdline class(fpm_build_settings), intent(in) :: settings type( watch_opts_t ), intent(in) :: w type(string_t), intent(in), allocatable :: files (:) real, intent(in) :: build_secs integer, intent(in) :: roots_count real, intent(in) :: secs_model real, intent(in) :: secs_targets real, intent(in) :: secs_watch Calls proc~~print_banner~~CallsGraph proc~print_banner print_banner colorize colorize proc~print_banner->colorize proc~active_features active_features proc~print_banner->proc~active_features proc~active_profile active_profile proc~print_banner->proc~active_profile proc~command_mode command_mode proc~print_banner->proc~command_mode proc~ftoa ftoa proc~print_banner->proc~ftoa proc~trim_or_default trim_or_default proc~print_banner->proc~trim_or_default str str proc~print_banner->str proc~join_csv join_csv proc~active_features->proc~join_csv proc~active_profile->proc~trim_or_default Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_banner~~CalledByGraph proc~print_banner print_banner proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~print_banner proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_banner ( full_cmdline , settings , w , files , build_secs , roots_count , secs_model , secs_targets , secs_watch ) character ( len =* ), intent ( in ) :: full_cmdline class ( fpm_build_settings ), intent ( in ) :: settings type ( watch_opts_t ), intent ( in ) :: w type ( string_t ), allocatable , intent ( in ) :: files (:) real , intent ( in ) :: build_secs integer , intent ( in ) :: roots_count real , intent ( in ) :: secs_model , secs_targets , secs_watch integer :: nfiles character ( len = :), allocatable :: mode character ( len = :), allocatable :: initrun character ( len = :), allocatable :: deps character ( len = :), allocatable :: prune character ( len = :), allocatable :: lowcpu character ( len = :), allocatable :: silent character ( len = :), allocatable :: bdir if ( w % verbosity < 0 ) return nfiles = 0 if ( allocated ( files )) nfiles = size ( files ) mode = command_mode ( settings ) if ( w % run_on_start ) then initrun = \"on\" else initrun = \"off\" end if if ( w % watch_deps ) then deps = \"on\" else deps = \"off\" end if if ( settings % prune ) then prune = \"on\" else prune = \"off\" end if if ( w % low_cpu ) then lowcpu = \"on\" else lowcpu = \"off\" end if if ( w % silent_fpm ) then silent = \"on\" else silent = \"off\" end if bdir = trim_or_default ( settings % build_dir , \"build\" ) write ( output_unit , '(a)' ) & colorize ( \"fpm-watch\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  |  watching: \" // colorize ( mode , color_fg = 'yellow_intense' , style = 'bold_on' ) // & \"  |  \" // colorize ( \"Ctrl+C\" , color_fg = 'red_intense' , style = 'bold_on' ) // \" to stop\" write ( output_unit , '(a)' ) & colorize ( \"command    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( full_cmdline ), color_fg = 'white_intense' ) write ( output_unit , '(a)' ) & colorize ( \"build-dir  |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( bdir ), color_fg = 'yellow_intense' ) write ( output_unit , '(a)' ) & colorize ( \"options    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  prune=\" // colorize ( prune , color_fg = 'yellow' ) // & \"   deps=\" // colorize ( deps , color_fg = 'yellow' ) // & \"   low-cpu=\" // colorize ( lowcpu , color_fg = 'yellow' ) // & \"   silent-fpm=\" // colorize ( silent , color_fg = 'yellow' ) // & \"   verbosity=\" // colorize ( str ( w % verbosity ), color_fg = 'yellow' ) write ( output_unit , '(a)' ) & colorize ( \"compiler   |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim_or_default ( settings % compiler , \"(auto)\" ), color_fg = 'green_intense' ) write ( output_unit , '(a)' ) & colorize ( \"profile    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( active_profile ( settings ), color_fg = 'magenta_intense' ) write ( output_unit , '(a)' ) & colorize ( \"features   |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( active_features ( settings ), color_fg = 'blue_intense' ) write ( output_unit , '(a)' ) & colorize ( \"watch      |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  files=\" // colorize ( str ( nfiles ), color_fg = 'yellow_intense' , style = 'bold_on' ) // & \"  roots=\" // colorize ( str ( roots_count ), color_fg = 'yellow_intense' , style = 'bold_on' ) // & \"  poll=\" // colorize ( ftoa ( w % poll ), color_fg = 'yellow' ) // \"s\" // & \"  debounce=\" // colorize ( ftoa ( w % debounce ), color_fg = 'yellow' ) // \"s\" // & \"  rescan=\" // colorize ( ftoa ( w % rescan ), color_fg = 'yellow' ) // \"s\" // & \"  init-run=\" // colorize ( initrun , color_fg = 'yellow' ) write ( output_unit , '(a)' ) & colorize ( \"init       |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  model=\" // colorize ( ftoa ( secs_model ), color_fg = 'yellow' ) // \"s\" // & \"  targets=\" // colorize ( ftoa ( secs_targets ), color_fg = 'yellow' ) // \"s\" // & \"  watchlist=\" // colorize ( ftoa ( secs_watch ), color_fg = 'yellow' ) // \"s\" // & \"  total=\" // colorize ( ftoa ( build_secs ), color_fg = 'yellow_intense' , style = 'bold_on' ) // \"s\" write ( output_unit , '(a)' ) & colorize ( \"stop       |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  Ctrl+C or touch \" // colorize ( \".fpm-watch.stop\" , color_fg = 'yellow_intense' ) if ( w % debug ) then write ( output_unit , '(a)' ) & colorize ( \"debug      |\" , color_fg = 'magenta_intense' , style = 'bold_on' ) // & \"  debug=on  verbosity=\" // colorize ( str ( w % verbosity ), color_fg = 'magenta_intense' ) end if end subroutine print_banner","tags":"","url":"proc/print_banner.html"},{"title":"print_file_list – fpm-watch","text":"public  subroutine print_file_list(files, w) Print the computed watch list (limited output). The printed list is capped to avoid overwhelming the terminal. Verbosity rules Printed only when w%verbosity >= 2 . Returns immediately if files is not allocated. Arguments files : Computed list of watched file paths. w : Watcher options (controls whether printing is enabled). Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) type( watch_opts_t ), intent(in) :: w Calls proc~~print_file_list~~CallsGraph proc~print_file_list print_file_list colorize colorize proc~print_file_list->colorize str str proc~print_file_list->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_file_list~~CalledByGraph proc~print_file_list print_file_list proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~print_file_list proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine print_file_list ( files , w ) type ( string_t ), allocatable , intent ( in ) :: files (:) type ( watch_opts_t ), intent ( in ) :: w integer :: i , cap character ( len = :), allocatable :: pfx if ( w % verbosity < 2 ) return if (. not . allocated ( files )) return cap = 200 pfx = colorize ( \"fpm-watch info:\" , color_fg = 'blue_intense' , style = 'bold_on' ) write ( output_unit , '(a)' ) & pfx // \" watched files list (cap=200), n=\" // & colorize ( str ( size ( files )), color_fg = 'yellow_intense' , style = 'bold_on' ) do i = 1 , min ( size ( files ), cap ) write ( output_unit , '(a)' ) pfx // \"   \" // colorize ( trim ( files ( i )% s ), color_fg = 'white_intense' ) end do if ( size ( files ) > cap ) then write ( output_unit , '(a)' ) & pfx // \"   ... (\" // colorize ( str ( size ( files ) - cap ), color_fg = 'yellow' ) // \" more)\" end if end subroutine print_file_list","tags":"","url":"proc/print_file_list.html"},{"title":"file_fingerprint – fpm-watch","text":"public  function file_fingerprint(path) result(fp) Compute a fingerprint for a file path. Strategy:\n- Read the file size ( inquire(size=...) ).\n- Hash up to three blocks (head/mid/tail) using FNV-1a mixing.\n- Combine with file size to reduce collision risk. Missing/unreadable files return 0 . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value integer(kind=int64) Calls proc~~file_fingerprint~~CallsGraph proc~file_fingerprint file_fingerprint proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~hash_block->proc~fnv1a_mix_i64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~file_fingerprint~~CalledByGraph proc~file_fingerprint file_fingerprint proc~init_fingerprints init_fingerprints proc~init_fingerprints->proc~file_fingerprint proc~manifest_key_from_files manifest_key_from_files proc~manifest_key_from_files->proc~file_fingerprint proc~scan_changes scan_changes proc~scan_changes->proc~file_fingerprint proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~manifest_key_from_files proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change->proc~rebuild_watch_list proc~rebuild_watch_list->proc~init_fingerprints proc~rebuild_watch_list->proc~manifest_key_from_files proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~scan_changes proc~watcher_run->proc~handle_manifest_change proc~watcher_run->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code integer ( int64 ) function file_fingerprint ( path ) result ( fp ) character ( len =* ), intent ( in ) :: path logical :: ex integer ( int64 ) :: sz , h , n64 , pos_mid , pos_end , pos_max integer :: u , ios , n inquire ( file = trim ( path ), exist = ex , size = sz , iostat = ios ) if ( ios /= 0 . or . . not . ex ) then fp = 0_int64 return end if if ( sz <= 0_int64 ) then fp = 0_int64 return end if n64 = min ( sz , int ( BLOCK_SIZE , int64 )) n = int ( n64 ) open ( newunit = u , file = trim ( path ), access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios /= 0 ) then fp = ieor ( ishft ( sz , 1 ), FNV_OFFSET ) return end if if (. not . allocated ( io_buf )) allocate ( io_buf ( BLOCK_SIZE )) h = FNV_OFFSET call hash_block ( u , 1_int64 , n , h ) if ( sz > n64 ) then pos_max = max ( 1_int64 , sz - n64 + 1_int64 ) pos_mid = sz / 2_int64 - n64 / 2_int64 if ( pos_mid < 1_int64 ) pos_mid = 1_int64 if ( pos_mid > pos_max ) pos_mid = pos_max pos_end = pos_max call hash_block ( u , pos_mid , n , h ) call hash_block ( u , pos_end , n , h ) end if close ( u ) fp = ieor ( ishft ( sz , 1 ), h ) end function file_fingerprint","tags":"","url":"proc/file_fingerprint.html"},{"title":"manifest_key_from_files – fpm-watch","text":"public  function manifest_key_from_files(settings, files) result(k) Compute a key representing the current manifest-related configuration. This key is used to detect when changes require rebuilding the watch list.\nIt includes:\n- Selected fpm_build_settings fields\n- Feature list ( settings%features )\n- The fingerprint of any watched file named fpm.toml Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings type(string_t), intent(in), allocatable :: files (:) Return Value integer(kind=int64) Calls proc~~manifest_key_from_files~~CallsGraph proc~manifest_key_from_files manifest_key_from_files basename basename proc~manifest_key_from_files->basename features features proc~manifest_key_from_files->features proc~file_fingerprint file_fingerprint proc~manifest_key_from_files->proc~file_fingerprint proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~manifest_key_from_files->proc~fnv1a_mix_i64 proc~fnv1a_mix_str fnv1a_mix_str proc~manifest_key_from_files->proc~fnv1a_mix_str proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~fnv1a_mix_str->proc~fnv1a_mix_i64 proc~hash_block->proc~fnv1a_mix_i64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~manifest_key_from_files~~CalledByGraph proc~manifest_key_from_files manifest_key_from_files proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~manifest_key_from_files proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change->proc~rebuild_watch_list proc~rebuild_watch_list->proc~manifest_key_from_files proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~handle_manifest_change proc~watcher_run->proc~rebuild_watch_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code integer ( int64 ) function manifest_key_from_files ( settings , files ) result ( k ) class ( fpm_build_settings ), intent ( in ) :: settings type ( string_t ), allocatable , intent ( in ) :: files (:) integer :: i character ( len = :), allocatable :: b k = FNV_OFFSET call mix_alloc ( k , settings % build_dir ) call mix_alloc ( k , settings % compiler ) call mix_alloc ( k , settings % c_compiler ) call mix_alloc ( k , settings % cxx_compiler ) call mix_alloc ( k , settings % archiver ) call mix_alloc ( k , settings % profile ) call mix_alloc ( k , settings % flag ) call mix_alloc ( k , settings % cflag ) call mix_alloc ( k , settings % cxxflag ) call mix_alloc ( k , settings % ldflag ) if ( settings % prune ) then call fnv1a_mix_str ( k , \"prune=1\" ) else call fnv1a_mix_str ( k , \"prune=0\" ) end if if ( settings % build_tests ) then call fnv1a_mix_str ( k , \"build_tests=1\" ) else call fnv1a_mix_str ( k , \"build_tests=0\" ) end if if ( allocated ( settings % features )) then do i = 1 , size ( settings % features ) call fnv1a_mix_str ( k , trim ( settings % features ( i )% s )) end do end if if (. not . allocated ( files )) return do i = 1 , size ( files ) b = basename ( files ( i )% s ) if ( b == \"fpm.toml\" ) then call fnv1a_mix_str ( k , files ( i )% s ) call fnv1a_mix_i64 ( k , file_fingerprint ( files ( i )% s )) end if end do contains subroutine mix_alloc ( h , s ) integer ( int64 ), intent ( inout ) :: h character ( len = :), allocatable , intent ( in ) :: s if (. not . allocated ( s )) return if ( len_trim ( s ) == 0 ) return call fnv1a_mix_str ( h , trim ( s )) end subroutine mix_alloc end function manifest_key_from_files","tags":"","url":"proc/manifest_key_from_files.html"},{"title":"accept_changes – fpm-watch","text":"public  subroutine accept_changes(fp_prev, fp_now, changed_idx, changed_count) Accept the new fingerprints for the subset of changed indices. After a successful run, this updates fp_prev so future scans detect new\nchanges relative to the latest known state. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: fp_prev (:) integer(kind=int64), intent(in) :: fp_now (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count Called by proc~~accept_changes~~CalledByGraph proc~accept_changes accept_changes proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~accept_changes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine accept_changes ( fp_prev , fp_now , changed_idx , changed_count ) integer ( int64 ), intent ( inout ) :: fp_prev (:) integer ( int64 ), intent ( in ) :: fp_now (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count integer :: j , i do j = 1 , changed_count i = changed_idx ( j ) if ( i >= 1 . and . i <= size ( fp_prev )) fp_prev ( i ) = fp_now ( i ) end do end subroutine accept_changes","tags":"","url":"proc/accept_changes.html"},{"title":"init_fingerprints – fpm-watch","text":"public  subroutine init_fingerprints(files, fp_prev, fp_now, changed_idx) Initialize fingerprint arrays for a watch list. Allocates fp_prev , fp_now , and changed_idx to match the size of files . Initial fingerprints are computed once and copied into fp_now . Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer(kind=int64), intent(inout), allocatable :: fp_prev (:) integer(kind=int64), intent(inout), allocatable :: fp_now (:) integer, intent(inout), allocatable :: changed_idx (:) Calls proc~~init_fingerprints~~CallsGraph proc~init_fingerprints init_fingerprints proc~file_fingerprint file_fingerprint proc~init_fingerprints->proc~file_fingerprint proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~hash_block->proc~fnv1a_mix_i64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_fingerprints~~CalledByGraph proc~init_fingerprints init_fingerprints proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~init_fingerprints proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_fingerprints ( files , fp_prev , fp_now , changed_idx ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer ( int64 ), allocatable , intent ( inout ) :: fp_prev (:) integer ( int64 ), allocatable , intent ( inout ) :: fp_now (:) integer , allocatable , intent ( inout ) :: changed_idx (:) integer :: n , i if (. not . allocated ( files )) then if ( allocated ( fp_prev )) deallocate ( fp_prev ) if ( allocated ( fp_now )) deallocate ( fp_now ) if ( allocated ( changed_idx )) deallocate ( changed_idx ) allocate ( fp_prev ( 0 ), fp_now ( 0 ), changed_idx ( 0 )) return end if n = size ( files ) if ( allocated ( fp_prev )) deallocate ( fp_prev ) if ( allocated ( fp_now )) deallocate ( fp_now ) if ( allocated ( changed_idx )) deallocate ( changed_idx ) allocate ( fp_prev ( n ), fp_now ( n ), changed_idx ( n )) do i = 1 , n fp_prev ( i ) = file_fingerprint ( files ( i )% s ) end do fp_now = fp_prev end subroutine init_fingerprints","tags":"","url":"proc/init_fingerprints.html"},{"title":"scan_changes – fpm-watch","text":"public  subroutine scan_changes(files, fp_prev, fp_now, changed_idx, changed_count) Scan files and return indices of changed entries. changed_idx(1:changed_count) contains the 1-based indices into files for which the fingerprint differs from fp_prev . Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer(kind=int64), intent(in) :: fp_prev (:) integer(kind=int64), intent(inout) :: fp_now (:) integer, intent(inout) :: changed_idx (:) integer, intent(out) :: changed_count Calls proc~~scan_changes~~CallsGraph proc~scan_changes scan_changes proc~file_fingerprint file_fingerprint proc~scan_changes->proc~file_fingerprint proc~hash_block hash_block proc~file_fingerprint->proc~hash_block proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~hash_block->proc~fnv1a_mix_i64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~scan_changes~~CalledByGraph proc~scan_changes scan_changes proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~scan_changes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine scan_changes ( files , fp_prev , fp_now , changed_idx , changed_count ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer ( int64 ), intent ( in ) :: fp_prev (:) integer ( int64 ), intent ( inout ) :: fp_now (:) integer , intent ( inout ) :: changed_idx (:) integer , intent ( out ) :: changed_count integer :: i , n changed_count = 0 if (. not . allocated ( files )) return n = size ( files ) if ( n == 0 ) return do i = 1 , n fp_now ( i ) = file_fingerprint ( files ( i )% s ) if ( fp_now ( i ) /= fp_prev ( i )) then changed_count = changed_count + 1 changed_idx ( changed_count ) = i end if end do end subroutine scan_changes","tags":"","url":"proc/scan_changes.html"},{"title":"fnv1a_mix_i64 – fpm-watch","text":"private  subroutine fnv1a_mix_i64(h, x) Mix a single 64-bit value into a 64-bit FNV-1a state. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: h integer(kind=int64), intent(in) :: x Called by proc~~fnv1a_mix_i64~~CalledByGraph proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~fnv1a_mix_str fnv1a_mix_str proc~fnv1a_mix_str->proc~fnv1a_mix_i64 proc~hash_block hash_block proc~hash_block->proc~fnv1a_mix_i64 proc~manifest_key_from_files manifest_key_from_files proc~manifest_key_from_files->proc~fnv1a_mix_i64 proc~manifest_key_from_files->proc~fnv1a_mix_str proc~file_fingerprint file_fingerprint proc~manifest_key_from_files->proc~file_fingerprint proc~file_fingerprint->proc~hash_block proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~manifest_key_from_files proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change->proc~rebuild_watch_list proc~rebuild_watch_list->proc~manifest_key_from_files proc~init_fingerprints init_fingerprints proc~rebuild_watch_list->proc~init_fingerprints proc~init_fingerprints->proc~file_fingerprint proc~scan_changes scan_changes proc~scan_changes->proc~file_fingerprint proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~handle_manifest_change proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~scan_changes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fnv1a_mix_i64 ( h , x ) integer ( int64 ), intent ( inout ) :: h integer ( int64 ), intent ( in ) :: x h = ieor ( h , x ) h = h * FNV_PRIME end subroutine fnv1a_mix_i64","tags":"","url":"proc/fnv1a_mix_i64.html"},{"title":"fnv1a_mix_str – fpm-watch","text":"private  subroutine fnv1a_mix_str(h, s) Mix a string into a 64-bit FNV-1a state. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: h character(len=*), intent(in) :: s Calls proc~~fnv1a_mix_str~~CallsGraph proc~fnv1a_mix_str fnv1a_mix_str proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~fnv1a_mix_str->proc~fnv1a_mix_i64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fnv1a_mix_str~~CalledByGraph proc~fnv1a_mix_str fnv1a_mix_str proc~manifest_key_from_files manifest_key_from_files proc~manifest_key_from_files->proc~fnv1a_mix_str proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~manifest_key_from_files proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change->proc~rebuild_watch_list proc~rebuild_watch_list->proc~manifest_key_from_files proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~handle_manifest_change proc~watcher_run->proc~rebuild_watch_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fnv1a_mix_str ( h , s ) integer ( int64 ), intent ( inout ) :: h character ( len =* ), intent ( in ) :: s integer :: i do i = 1 , len_trim ( s ) call fnv1a_mix_i64 ( h , int ( iachar ( s ( i : i )), int64 )) end do end subroutine fnv1a_mix_str","tags":"","url":"proc/fnv1a_mix_str.html"},{"title":"hash_block – fpm-watch","text":"private  subroutine hash_block(u, pos, n, h) Hash a single file block at a specific stream position. Arguments Type Intent Optional Attributes Name integer, intent(in) :: u integer(kind=int64), intent(in) :: pos integer, intent(in) :: n integer(kind=int64), intent(inout) :: h Calls proc~~hash_block~~CallsGraph proc~hash_block hash_block proc~fnv1a_mix_i64 fnv1a_mix_i64 proc~hash_block->proc~fnv1a_mix_i64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hash_block~~CalledByGraph proc~hash_block hash_block proc~file_fingerprint file_fingerprint proc~file_fingerprint->proc~hash_block proc~init_fingerprints init_fingerprints proc~init_fingerprints->proc~file_fingerprint proc~manifest_key_from_files manifest_key_from_files proc~manifest_key_from_files->proc~file_fingerprint proc~scan_changes scan_changes proc~scan_changes->proc~file_fingerprint proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~manifest_key_from_files proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change->proc~rebuild_watch_list proc~rebuild_watch_list->proc~init_fingerprints proc~rebuild_watch_list->proc~manifest_key_from_files proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~scan_changes proc~watcher_run->proc~handle_manifest_change proc~watcher_run->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hash_block ( u , pos , n , h ) integer , intent ( in ) :: u integer ( int64 ), intent ( in ) :: pos integer , intent ( in ) :: n integer ( int64 ), intent ( inout ) :: h integer :: ios , i if ( n <= 0 ) return read ( u , pos = pos , iostat = ios ) io_buf ( 1 : n ) if ( ios == 0 ) then do i = 1 , n call fnv1a_mix_i64 ( h , int ( iachar ( io_buf ( i )), int64 )) end do end if end subroutine hash_block","tags":"","url":"proc/hash_block.html"},{"title":"log_debug – fpm-watch","text":"public  subroutine log_debug(w, msg) Log a debug message (prints only when debug is enabled). Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(in) :: w character(len=*), intent(in) :: msg Calls proc~~log_debug~~CallsGraph proc~log_debug log_debug colorize colorize proc~log_debug->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine log_debug ( w , msg ) type ( watch_opts_t ), intent ( in ) :: w character ( len =* ), intent ( in ) :: msg if (. not . w % debug ) return write ( output_unit , '(a)' ) & colorize ( \"debug      |\" , color_fg = 'magenta_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_debug","tags":"","url":"proc/log_debug.html"},{"title":"log_err – fpm-watch","text":"public  subroutine log_err(msg) Log an error message (always prints). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Calls proc~~log_err~~CallsGraph proc~log_err log_err colorize colorize proc~log_err->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine log_err ( msg ) character ( len =* ), intent ( in ) :: msg write ( error_unit , '(a)' ) & colorize ( \"error      |\" , color_fg = 'red_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_err","tags":"","url":"proc/log_err.html"},{"title":"log_info – fpm-watch","text":"public  subroutine log_info(w, msg) Log an informational message. Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(in) :: w character(len=*), intent(in) :: msg Calls proc~~log_info~~CallsGraph proc~log_info log_info colorize colorize proc~log_info->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~log_info~~CalledByGraph proc~log_info log_info proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~log_info proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~log_info proc~rebuild_watch_list rebuild_watch_list proc~handle_manifest_change->proc~rebuild_watch_list proc~rebuild_watch_list->proc~log_info proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~stats_init stats_feature_t%stats_init proc~stats_init->proc~log_info proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~log_info proc~watcher_run->proc~handle_manifest_change proc~watcher_run->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine log_info ( w , msg ) type ( watch_opts_t ), intent ( in ) :: w character ( len =* ), intent ( in ) :: msg if ( w % verbosity < 0 ) return write ( output_unit , '(a)' ) & colorize ( \"info       |\" , color_fg = 'blue_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_info","tags":"","url":"proc/log_info.html"},{"title":"log_warn – fpm-watch","text":"public  subroutine log_warn(w, msg) Log a warning message. Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(in) :: w character(len=*), intent(in) :: msg Calls proc~~log_warn~~CallsGraph proc~log_warn log_warn colorize colorize proc~log_warn->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~log_warn~~CalledByGraph proc~log_warn log_warn proc~enable_features enable_features proc~enable_features->proc~log_warn proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~enable_features Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine log_warn ( w , msg ) type ( watch_opts_t ), intent ( in ) :: w character ( len =* ), intent ( in ) :: msg if ( w % verbosity < 0 ) return write ( output_unit , '(a)' ) & colorize ( \"warn       |\" , color_fg = 'yellow_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_warn","tags":"","url":"proc/log_warn.html"},{"title":"set_low_cpu – fpm-watch","text":"public  subroutine set_low_cpu(flag) Enable or disable low-CPU mode. When enabled, sleep_seconds uses the OS sleep implementation. Arguments Type Intent Optional Attributes Name logical, intent(in) :: flag Called by proc~~set_low_cpu~~CalledByGraph proc~set_low_cpu set_low_cpu proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~set_low_cpu proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~set_low_cpu proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_low_cpu ( flag ) logical , intent ( in ) :: flag low_cpu_mode = flag end subroutine set_low_cpu","tags":"","url":"proc/set_low_cpu.html"},{"title":"sleep_seconds – fpm-watch","text":"public  subroutine sleep_seconds(s) Sleep for a number of seconds. Dispatches to either sleep_os (low CPU) or sleep_spin (busy wait)\ndepending on the global low_cpu_mode . Arguments Type Intent Optional Attributes Name real, intent(in) :: s Calls proc~~sleep_seconds~~CallsGraph proc~sleep_seconds sleep_seconds proc~sleep_os sleep_os proc~sleep_seconds->proc~sleep_os proc~sleep_spin sleep_spin proc~sleep_seconds->proc~sleep_spin interface~c_nanosleep c_nanosleep proc~sleep_os->interface~c_nanosleep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sleep_seconds~~CalledByGraph proc~sleep_seconds sleep_seconds proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~sleep_seconds proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~sleep_seconds proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sleep_seconds ( s ) real , intent ( in ) :: s if ( s <= 0.0 ) return if ( low_cpu_mode ) then call sleep_os ( s ) else call sleep_spin ( s ) end if end subroutine sleep_seconds","tags":"","url":"proc/sleep_seconds.html"},{"title":"sleep_os – fpm-watch","text":"private  subroutine sleep_os(s) OS-backed sleep for approximately s seconds. Windows: calls Sleep(ms) POSIX: calls nanosleep(timespec) This is intended to minimize CPU usage while waiting. Arguments Type Intent Optional Attributes Name real, intent(in) :: s Calls proc~~sleep_os~~CallsGraph proc~sleep_os sleep_os interface~c_nanosleep c_nanosleep proc~sleep_os->interface~c_nanosleep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sleep_os~~CalledByGraph proc~sleep_os sleep_os proc~sleep_seconds sleep_seconds proc~sleep_seconds->proc~sleep_os proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~sleep_seconds proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~sleep_seconds proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sleep_os ( s ) real , intent ( in ) :: s #if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) integer ( c_int ) :: ms real :: ss ss = s if ( ss <= 0.0 ) return ms = int ( ss * 100 0.0 + 0.5 , kind = c_int ) if ( ms <= 0_c_int ) ms = 1_c_int call c_sleep_ms ( ms ) #else type ( timespec ) :: req , rem integer ( c_int ) :: rc real :: ss , frac integer ( c_long ) :: sec integer ( c_long ) :: nsec ss = s if ( ss <= 0.0 ) return sec = int ( ss , kind = c_long ) frac = ss - real ( sec ) if ( frac < 0.0 ) frac = 0.0 nsec = int ( frac * 100000000 0.0 , kind = c_long ) if ( nsec < 0_c_long ) nsec = 0_c_long if ( nsec >= 1000000000_c_long ) then sec = sec + 1_c_long nsec = nsec - 1000000000_c_long end if req % tv_sec = sec req % tv_nsec = nsec do rc = c_nanosleep ( req , rem ) if ( rc == 0_c_int ) exit req = rem end do #endif end subroutine sleep_os","tags":"","url":"proc/sleep_os.html"},{"title":"sleep_spin – fpm-watch","text":"private  subroutine sleep_spin(s) Busy-wait for approximately s seconds. This is used only when low CPU mode is disabled. Arguments Type Intent Optional Attributes Name real, intent(in) :: s Called by proc~~sleep_spin~~CalledByGraph proc~sleep_spin sleep_spin proc~sleep_seconds sleep_seconds proc~sleep_seconds->proc~sleep_spin proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~sleep_seconds proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~sleep_seconds proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sleep_spin ( s ) real , intent ( in ) :: s integer ( int64 ) :: rate , t0 , t1 , ticks if ( s <= 0.0 ) return call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 ticks = int ( s * real ( rate ), int64 ) if ( ticks <= 0_int64 ) return call system_clock ( t0 ) do call system_clock ( t1 ) if ( t1 - t0 >= ticks ) exit end do end subroutine sleep_spin","tags":"","url":"proc/sleep_spin.html"},{"title":"c_nanosleep – fpm-watch","text":"interface Called by interface~~c_nanosleep~~CalledByGraph interface~c_nanosleep c_nanosleep proc~sleep_os sleep_os proc~sleep_os->interface~c_nanosleep proc~sleep_seconds sleep_seconds proc~sleep_seconds->proc~sleep_os proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~sleep_seconds proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~sleep_seconds proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function c_nanosleep(req, rem) bind(C, name=\"nanosleep\") Arguments Type Intent Optional Attributes Name type( timespec ), intent(in) :: req type( timespec ), intent(out) :: rem Return Value integer(kind=c_int)","tags":"","url":"interface/c_nanosleep.html"},{"title":"inject_names_into_cmd – fpm-watch","text":"public  function inject_names_into_cmd(prefix, rest, names) result(out) Inject target names into a command line while respecting a -- delimiter. fpm run and fpm test accept optional name patterns. This helper\ninserts those names into the right location:\n- after the prefix and any existing fpm options,\n- before a -- delimiter (if present), so that program arguments remain\n  attached to the executed program. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix Prefix up to and including the subcommand. character(len=*), intent(in) :: rest Remaining arguments after the subcommand. character(len=*), intent(in) :: names Space-separated names to inject. Return Value character(len=:), allocatable Called by proc~~inject_names_into_cmd~~CalledByGraph proc~inject_names_into_cmd inject_names_into_cmd proc~build_run_command build_run_command proc~build_run_command->proc~inject_names_into_cmd proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~build_run_command Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function inject_names_into_cmd ( prefix , rest , names ) result ( out ) character ( len =* ), intent ( in ) :: prefix !! Prefix up to and including the subcommand. character ( len =* ), intent ( in ) :: rest !! Remaining arguments after the subcommand. character ( len =* ), intent ( in ) :: names !! Space-separated names to inject. character ( len = :), allocatable :: out character ( len = :), allocatable :: p , r , n , before , after integer :: dd p = trim ( prefix ) r = adjustl ( trim ( rest )) n = trim ( names ) if ( len_trim ( p ) == 0 ) then out = \"\" return end if if ( len_trim ( n ) == 0 ) then if ( len_trim ( r ) == 0 ) then out = p else out = p // \" \" // r end if return end if dd = find_double_dash_delim ( r ) if ( dd > 0 ) then if ( dd > 1 ) then before = trim ( r ( 1 : dd - 1 )) else before = \"\" end if after = trim ( adjustl ( r ( dd :))) else before = trim ( r ) after = \"\" end if out = p if ( len_trim ( before ) > 0 ) out = out // \" \" // before out = out // \" \" // n if ( len_trim ( after ) > 0 ) out = out // \" \" // after contains pure integer function find_double_dash_delim ( str ) result ( pos ) character ( len =* ), intent ( in ) :: str integer :: i , n pos = 0 n = len_trim ( str ) if ( n < 2 ) return do i = 1 , n - 1 if ( str ( i : i + 1 ) == \"--\" ) then if ( is_boundary ( str , i - 1 ) . and . is_boundary ( str , i + 2 )) then pos = i return end if end if end do end function find_double_dash_delim pure logical function is_boundary ( str , j ) result ( ok ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: j integer :: n n = len_trim ( str ) if ( j < 1 ) then ok = . true . else if ( j > n ) then ok = . true . else ok = ( str ( j : j ) == \" \" . or . str ( j : j ) == char ( 9 )) end if end function is_boundary end function inject_names_into_cmd","tags":"","url":"proc/inject_names_into_cmd.html"},{"title":"split_cmd_after_subcmd – fpm-watch","text":"public  subroutine split_cmd_after_subcmd(full, prefix, rest) Split a command line into <fpm subcmd> prefix and remaining arguments. This is used to support name injection for fpm run / fpm test :\nthe injected names are inserted after prefix and before the rest,\nwhile respecting a -- delimiter. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full Full command string. character(len=:), intent(out), allocatable :: prefix Prefix up to and including the subcommand token. character(len=:), intent(out), allocatable :: rest Remaining arguments after the subcommand. Called by proc~~split_cmd_after_subcmd~~CalledByGraph proc~split_cmd_after_subcmd split_cmd_after_subcmd proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~split_cmd_after_subcmd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine split_cmd_after_subcmd ( full , prefix , rest ) character ( len =* ), intent ( in ) :: full !! Full command string. character ( len = :), allocatable , intent ( out ) :: prefix !! Prefix up to and including the subcommand token. character ( len = :), allocatable , intent ( out ) :: rest !! Remaining arguments after the subcommand. character ( len = :), allocatable :: s integer :: p_fpm_end , p_sub_start , p_sub_end s = adjustl ( trim ( full )) prefix = \"\" rest = \"\" if ( len_trim ( s ) == 0 ) return if (. not . starts_with_token ( s , \"fpm\" )) return p_fpm_end = token_end ( s , 1 ) p_sub_start = next_token_start ( s , p_fpm_end + 1 ) if ( p_sub_start == 0 ) return p_sub_end = token_end ( s , p_sub_start ) prefix = trim ( s ( 1 : p_sub_end )) if ( p_sub_end < len_trim ( s )) then rest = adjustl ( s ( p_sub_end + 1 :)) else rest = \"\" end if contains pure logical function starts_with_token ( str , tok ) result ( ok ) character ( len =* ), intent ( in ) :: str , tok integer :: e , n ok = . false . n = len_trim ( tok ) if ( n == 0 ) return if ( len_trim ( str ) < n ) return if ( str ( 1 : n ) /= tok ( 1 : n )) return e = token_end ( str , 1 ) ok = ( e == n ) end function starts_with_token pure integer function next_token_start ( str , i ) result ( pos ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: i integer :: k , n pos = 0 n = len_trim ( str ) k = max ( 1 , i ) do while ( k <= n ) if ( str ( k : k ) /= \" \" . and . str ( k : k ) /= char ( 9 )) then pos = k return end if k = k + 1 end do end function next_token_start pure integer function token_end ( str , i ) result ( pos ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: i integer :: k , n pos = 0 n = len_trim ( str ) if ( i < 1 . or . i > n ) return k = i do while ( k <= n ) if ( str ( k : k ) == \" \" . or . str ( k : k ) == char ( 9 )) then pos = k - 1 return end if k = k + 1 end do pos = n end function token_end end subroutine split_cmd_after_subcmd","tags":"","url":"proc/split_cmd_after_subcmd.html"},{"title":"enable_features – fpm-watch","text":"public  subroutine enable_features(fm, w) Enable features requested in watch options. Unknown feature names are ignored with a warning. Arguments Type Intent Optional Attributes Name type( feature_manager_t ), intent(inout) :: fm type( watch_opts_t ), intent(in) :: w Calls proc~~enable_features~~CallsGraph proc~enable_features enable_features proc~add_stats add_stats proc~enable_features->proc~add_stats proc~log_warn log_warn proc~enable_features->proc~log_warn proc~fm_add feature_manager_t%fm_add proc~add_stats->proc~fm_add proc~new_stats_feature new_stats_feature proc~add_stats->proc~new_stats_feature colorize colorize proc~log_warn->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~enable_features~~CalledByGraph proc~enable_features enable_features proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~enable_features Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine enable_features ( fm , w ) type ( feature_manager_t ), intent ( inout ) :: fm type ( watch_opts_t ), intent ( in ) :: w integer :: i character ( len = :), allocatable :: name if (. not . allocated ( w % enabled_features )) return do i = 1 , size ( w % enabled_features ) name = trim ( w % enabled_features ( i )% s ) if ( len_trim ( name ) == 0 ) cycle select case ( name ) case ( \"stats\" ) call add_stats ( fm ) case default call log_warn ( w , \"unknown feature '\" // name // \"' (ignored)\" ) end select end do end subroutine enable_features","tags":"","url":"proc/enable_features.html"},{"title":"add_stats – fpm-watch","text":"private  subroutine add_stats(fm) Factory helper: add the built-in stats feature. Arguments Type Intent Optional Attributes Name type( feature_manager_t ), intent(inout) :: fm Calls proc~~add_stats~~CallsGraph proc~add_stats add_stats proc~fm_add feature_manager_t%fm_add proc~add_stats->proc~fm_add proc~new_stats_feature new_stats_feature proc~add_stats->proc~new_stats_feature Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_stats~~CalledByGraph proc~add_stats add_stats proc~enable_features enable_features proc~enable_features->proc~add_stats proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~enable_features Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_stats ( fm ) type ( feature_manager_t ), intent ( inout ) :: fm class ( watch_feature_t ), allocatable :: f call new_stats_feature ( f ) call fm % add ( f ) end subroutine add_stats","tags":"","url":"proc/add_stats.html"},{"title":"clock_delta – fpm-watch","text":"public pure function clock_delta(t0, t1, max) result(dt) Compute tick delta between two readings with wraparound handling. Some system_clock implementations wrap at count_max . This helper\ntreats t0 and t1 as readings from the same clock configuration. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: t0 Start tick, end tick, and maximum tick before wrap. integer(kind=int64), intent(in) :: t1 Start tick, end tick, and maximum tick before wrap. integer(kind=int64), intent(in) :: max Start tick, end tick, and maximum tick before wrap. Return Value integer(kind=int64) Source Code pure integer ( int64 ) function clock_delta ( t0 , t1 , max ) result ( dt ) integer ( int64 ), intent ( in ) :: t0 , t1 , max !! Start tick, end tick, and maximum tick before wrap. if ( t1 >= t0 ) then dt = t1 - t0 else dt = ( max - t0 + 1_int64 ) + t1 end if end function clock_delta","tags":"","url":"proc/clock_delta.html"},{"title":"ticks_to_seconds – fpm-watch","text":"public pure function ticks_to_seconds(ticks, rate) result(secs) Convert ticks to seconds using a specified tick rate. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: ticks Tick delta and tick rate. integer(kind=int64), intent(in) :: rate Tick delta and tick rate. Return Value real Source Code pure real function ticks_to_seconds ( ticks , rate ) result ( secs ) integer ( int64 ), intent ( in ) :: ticks , rate !! Tick delta and tick rate. secs = real ( ticks ) / real ( rate ) end function ticks_to_seconds","tags":"","url":"proc/ticks_to_seconds.html"},{"title":"clock_init – fpm-watch","text":"public pure subroutine clock_init(rate, max) Initialize system_clock parameters. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out) :: rate Clock tick rate and maximum tick count as reported by system_clock . If the platform reports non-positive values, fallbacks are applied:\n- rate defaults to 1000 ticks/sec.\n- max defaults to huge(1_int64) . integer(kind=int64), intent(out) :: max Clock tick rate and maximum tick count as reported by system_clock . If the platform reports non-positive values, fallbacks are applied:\n- rate defaults to 1000 ticks/sec.\n- max defaults to huge(1_int64) . Source Code pure subroutine clock_init ( rate , max ) integer ( int64 ), intent ( out ) :: rate , max !! Clock tick rate and maximum tick count as reported by `system_clock`. !! !! If the platform reports non-positive values, fallbacks are applied: !! - `rate` defaults to `1000` ticks/sec. !! - `max` defaults to `huge(1_int64)`. call system_clock ( count_rate = rate , count_max = max ) if ( rate <= 0_int64 ) rate = 1000_int64 if ( max <= 0_int64 ) max = huge ( 1_int64 ) end subroutine clock_init","tags":"","url":"proc/clock_init.html"},{"title":"clock_now – fpm-watch","text":"public  subroutine clock_now(t) Fetch the current clock tick count. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out) :: t Current tick count from system_clock . Source Code subroutine clock_now ( t ) integer ( int64 ), intent ( out ) :: t !! Current tick count from `system_clock`. call system_clock ( t ) end subroutine clock_now","tags":"","url":"proc/clock_now.html"},{"title":"is_windows – fpm-watch","text":"public  function is_windows() Return whether the current OS is Windows. Arguments None Return Value logical Calls proc~~is_windows~~CallsGraph proc~is_windows is_windows get_os_type get_os_type proc~is_windows->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_windows~~CalledByGraph proc~is_windows is_windows proc~null_device null_device proc~null_device->proc~is_windows proc~shell_wrap shell_wrap proc~shell_wrap->proc~is_windows Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code logical function is_windows () is_windows = ( get_os_type () == OS_WINDOWS ) end function is_windows","tags":"","url":"proc/is_windows.html"},{"title":"null_device – fpm-watch","text":"public  function null_device() result(p) Return the system null device path. Arguments None Return Value character(len=:), allocatable Calls proc~~null_device~~CallsGraph proc~null_device null_device proc~is_windows is_windows proc~null_device->proc~is_windows get_os_type get_os_type proc~is_windows->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function null_device () result ( p ) character ( len = :), allocatable :: p if ( is_windows ()) then p = \"NUL\" else p = \"/dev/null\" end if end function null_device","tags":"","url":"proc/null_device.html"},{"title":"shell_wrap – fpm-watch","text":"public  function shell_wrap(cmd) result(wrapped) Wrap a command for execution by the platform shell. Windows: cmd /c \"...\" with doubled quotes POSIX: sh -c '...' with standard single-quote escaping Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd Return Value character(len=:), allocatable Calls proc~~shell_wrap~~CallsGraph proc~shell_wrap shell_wrap proc~is_windows is_windows proc~shell_wrap->proc~is_windows get_os_type get_os_type proc~is_windows->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function shell_wrap ( cmd ) result ( wrapped ) character ( len =* ), intent ( in ) :: cmd character ( len = :), allocatable :: wrapped if ( is_windows ()) then wrapped = 'cmd /c \"' // escape_quotes_win ( trim ( cmd )) // '\"' else wrapped = \"sh -c '\" // escape_quotes_sh ( trim ( cmd )) // \"'\" end if contains function escape_quotes_win ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: i r = \"\" do i = 1 , len_trim ( s ) if ( s ( i : i ) == '\"' ) then r = r // '\"\"' else r = r // s ( i : i ) end if end do end function escape_quotes_win function escape_quotes_sh ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: i r = \"\" do i = 1 , len_trim ( s ) if ( s ( i : i ) == \"'\" ) then r = r // \"'\"\"'\"\"'\" else r = r // s ( i : i ) end if end do end function escape_quotes_sh end function shell_wrap","tags":"","url":"proc/shell_wrap.html"},{"title":"build_run_command – fpm-watch","text":"public  function build_run_command(settings, full_cmdline, cmd_prefix, cmd_rest, roots, file_mask, changed_idx, changed_count) result(cmd) Uses watch_cmdsplice proc~~build_run_command~~UsesGraph proc~build_run_command build_run_command module~watch_cmdsplice watch_cmdsplice proc~build_run_command->module~watch_cmdsplice Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Construct the effective command to run based on changes and target masks. For fpm build , the original command is returned unchanged. For fpm run and fpm test , if the user did not already pin names via --name /positional patterns, this routine can inject a computed set of\ntarget names corresponding to the changed files. This reduces redundant\nbuilds and speeds up iterative workflows. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings character(len=*), intent(in) :: full_cmdline character(len=*), intent(in) :: cmd_prefix character(len=*), intent(in) :: cmd_rest type( root_info_t ), intent(in), allocatable :: roots (:) integer(kind=int64), intent(in), allocatable :: file_mask (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count Return Value character(len=:), allocatable Calls proc~~build_run_command~~CallsGraph proc~build_run_command build_run_command proc~inject_names_into_cmd inject_names_into_cmd proc~build_run_command->proc~inject_names_into_cmd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_run_command~~CalledByGraph proc~build_run_command build_run_command proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~build_run_command Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function build_run_command ( settings , full_cmdline , cmd_prefix , cmd_rest , roots , file_mask , changed_idx , changed_count ) result ( cmd ) use watch_cmdsplice , only : inject_names_into_cmd class ( fpm_build_settings ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: full_cmdline character ( len =* ), intent ( in ) :: cmd_prefix character ( len =* ), intent ( in ) :: cmd_rest type ( root_info_t ), allocatable , intent ( in ) :: roots (:) integer ( int64 ), allocatable , intent ( in ) :: file_mask (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count character ( len = :), allocatable :: cmd logical :: is_test , is_run integer ( int64 ) :: hitmask character ( len = :), allocatable :: names_str integer :: j , idx logical :: user_pinned_names is_test = . false . is_run = . false . user_pinned_names = . false . select type ( s => settings ) type is ( fpm_test_settings ) is_test = . true . if ( allocated ( s % name )) user_pinned_names = ( size ( s % name ) > 0 ) type is ( fpm_run_settings ) is_run = . true . if ( allocated ( s % name )) user_pinned_names = ( size ( s % name ) > 0 ) class default continue end select if ( user_pinned_names ) then cmd = trim ( full_cmdline ) return end if if (. not . is_test . and . . not . is_run ) then cmd = trim ( full_cmdline ) return end if if (. not . allocated ( roots ) . or . size ( roots ) == 0 ) then cmd = trim ( full_cmdline ) return end if if (. not . allocated ( file_mask )) then cmd = trim ( full_cmdline ) return end if hitmask = 0_int64 do j = 1 , changed_count idx = changed_idx ( j ) if ( idx < 1 . or . idx > size ( file_mask )) cycle hitmask = ior ( hitmask , file_mask ( idx )) end do if ( hitmask == 0_int64 ) then cmd = trim ( full_cmdline ) return end if names_str = join_names_from_mask ( roots , hitmask ) if ( len_trim ( names_str ) == 0 ) then cmd = trim ( full_cmdline ) return end if if ( len_trim ( cmd_prefix ) == 0 ) then cmd = trim ( full_cmdline ) return end if cmd = inject_names_into_cmd ( cmd_prefix , cmd_rest , names_str ) contains function join_names_from_mask ( roots , mask ) result ( s ) type ( root_info_t ), intent ( in ) :: roots (:) integer ( int64 ), intent ( in ) :: mask character ( len = :), allocatable :: s integer :: rr character ( len = :), allocatable :: nm s = \"\" do rr = 1 , size ( roots ) if ( iand ( mask , roots ( rr )% mask ) == 0_int64 ) cycle if (. not . allocated ( roots ( rr )% name )) cycle nm = trim ( roots ( rr )% name ) if ( len_trim ( nm ) == 0 ) cycle if ( len ( s ) > 0 ) s = s // \" \" s = s // nm end do end function join_names_from_mask end function build_run_command","tags":"","url":"proc/build_run_command.html"},{"title":"report_changes – fpm-watch","text":"public  subroutine report_changes(files, changed_idx, changed_count, w) Print a summary of changed files. The output is intentionally limited (cap=8) to keep logs compact.\nThis routine is suppressed in quiet mode ( w%verbosity < 0 ). Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count type( watch_opts_t ), intent(in) :: w Calls proc~~report_changes~~CallsGraph proc~report_changes report_changes colorize colorize proc~report_changes->colorize proc~ftoa ftoa proc~report_changes->proc~ftoa str str proc~report_changes->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~report_changes~~CalledByGraph proc~report_changes report_changes proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~report_changes Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine report_changes ( files , changed_idx , changed_count , w ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count type ( watch_opts_t ), intent ( in ) :: w integer :: i , cap , idx if ( w % verbosity < 0 ) return cap = 8 write ( output_unit , '(a)' ) & colorize ( \"change     |\" , color_fg = 'yellow_intense' , style = 'bold_on' ) // \"  \" // & colorize ( str ( changed_count ), color_fg = 'yellow_intense' , style = 'bold_on' ) // & \" files (debounced \" // colorize ( ftoa ( w % debounce ), color_fg = 'yellow' ) // \"s)\" if ( changed_count == 0 ) return if (. not . allocated ( files )) return do i = 1 , min ( changed_count , cap ) idx = changed_idx ( i ) if ( idx < 1 . or . idx > size ( files )) cycle write ( output_unit , '(a)' ) \"           |  \" // colorize ( trim ( files ( idx )% s ), color_fg = 'yellow' ) end do if ( changed_count > cap ) then write ( output_unit , '(a)' ) & \"           |  ... +\" // colorize ( str ( changed_count - cap ), color_fg = 'yellow' ) // \" more\" end if end subroutine report_changes","tags":"","url":"proc/report_changes.html"},{"title":"run_command_and_report – fpm-watch","text":"public  subroutine run_command_and_report(cmd, w, exitstat, secs) Execute a command and print pre/post status lines. This routine is responsible for:\n- Printing a \"run\" line (unless quiet),\n- Executing the command via fpm_filesystem:run ,\n- Timing the execution with system_clock ,\n- Printing a final OK/FAIL summary and returning exitstat and secs . When w%silent_fpm is true, the executed command's output is suppressed\n(but the status lines from fpm-watch remain visible). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd type( watch_opts_t ), intent(in) :: w integer, intent(out) :: exitstat real, intent(out) :: secs Calls proc~~run_command_and_report~~CallsGraph proc~run_command_and_report run_command_and_report colorize colorize proc~run_command_and_report->colorize proc~ftoa ftoa proc~run_command_and_report->proc~ftoa run run proc~run_command_and_report->run str str proc~run_command_and_report->str Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~run_command_and_report~~CalledByGraph proc~run_command_and_report run_command_and_report proc~run_once run_once proc~run_once->proc~run_command_and_report proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~run_command_and_report proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~run_once Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine run_command_and_report ( cmd , w , exitstat , secs ) character ( len =* ), intent ( in ) :: cmd type ( watch_opts_t ), intent ( in ) :: w integer , intent ( out ) :: exitstat real , intent ( out ) :: secs integer ( int64 ) :: rate , t0 , t1 logical :: verbose_run character ( len = :), allocatable :: status_color character ( len = :), allocatable :: status_word call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 verbose_run = . not . w % silent_fpm if ( w % verbosity >= 0 ) then if ( w % silent_fpm ) then write ( output_unit , '(a)' ) & colorize ( \"run        |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( cmd ), color_fg = 'white_intense' ) // \"  \" // & colorize ( \"(fpm output silenced)\" , color_fg = 'magenta_intense' , style = 'italics_on' ) else write ( output_unit , '(a)' ) & colorize ( \"run        |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( cmd ), color_fg = 'white_intense' ) end if end if if ( w % verbosity >= 0 ) flush ( output_unit ) call system_clock ( t0 ) call run ( trim ( cmd ), echo = . false ., exitstat = exitstat , verbose = verbose_run ) call system_clock ( t1 ) secs = real ( t1 - t0 ) / real ( rate ) if ( exitstat == 0 ) then status_color = \"green_intense\" status_word = \"OK\" else status_color = \"red_intense\" status_word = \"FAIL\" end if if ( w % verbosity >= 0 ) then write ( output_unit , '(a)' ) \"\" write ( output_unit , '(a)' ) & colorize ( \"done       |\" , color_fg = status_color , style = 'bold_on' ) // & \"  \" // colorize ( status_word , color_fg = status_color , style = 'bold_on' ) // & \"  exit=\" // colorize ( str ( exitstat ), color_fg = status_color , style = 'bold_on' ) // & \"  time=\" // colorize ( ftoa ( secs ), color_fg = 'yellow_intense' ) // \"s\" write ( output_unit , '(a)' ) & colorize ( \"command    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( cmd ), color_fg = 'white_intense' ) write ( output_unit , '(a)' ) & colorize ( \"watch      |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  waiting (poll=\" // colorize ( ftoa ( w % poll ), color_fg = 'yellow' ) // \"s\" // & \", debounce=\" // colorize ( ftoa ( w % debounce ), color_fg = 'yellow' ) // \"s)  \" // & colorize ( \"Ctrl+C\" , color_fg = 'red_intense' , style = 'bold_on' ) // \" to stop\" end if end subroutine run_command_and_report","tags":"","url":"proc/run_command_and_report.html"},{"title":"is_ignored_path – fpm-watch","text":"public pure function is_ignored_path(path, build_dir) result(ignored) Identify paths that should be ignored due to being inside the build directory. This is used to prevent watch loops from triggering rebuilds due to build\nartifacts changing. When dependency watching is enabled, callers may\nselectively override this behavior. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path character(len=*), intent(in) :: build_dir Return Value logical Calls proc~~is_ignored_path~~CallsGraph proc~is_ignored_path is_ignored_path proc~contains_path_fragment contains_path_fragment proc~is_ignored_path->proc~contains_path_fragment proc~normalize_path normalize_path proc~is_ignored_path->proc~normalize_path proc~starts_with~2 starts_with proc~is_ignored_path->proc~starts_with~2 proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_ignored_path~~CalledByGraph proc~is_ignored_path is_ignored_path proc~vec_push_unique vec_push_unique proc~vec_push_unique->proc~is_ignored_path proc~gather_files_with_mask gather_files_with_mask proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask push_file_with_mask proc~push_file_with_mask->proc~vec_push_unique proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function is_ignored_path ( path , build_dir ) result ( ignored ) character ( len =* ), intent ( in ) :: path , build_dir character ( len = :), allocatable :: p , b p = normalize_path ( path ) b = normalize_path ( build_dir ) ignored = . false . if ( len_trim ( b ) == 0 ) return if ( p == b ) then ignored = . true . return end if if ( starts_with ( p , b // \"/\" )) then ignored = . true . return end if if ( contains_path_fragment ( p , b )) then ignored = . true . return end if end function is_ignored_path","tags":"","url":"proc/is_ignored_path.html"},{"title":"normalize_path – fpm-watch","text":"public pure function normalize_path(path) result(p) Normalize a path to a consistent form for matching. Transformations:\n- Backslashes ( \\ ) → slashes ( / )\n- Strip any leading ./ prefixes (repeatedly) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:), allocatable Called by proc~~normalize_path~~CalledByGraph proc~normalize_path normalize_path proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~normalize_path proc~filter_watch_files filter_watch_files proc~compute_watch_files_from_settings->proc~filter_watch_files proc~gather_files_with_mask gather_files_with_mask proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~push_file_with_mask push_file_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~filter_watch_files->proc~normalize_path proc~is_ignored_path is_ignored_path proc~is_ignored_path->proc~normalize_path proc~is_in_dep_dirs is_in_dep_dirs proc~is_in_dep_dirs->proc~normalize_path proc~vec_push_unique vec_push_unique proc~vec_push_unique->proc~normalize_path proc~vec_push_unique->proc~is_ignored_path proc~vec_push_unique->proc~is_in_dep_dirs proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask->proc~vec_push_unique proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function normalize_path ( path ) result ( p ) character ( len =* ), intent ( in ) :: path character ( len = :), allocatable :: p integer :: i p = trim ( path ) do i = 1 , len ( p ) if ( p ( i : i ) == char ( 92 )) p ( i : i ) = \"/\" end do do while ( len ( p ) >= 2 ) if ( p ( 1 : 2 ) == \"./\" ) then p = p ( 3 :) else exit end if end do end function normalize_path","tags":"","url":"proc/normalize_path.html"},{"title":"starts_with – fpm-watch","text":"public pure function starts_with(s, prefix) result(ok) Check whether a string begins with a given prefix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: prefix Return Value logical Called by proc~~starts_with~2~~CalledByGraph proc~starts_with~2 starts_with proc~is_ignored_path is_ignored_path proc~is_ignored_path->proc~starts_with~2 proc~is_in_dep_dirs is_in_dep_dirs proc~is_in_dep_dirs->proc~starts_with~2 proc~vec_push_unique vec_push_unique proc~vec_push_unique->proc~is_ignored_path proc~vec_push_unique->proc~is_in_dep_dirs proc~gather_files_with_mask gather_files_with_mask proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask push_file_with_mask proc~push_file_with_mask->proc~vec_push_unique proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function starts_with ( s , prefix ) result ( ok ) character ( len =* ), intent ( in ) :: s , prefix integer :: n n = len_trim ( prefix ) if ( n <= 0 ) then ok = . true . else if ( len_trim ( s ) < n ) then ok = . false . else ok = ( s ( 1 : n ) == prefix ( 1 : n )) end if end function starts_with","tags":"","url":"proc/starts_with~2.html"},{"title":"contains_path_fragment – fpm-watch","text":"private pure function contains_path_fragment(p, frag) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: p character(len=*), intent(in) :: frag Return Value logical Calls proc~~contains_path_fragment~~CallsGraph proc~contains_path_fragment contains_path_fragment proc~ends_with ends_with proc~contains_path_fragment->proc~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~contains_path_fragment~~CalledByGraph proc~contains_path_fragment contains_path_fragment proc~is_ignored_path is_ignored_path proc~is_ignored_path->proc~contains_path_fragment proc~vec_push_unique vec_push_unique proc~vec_push_unique->proc~is_ignored_path proc~gather_files_with_mask gather_files_with_mask proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask push_file_with_mask proc~push_file_with_mask->proc~vec_push_unique proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function contains_path_fragment ( p , frag ) result ( ok ) character ( len =* ), intent ( in ) :: p , frag character ( len = :), allocatable :: needle ok = . false . if ( len_trim ( frag ) == 0 ) return needle = \"/\" // trim ( frag ) // \"/\" if ( index ( p , needle ) /= 0 ) then ok = . true . return end if if ( ends_with ( p , \"/\" // trim ( frag ))) then ok = . true . return end if end function contains_path_fragment","tags":"","url":"proc/contains_path_fragment.html"},{"title":"ends_with – fpm-watch","text":"private pure function ends_with(s, suffix) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: suffix Return Value logical Called by proc~~ends_with~~CalledByGraph proc~ends_with ends_with proc~contains_path_fragment contains_path_fragment proc~contains_path_fragment->proc~ends_with proc~is_ignored_path is_ignored_path proc~is_ignored_path->proc~contains_path_fragment proc~vec_push_unique vec_push_unique proc~vec_push_unique->proc~is_ignored_path proc~gather_files_with_mask gather_files_with_mask proc~gather_files_with_mask->proc~vec_push_unique proc~push_file_with_mask push_file_with_mask proc~push_file_with_mask->proc~vec_push_unique proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~gather_files_with_mask proc~compute_watch_files_from_settings->proc~push_file_with_mask proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function ends_with ( s , suffix ) result ( ok ) character ( len =* ), intent ( in ) :: s , suffix integer :: ns , n ns = len_trim ( suffix ) n = len_trim ( s ) if ( ns <= 0 ) then ok = . true . else if ( n < ns ) then ok = . false . else ok = ( s ( n - ns + 1 : n ) == suffix ( 1 : ns )) end if end function ends_with","tags":"","url":"proc/ends_with.html"},{"title":"filter_watch_files – fpm-watch","text":"public  subroutine filter_watch_files(files, include, ignore, masks) Apply include/ignore rules to the watch list. If include patterns are empty, all files are included by default. If include patterns are present, only matching files are kept. If ignore patterns match a file, it is removed even if included. The masks array (when present) is filtered in sync with files . Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: files (:) type(string_t), intent(in), allocatable :: include (:) type(string_t), intent(in), allocatable :: ignore (:) integer(kind=int64), intent(inout), optional, allocatable :: masks (:) Calls proc~~filter_watch_files~~CallsGraph proc~filter_watch_files filter_watch_files basename basename proc~filter_watch_files->basename glob glob proc~filter_watch_files->glob proc~normalize_path normalize_path proc~filter_watch_files->proc~normalize_path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~filter_watch_files~~CalledByGraph proc~filter_watch_files filter_watch_files proc~compute_watch_files_from_settings compute_watch_files_from_settings proc~compute_watch_files_from_settings->proc~filter_watch_files proc~rebuild_watch_list rebuild_watch_list proc~rebuild_watch_list->proc~compute_watch_files_from_settings proc~handle_manifest_change handle_manifest_change proc~handle_manifest_change->proc~rebuild_watch_list proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~rebuild_watch_list proc~watcher_run watcher_t%watcher_run proc~watcher_run->proc~rebuild_watch_list proc~watcher_run->proc~handle_manifest_change Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine filter_watch_files ( files , include , ignore , masks ) type ( string_t ), allocatable , intent ( inout ) :: files (:) type ( string_t ), allocatable , intent ( in ) :: include (:), ignore (:) integer ( int64 ), allocatable , intent ( inout ), optional :: masks (:) logical , allocatable :: keep (:) type ( string_t ), allocatable :: out (:) integer ( int64 ), allocatable :: outm (:) integer :: i , k , n , m if (. not . allocated ( files )) return n = size ( files ) allocate ( keep ( n )) do i = 1 , n keep ( i ) = should_keep ( files ( i )% s , include , ignore ) end do m = count ( keep ) allocate ( out ( m )) if ( present ( masks )) then if (. not . allocated ( masks )) then allocate ( masks ( n )) masks = 0_int64 end if allocate ( outm ( m )) end if k = 0 do i = 1 , n if (. not . keep ( i )) cycle k = k + 1 out ( k )% s = files ( i )% s if ( present ( masks )) outm ( k ) = masks ( i ) end do call move_alloc ( out , files ) if ( present ( masks )) call move_alloc ( outm , masks ) deallocate ( keep ) contains logical function should_keep ( path , include_pats , ignore_pats ) result ( ok ) character ( len =* ), intent ( in ) :: path type ( string_t ), allocatable , intent ( in ) :: include_pats (:), ignore_pats (:) character ( len = :), allocatable :: b b = basename ( trim ( path )) if ( b == \"fpm.toml\" ) then ok = . true . return end if ok = match_include ( path , include_pats ) . and . (. not . match_any ( path , ignore_pats )) end function should_keep logical function match_any ( path , pats ) result ( ok ) character ( len =* ), intent ( in ) :: path type ( string_t ), allocatable , intent ( in ) :: pats (:) integer :: j character ( len = :), allocatable :: pat ok = . false . if (. not . allocated ( pats )) return do j = 1 , size ( pats ) if ( len_trim ( pats ( j )% s ) == 0 ) cycle pat = normalize_path ( trim ( pats ( j )% s )) if ( glob ( pat , trim ( path ))) then ok = . true . return end if end do end function match_any logical function match_include ( path , pats ) result ( ok ) character ( len =* ), intent ( in ) :: path type ( string_t ), allocatable , intent ( in ) :: pats (:) if (. not . allocated ( pats )) then ok = . true . return end if if ( size ( pats ) == 0 ) then ok = . true . return end if ok = match_any ( path , pats ) end function match_include end subroutine filter_watch_files","tags":"","url":"proc/filter_watch_files.html"},{"title":"apply_watch_from_manifest – fpm-watch","text":"public  subroutine apply_watch_from_manifest(w) Apply configuration overrides from fpm.toml [extra.fpm-watch] . Missing keys are ignored; successfully read values override existing\ndefaults. Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(inout) :: w Calls proc~~apply_watch_from_manifest~~CallsGraph proc~apply_watch_from_manifest apply_watch_from_manifest proc~load_watch_table load_watch_table proc~apply_watch_from_manifest->proc~load_watch_table proc~normalize_watch_opts normalize_watch_opts proc~apply_watch_from_manifest->proc~normalize_watch_opts proc~toml_get_int toml_get_int proc~apply_watch_from_manifest->proc~toml_get_int proc~toml_get_list_strings toml_get_list_strings proc~apply_watch_from_manifest->proc~toml_get_list_strings proc~toml_get_logical toml_get_logical proc~apply_watch_from_manifest->proc~toml_get_logical proc~toml_get_real toml_get_real proc~apply_watch_from_manifest->proc~toml_get_real exists exists proc~load_watch_table->exists get_value get_value proc~load_watch_table->get_value read_package_file read_package_file proc~load_watch_table->read_package_file proc~toml_get_int->get_value get_list get_list proc~toml_get_list_strings->get_list proc~toml_get_logical->get_value proc~toml_get_real->get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~apply_watch_from_manifest~~CalledByGraph proc~apply_watch_from_manifest apply_watch_from_manifest proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_from_manifest proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apply_watch_from_manifest ( w ) type ( watch_opts_t ), intent ( inout ) :: w type ( toml_table ), allocatable :: root type ( toml_table ), pointer :: wt logical :: ok call load_watch_table ( root , wt , ok ) if (. not . ok ) return call toml_get_real ( wt , \"poll\" , w % poll ) call toml_get_real ( wt , \"debounce\" , w % debounce ) call toml_get_real ( wt , \"rescan\" , w % rescan ) call toml_get_logical ( wt , \"debug\" , w % debug ) call toml_get_logical ( wt , \"print-files\" , w % print_files_once ) call toml_get_logical ( wt , \"silent-fpm\" , w % silent_fpm ) call toml_get_logical ( wt , \"run-on-start\" , w % run_on_start ) call toml_get_logical ( wt , \"deps\" , w % watch_deps ) call toml_get_logical ( wt , \"low-cpu\" , w % low_cpu ) call toml_get_logical ( wt , \"once\" , w % once ) call toml_get_int ( wt , \"verbosity\" , w % verbosity ) call toml_get_list_strings ( wt , \"ignore\" , w % ignore ) call toml_get_list_strings ( wt , \"include\" , w % include ) call toml_get_list_strings ( wt , \"features\" , w % enabled_features ) call normalize_watch_opts ( w ) end subroutine apply_watch_from_manifest","tags":"","url":"proc/apply_watch_from_manifest.html"},{"title":"get_restart_defaults – fpm-watch","text":"public  subroutine get_restart_defaults(auto_restart, restart_delay, restart_max, self_exe) Read supervisor defaults from the manifest (when present). These are used by watch_restart and can be configured under [extra.fpm-watch] . Keys:\n- auto-restart (logical)\n- restart-delay (real, seconds)\n- restart-max (integer, 0 = unlimited)\n- self or self-exe (string, explicit path to fpm-watch ) Arguments Type Intent Optional Attributes Name logical, intent(out) :: auto_restart real, intent(out) :: restart_delay integer, intent(out) :: restart_max character(len=:), intent(out), allocatable :: self_exe Calls proc~~get_restart_defaults~~CallsGraph proc~get_restart_defaults get_restart_defaults proc~load_watch_table load_watch_table proc~get_restart_defaults->proc~load_watch_table proc~toml_get_int toml_get_int proc~get_restart_defaults->proc~toml_get_int proc~toml_get_logical toml_get_logical proc~get_restart_defaults->proc~toml_get_logical proc~toml_get_real toml_get_real proc~get_restart_defaults->proc~toml_get_real proc~toml_get_string toml_get_string proc~get_restart_defaults->proc~toml_get_string exists exists proc~load_watch_table->exists get_value get_value proc~load_watch_table->get_value read_package_file read_package_file proc~load_watch_table->read_package_file proc~toml_get_int->get_value proc~toml_get_logical->get_value proc~toml_get_real->get_value proc~toml_get_string->get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_restart_defaults~~CalledByGraph proc~get_restart_defaults get_restart_defaults proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~get_restart_defaults proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine get_restart_defaults ( auto_restart , restart_delay , restart_max , self_exe ) logical , intent ( out ) :: auto_restart real , intent ( out ) :: restart_delay integer , intent ( out ) :: restart_max character ( len = :), allocatable , intent ( out ) :: self_exe type ( toml_table ), allocatable :: root type ( toml_table ), pointer :: wt logical :: ok character ( len = :), allocatable :: tmp auto_restart = . false . restart_delay = 1.0 restart_max = 0 self_exe = \"\" call load_watch_table ( root , wt , ok ) if (. not . ok ) return call toml_get_logical ( wt , \"auto-restart\" , auto_restart ) call toml_get_real ( wt , \"restart-delay\" , restart_delay ) call toml_get_int ( wt , \"restart-max\" , restart_max ) tmp = \"\" call toml_get_string ( wt , \"self\" , tmp ) if ( len_trim ( tmp ) == 0 ) call toml_get_string ( wt , \"self-exe\" , tmp ) if ( len_trim ( tmp ) > 0 ) self_exe = trim ( tmp ) if ( restart_delay < 0.0 ) restart_delay = 0.0 if ( restart_max < 0 ) restart_max = 0 end subroutine get_restart_defaults","tags":"","url":"proc/get_restart_defaults.html"},{"title":"normalize_watch_opts – fpm-watch","text":"public  subroutine normalize_watch_opts(w) Normalize watcher options and clamp to safe bounds. Clamping prevents pathological values (e.g., negative times, too-small poll\nintervals) from degrading performance or usability. Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(inout) :: w Called by proc~~normalize_watch_opts~~CalledByGraph proc~normalize_watch_opts normalize_watch_opts proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~normalize_watch_opts proc~apply_watch_from_manifest apply_watch_from_manifest proc~apply_watch_from_manifest->proc~normalize_watch_opts proc~parse_cli parse_cli proc~parse_cli->proc~normalize_watch_opts proc~parse_cli->proc~apply_watch_flag proc~parse_cli->proc~apply_watch_from_manifest proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine normalize_watch_opts ( w ) type ( watch_opts_t ), intent ( inout ) :: w if ( w % poll < 0.05 ) w % poll = 0.05 if ( w % debounce < 0.0 ) w % debounce = 0.0 if ( w % rescan < 0.0 ) w % rescan = 0.0 if ( w % verbosity > 2 ) w % verbosity = 2 if ( w % verbosity < - 1 ) w % verbosity = - 1 end subroutine normalize_watch_opts","tags":"","url":"proc/normalize_watch_opts.html"},{"title":"push_feature – fpm-watch","text":"public  subroutine push_feature(features, name) Append a feature name to a string_t array if not already present. This is used both for plugin feature names and for ignore/include patterns. Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: features (:) character(len=*), intent(in) :: name Called by proc~~push_feature~~CalledByGraph proc~push_feature push_feature proc~add_features_csv add_features_csv proc~add_features_csv->proc~push_feature proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~push_feature proc~parse_cli parse_cli proc~parse_cli->proc~push_feature proc~parse_cli->proc~add_features_csv proc~parse_cli->proc~apply_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine push_feature ( features , name ) type ( string_t ), allocatable , intent ( inout ) :: features (:) character ( len =* ), intent ( in ) :: name integer :: n , i type ( string_t ), allocatable :: tmp (:) if ( len_trim ( name ) == 0 ) return if (. not . allocated ( features )) then allocate ( features ( 1 )) features ( 1 )% s = trim ( name ) return end if do i = 1 , size ( features ) if ( trim ( features ( i )% s ) == trim ( name )) return end do n = size ( features ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = features tmp ( n + 1 )% s = trim ( name ) call move_alloc ( tmp , features ) end subroutine push_feature","tags":"","url":"proc/push_feature.html"},{"title":"set_watch_defaults – fpm-watch","text":"public  subroutine set_watch_defaults(w) Apply built-in defaults to watcher options. This routine sets conservative defaults intended to work well for most\nprojects, and ensures that list fields are always allocated (possibly\nwith size zero). Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(inout) :: w Called by proc~~set_watch_defaults~~CalledByGraph proc~set_watch_defaults set_watch_defaults proc~parse_cli parse_cli proc~parse_cli->proc~set_watch_defaults proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_watch_defaults ( w ) type ( watch_opts_t ), intent ( inout ) :: w w % verbosity = 0 w % debug = . false . w % poll = 0.5 w % debounce = 0.2 w % rescan = 0.0 w % run_on_start = . true . w % print_files_once = . false . w % silent_fpm = . false . w % watch_deps = . false . w % low_cpu = . false . w % once = . false . if (. not . allocated ( w % ignore )) allocate ( w % ignore ( 0 )) if (. not . allocated ( w % include )) allocate ( w % include ( 0 )) if (. not . allocated ( w % enabled_features )) allocate ( w % enabled_features ( 0 )) end subroutine set_watch_defaults","tags":"","url":"proc/set_watch_defaults.html"},{"title":"load_watch_table – fpm-watch","text":"private  subroutine load_watch_table(root, wt, ok) Locate and return the [extra.fpm-watch] table from fpm.toml . Returns ok=.false. when:\n- fpm.toml is missing,\n- the TOML cannot be read,\n- the extra table is absent,\n- the fpm-watch table is absent. Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: root type(toml_table), intent(out), pointer :: wt logical, intent(out) :: ok Calls proc~~load_watch_table~~CallsGraph proc~load_watch_table load_watch_table exists exists proc~load_watch_table->exists get_value get_value proc~load_watch_table->get_value read_package_file read_package_file proc~load_watch_table->read_package_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~load_watch_table~~CalledByGraph proc~load_watch_table load_watch_table proc~apply_watch_from_manifest apply_watch_from_manifest proc~apply_watch_from_manifest->proc~load_watch_table proc~get_restart_defaults get_restart_defaults proc~get_restart_defaults->proc~load_watch_table proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_from_manifest proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~get_restart_defaults proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine load_watch_table ( root , wt , ok ) type ( toml_table ), allocatable , intent ( out ) :: root type ( toml_table ), pointer , intent ( out ) :: wt logical , intent ( out ) :: ok type ( toml_table ), pointer :: extra type ( error_t ), allocatable :: err integer :: stat ok = . false . wt => null () extra => null () if (. not . exists ( \"fpm.toml\" )) return call read_package_file ( root , \"fpm.toml\" , err ) if ( allocated ( err )) return call get_value ( root , \"extra\" , extra , requested = . false ., stat = stat ) if ( stat /= toml_stat % success ) return if (. not . associated ( extra )) return call get_value ( extra , \"fpm-watch\" , wt , requested = . false ., stat = stat ) if ( stat /= toml_stat % success ) return if (. not . associated ( wt )) return ok = . true . end subroutine load_watch_table","tags":"","url":"proc/load_watch_table.html"},{"title":"toml_get_int – fpm-watch","text":"private  subroutine toml_get_int(table, key, v) Read a TOML integer value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key integer, intent(inout) :: v Calls proc~~toml_get_int~~CallsGraph proc~toml_get_int toml_get_int get_value get_value proc~toml_get_int->get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~toml_get_int~~CalledByGraph proc~toml_get_int toml_get_int proc~apply_watch_from_manifest apply_watch_from_manifest proc~apply_watch_from_manifest->proc~toml_get_int proc~get_restart_defaults get_restart_defaults proc~get_restart_defaults->proc~toml_get_int proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_from_manifest proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~get_restart_defaults proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine toml_get_int ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key integer , intent ( inout ) :: v integer :: tmp , stat tmp = v call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) v = tmp end subroutine toml_get_int","tags":"","url":"proc/toml_get_int.html"},{"title":"toml_get_list_strings – fpm-watch","text":"private  subroutine toml_get_list_strings(table, key, list) Read a TOML string list into an allocatable string_t array. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key type(string_t), intent(inout), allocatable :: list (:) Calls proc~~toml_get_list_strings~~CallsGraph proc~toml_get_list_strings toml_get_list_strings get_list get_list proc~toml_get_list_strings->get_list Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~toml_get_list_strings~~CalledByGraph proc~toml_get_list_strings toml_get_list_strings proc~apply_watch_from_manifest apply_watch_from_manifest proc~apply_watch_from_manifest->proc~toml_get_list_strings proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_from_manifest proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine toml_get_list_strings ( table , key , list ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key type ( string_t ), allocatable , intent ( inout ) :: list (:) type ( error_t ), allocatable :: err type ( string_t ), allocatable :: tmp (:) if (. not . allocated ( list )) allocate ( list ( 0 )) call get_list ( table , key , tmp , err ) if ( allocated ( err )) then if ( allocated ( tmp )) deallocate ( tmp ) return end if if (. not . allocated ( tmp )) return call move_alloc ( tmp , list ) end subroutine toml_get_list_strings","tags":"","url":"proc/toml_get_list_strings.html"},{"title":"toml_get_logical – fpm-watch","text":"private  subroutine toml_get_logical(table, key, v) Read a TOML logical value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key logical, intent(inout) :: v Calls proc~~toml_get_logical~~CallsGraph proc~toml_get_logical toml_get_logical get_value get_value proc~toml_get_logical->get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~toml_get_logical~~CalledByGraph proc~toml_get_logical toml_get_logical proc~apply_watch_from_manifest apply_watch_from_manifest proc~apply_watch_from_manifest->proc~toml_get_logical proc~get_restart_defaults get_restart_defaults proc~get_restart_defaults->proc~toml_get_logical proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_from_manifest proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~get_restart_defaults proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine toml_get_logical ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key logical , intent ( inout ) :: v logical :: tmp integer :: stat tmp = v call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) v = tmp end subroutine toml_get_logical","tags":"","url":"proc/toml_get_logical.html"},{"title":"toml_get_real – fpm-watch","text":"private  subroutine toml_get_real(table, key, v) Read a TOML real value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key real, intent(inout) :: v Calls proc~~toml_get_real~~CallsGraph proc~toml_get_real toml_get_real get_value get_value proc~toml_get_real->get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~toml_get_real~~CalledByGraph proc~toml_get_real toml_get_real proc~apply_watch_from_manifest apply_watch_from_manifest proc~apply_watch_from_manifest->proc~toml_get_real proc~get_restart_defaults get_restart_defaults proc~get_restart_defaults->proc~toml_get_real proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_from_manifest proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~get_restart_defaults proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine toml_get_real ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key real , intent ( inout ) :: v real :: tmp integer :: stat tmp = v call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) v = tmp end subroutine toml_get_real","tags":"","url":"proc/toml_get_real.html"},{"title":"toml_get_string – fpm-watch","text":"private  subroutine toml_get_string(table, key, v) Read a TOML string value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key character(len=:), intent(inout), allocatable :: v Calls proc~~toml_get_string~~CallsGraph proc~toml_get_string toml_get_string get_value get_value proc~toml_get_string->get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~toml_get_string~~CalledByGraph proc~toml_get_string toml_get_string proc~get_restart_defaults get_restart_defaults proc~get_restart_defaults->proc~toml_get_string proc~parse_restart_flags parse_restart_flags proc~parse_restart_flags->proc~get_restart_defaults proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine toml_get_string ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key character ( len = :), allocatable , intent ( inout ) :: v character ( len = :), allocatable :: tmp integer :: stat call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) then if ( allocated ( tmp )) then v = tmp else v = \"\" end if end if end subroutine toml_get_string","tags":"","url":"proc/toml_get_string.html"},{"title":"new_stats_feature – fpm-watch","text":"public  subroutine new_stats_feature(f) Allocate a new stats feature instance. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(out), allocatable :: f Called by proc~~new_stats_feature~~CalledByGraph proc~new_stats_feature new_stats_feature proc~add_stats add_stats proc~add_stats->proc~new_stats_feature proc~enable_features enable_features proc~enable_features->proc~add_stats proc~watcher_init watcher_t%watcher_init proc~watcher_init->proc~enable_features Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine new_stats_feature ( f ) class ( watch_feature_t ), allocatable , intent ( out ) :: f allocate ( stats_feature_t :: f ) end subroutine new_stats_feature","tags":"","url":"proc/new_stats_feature.html"},{"title":"stats_after – fpm-watch","text":"private  subroutine stats_after(self, exitstat, seconds) Update run counter after each completed command execution. The exit status and runtime are currently not used by this feature. Type Bound stats_feature_t Arguments Type Intent Optional Attributes Name class( stats_feature_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds Source Code subroutine stats_after ( self , exitstat , seconds ) class ( stats_feature_t ), intent ( inout ) :: self integer , intent ( in ) :: exitstat real , intent ( in ) :: seconds self % runs = self % runs + 1 if (. false .) then if ( exitstat /= 0 ) continue if ( seconds < 0.0 ) continue end if end subroutine stats_after","tags":"","url":"proc/stats_after.html"},{"title":"stats_init – fpm-watch","text":"private  subroutine stats_init(self, cfg) Initialize the stats feature. Currently logs a single \"feature enabled\" message. Type Bound stats_feature_t Arguments Type Intent Optional Attributes Name class( stats_feature_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg Calls proc~~stats_init~~CallsGraph proc~stats_init stats_feature_t%stats_init proc~log_info log_info proc~stats_init->proc~log_info colorize colorize proc~log_info->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine stats_init ( self , cfg ) class ( stats_feature_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg call log_info ( cfg % w , \"feature enabled: stats\" ) end subroutine stats_init","tags":"","url":"proc/stats_init.html"},{"title":"build_child_command – fpm-watch","text":"private  function build_child_command(exe0) result(cmd) Build the command line used to spawn the supervised child. The child receives --watch-child and inherits most argv tokens, with\nsupervisor-only flags removed to avoid recursion. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exe0 Return Value character(len=:), allocatable Calls proc~~build_child_command~~CallsGraph proc~build_child_command build_child_command proc~choose_self_exe choose_self_exe proc~build_child_command->proc~choose_self_exe proc~get_arg get_arg proc~build_child_command->proc~get_arg proc~quote_arg quote_arg proc~build_child_command->proc~quote_arg proc~starts_with starts_with proc~build_child_command->proc~starts_with proc~choose_self_exe->proc~get_arg proc~is_windows_os is_windows_os proc~quote_arg->proc~is_windows_os get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_child_command~~CalledByGraph proc~build_child_command build_child_command proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~build_child_command proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function build_child_command ( exe0 ) result ( cmd ) character ( len =* ), intent ( in ) :: exe0 character ( len = :), allocatable :: cmd character ( len = :), allocatable :: exe , a integer :: narg , i logical :: skip_next exe = choose_self_exe ( exe0 ) cmd = quote_arg ( exe ) // \" --watch-child\" narg = command_argument_count () skip_next = . false . do i = 1 , narg a = get_arg ( i ) if ( skip_next ) then skip_next = . false . cycle end if if ( a == \"--watch-auto-restart\" ) cycle if ( a == \"--watch-child\" ) cycle if ( a == \"--watch-restart-delay\" ) then skip_next = . true . cycle end if if ( a == \"--watch-restart-max\" ) then skip_next = . true . cycle end if if ( a == \"--watch-self\" ) then skip_next = . true . cycle end if if ( starts_with ( a , \"--watch-restart-delay=\" )) cycle if ( starts_with ( a , \"--watch-restart-max=\" )) cycle if ( starts_with ( a , \"--watch-self=\" )) cycle cmd = cmd // \" \" // quote_arg ( a ) end do end function build_child_command","tags":"","url":"proc/build_child_command.html"},{"title":"choose_self_exe – fpm-watch","text":"private  function choose_self_exe(exe0) result(exe) Determine the executable to use when spawning the child watcher. Precedence:\n1. Explicit exe0 argument\n2. Environment FPM_WATCH_SELF 3. argv[0] 4. Fallback \"fpm-watch\" Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exe0 Return Value character(len=:), allocatable Calls proc~~choose_self_exe~~CallsGraph proc~choose_self_exe choose_self_exe proc~get_arg get_arg proc~choose_self_exe->proc~get_arg Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~choose_self_exe~~CalledByGraph proc~choose_self_exe choose_self_exe proc~build_child_command build_child_command proc~build_child_command->proc~choose_self_exe proc~supervisor_loop supervisor_loop proc~supervisor_loop->proc~build_child_command proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function choose_self_exe ( exe0 ) result ( exe ) character ( len =* ), intent ( in ) :: exe0 character ( len = :), allocatable :: exe character ( len = 2048 ) :: buf integer :: n , stat character ( len = :), allocatable :: a0 if ( len_trim ( exe0 ) > 0 ) then exe = trim ( exe0 ) return end if buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"FPM_WATCH_SELF\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) then exe = trim ( buf ( 1 : n )) return end if a0 = get_arg ( 0 ) if ( len_trim ( a0 ) > 0 ) then exe = trim ( a0 ) return end if exe = \"fpm-watch\" end function choose_self_exe","tags":"","url":"proc/choose_self_exe.html"},{"title":"maybe_supervise – fpm-watch","text":"public  subroutine maybe_supervise() Enter supervisor mode when requested, otherwise return immediately. If auto-restart is enabled and the current process is not marked as a\nchild ( --watch-child ), this routine runs a supervisor loop and does not\nreturn. Arguments None Calls proc~~maybe_supervise~~CallsGraph proc~maybe_supervise maybe_supervise proc~parse_restart_flags parse_restart_flags proc~maybe_supervise->proc~parse_restart_flags proc~supervisor_loop supervisor_loop proc~maybe_supervise->proc~supervisor_loop proc~get_arg get_arg proc~parse_restart_flags->proc~get_arg proc~get_restart_defaults get_restart_defaults proc~parse_restart_flags->proc~get_restart_defaults proc~parse_int parse_int proc~parse_restart_flags->proc~parse_int proc~parse_real parse_real proc~parse_restart_flags->proc~parse_real proc~set_low_cpu set_low_cpu proc~parse_restart_flags->proc~set_low_cpu proc~starts_with starts_with proc~parse_restart_flags->proc~starts_with proc~build_child_command build_child_command proc~supervisor_loop->proc~build_child_command proc~sleep_seconds sleep_seconds proc~supervisor_loop->proc~sleep_seconds proc~build_child_command->proc~get_arg proc~build_child_command->proc~starts_with proc~choose_self_exe choose_self_exe proc~build_child_command->proc~choose_self_exe proc~quote_arg quote_arg proc~build_child_command->proc~quote_arg proc~load_watch_table load_watch_table proc~get_restart_defaults->proc~load_watch_table proc~toml_get_int toml_get_int proc~get_restart_defaults->proc~toml_get_int proc~toml_get_logical toml_get_logical proc~get_restart_defaults->proc~toml_get_logical proc~toml_get_real toml_get_real proc~get_restart_defaults->proc~toml_get_real proc~toml_get_string toml_get_string proc~get_restart_defaults->proc~toml_get_string proc~sleep_os sleep_os proc~sleep_seconds->proc~sleep_os proc~sleep_spin sleep_spin proc~sleep_seconds->proc~sleep_spin proc~choose_self_exe->proc~get_arg exists exists proc~load_watch_table->exists get_value get_value proc~load_watch_table->get_value read_package_file read_package_file proc~load_watch_table->read_package_file proc~is_windows_os is_windows_os proc~quote_arg->proc~is_windows_os interface~c_nanosleep c_nanosleep proc~sleep_os->interface~c_nanosleep proc~toml_get_int->get_value proc~toml_get_logical->get_value proc~toml_get_real->get_value proc~toml_get_string->get_value get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine maybe_supervise () logical :: auto_restart , is_child real :: restart_delay integer :: restart_max character ( len = :), allocatable :: self_exe call parse_restart_flags ( auto_restart , restart_delay , restart_max , is_child , self_exe ) if ( auto_restart . and . (. not . is_child )) then call supervisor_loop ( max ( 0.0 , restart_delay ), restart_max , self_exe ) stop 0 end if end subroutine maybe_supervise","tags":"","url":"proc/maybe_supervise.html"},{"title":"parse_restart_flags – fpm-watch","text":"private  subroutine parse_restart_flags(auto_restart, restart_delay, restart_max, is_child, self_exe) Parse restart-related flags and apply manifest defaults. This routine also applies --watch-low-cpu to the sleep implementation\nso supervisor delays do not busy-wait. Arguments Type Intent Optional Attributes Name logical, intent(out) :: auto_restart real, intent(out) :: restart_delay integer, intent(out) :: restart_max logical, intent(out) :: is_child character(len=:), intent(out), allocatable :: self_exe Calls proc~~parse_restart_flags~~CallsGraph proc~parse_restart_flags parse_restart_flags proc~get_arg get_arg proc~parse_restart_flags->proc~get_arg proc~get_restart_defaults get_restart_defaults proc~parse_restart_flags->proc~get_restart_defaults proc~parse_int parse_int proc~parse_restart_flags->proc~parse_int proc~parse_real parse_real proc~parse_restart_flags->proc~parse_real proc~set_low_cpu set_low_cpu proc~parse_restart_flags->proc~set_low_cpu proc~starts_with starts_with proc~parse_restart_flags->proc~starts_with proc~load_watch_table load_watch_table proc~get_restart_defaults->proc~load_watch_table proc~toml_get_int toml_get_int proc~get_restart_defaults->proc~toml_get_int proc~toml_get_logical toml_get_logical proc~get_restart_defaults->proc~toml_get_logical proc~toml_get_real toml_get_real proc~get_restart_defaults->proc~toml_get_real proc~toml_get_string toml_get_string proc~get_restart_defaults->proc~toml_get_string exists exists proc~load_watch_table->exists get_value get_value proc~load_watch_table->get_value read_package_file read_package_file proc~load_watch_table->read_package_file proc~toml_get_int->get_value proc~toml_get_logical->get_value proc~toml_get_real->get_value proc~toml_get_string->get_value Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_restart_flags~~CalledByGraph proc~parse_restart_flags parse_restart_flags proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~parse_restart_flags Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_restart_flags ( auto_restart , restart_delay , restart_max , is_child , self_exe ) logical , intent ( out ) :: auto_restart , is_child real , intent ( out ) :: restart_delay integer , intent ( out ) :: restart_max character ( len = :), allocatable , intent ( out ) :: self_exe integer :: narg , i character ( len = :), allocatable :: a , v call get_restart_defaults ( auto_restart , restart_delay , restart_max , self_exe ) is_child = . false . narg = command_argument_count () i = 1 do while ( i <= narg ) a = get_arg ( i ) if ( a == \"--watch-low-cpu\" ) then call set_low_cpu (. true .) i = i + 1 cycle end if if ( a == \"--watch-no-low-cpu\" ) then call set_low_cpu (. false .) i = i + 1 cycle end if if ( starts_with ( a , \"--watch-low-cpu=\" )) then v = a ( len ( \"--watch-low-cpu=\" ) + 1 :) call set_low_cpu ( parse_bool ( v , . true .)) i = i + 1 cycle end if if ( a == \"--watch-auto-restart\" ) then auto_restart = . true . i = i + 1 cycle end if if ( a == \"--watch-child\" ) then is_child = . true . i = i + 1 cycle end if if ( starts_with ( a , \"--watch-restart-delay=\" )) then v = a ( len ( \"--watch-restart-delay=\" ) + 1 :) restart_delay = parse_real ( v , restart_delay ) i = i + 1 cycle end if if ( starts_with ( a , \"--watch-restart-max=\" )) then v = a ( len ( \"--watch-restart-max=\" ) + 1 :) restart_max = parse_int ( v , restart_max ) i = i + 1 cycle end if if ( starts_with ( a , \"--watch-self=\" )) then self_exe = trim ( a ( len ( \"--watch-self=\" ) + 1 :)) i = i + 1 cycle end if if ( a == \"--watch-restart-delay\" ) then if ( i + 1 <= narg ) then v = get_arg ( i + 1 ) restart_delay = parse_real ( v , restart_delay ) i = i + 2 else i = i + 1 end if cycle end if if ( a == \"--watch-restart-max\" ) then if ( i + 1 <= narg ) then v = get_arg ( i + 1 ) restart_max = parse_int ( v , restart_max ) i = i + 2 else i = i + 1 end if cycle end if if ( a == \"--watch-self\" ) then if ( i + 1 <= narg ) then self_exe = trim ( get_arg ( i + 1 )) i = i + 2 else i = i + 1 end if cycle end if i = i + 1 end do contains pure logical function parse_bool ( s , default ) result ( vb ) character ( len =* ), intent ( in ) :: s logical , intent ( in ) :: default character ( len = :), allocatable :: t t = trim ( adjustl ( lower_ascii ( s ))) select case ( t ) case ( \"1\" , \"true\" , \"on\" , \"yes\" , \"y\" , \"t\" ) vb = . true . case ( \"0\" , \"false\" , \"off\" , \"no\" , \"n\" , \"f\" ) vb = . false . case default vb = default end select end function parse_bool pure function lower_ascii ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = len ( s )) :: r integer :: k , c , da da = iachar ( 'a' ) - iachar ( 'A' ) do k = 1 , len ( s ) c = iachar ( s ( k : k )) if ( c >= iachar ( 'A' ) . and . c <= iachar ( 'Z' )) then r ( k : k ) = achar ( c + da ) else r ( k : k ) = s ( k : k ) end if end do end function lower_ascii end subroutine parse_restart_flags","tags":"","url":"proc/parse_restart_flags.html"},{"title":"supervisor_loop – fpm-watch","text":"private  subroutine supervisor_loop(delay0, max0, exe0) Run the supervisor loop, restarting the child on non-zero exit. The supervisor will:\n- Execute the child command.\n- Exit if the child returns 0 .\n- Otherwise wait delay0 seconds and restart, until max0 is reached. Arguments Type Intent Optional Attributes Name real, intent(in) :: delay0 integer, intent(in) :: max0 character(len=*), intent(in) :: exe0 Calls proc~~supervisor_loop~~CallsGraph proc~supervisor_loop supervisor_loop proc~build_child_command build_child_command proc~supervisor_loop->proc~build_child_command proc~sleep_seconds sleep_seconds proc~supervisor_loop->proc~sleep_seconds proc~choose_self_exe choose_self_exe proc~build_child_command->proc~choose_self_exe proc~get_arg get_arg proc~build_child_command->proc~get_arg proc~quote_arg quote_arg proc~build_child_command->proc~quote_arg proc~starts_with starts_with proc~build_child_command->proc~starts_with proc~sleep_os sleep_os proc~sleep_seconds->proc~sleep_os proc~sleep_spin sleep_spin proc~sleep_seconds->proc~sleep_spin proc~choose_self_exe->proc~get_arg proc~is_windows_os is_windows_os proc~quote_arg->proc~is_windows_os interface~c_nanosleep c_nanosleep proc~sleep_os->interface~c_nanosleep get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~supervisor_loop~~CalledByGraph proc~supervisor_loop supervisor_loop proc~maybe_supervise maybe_supervise proc~maybe_supervise->proc~supervisor_loop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine supervisor_loop ( delay0 , max0 , exe0 ) real , intent ( in ) :: delay0 integer , intent ( in ) :: max0 character ( len =* ), intent ( in ) :: exe0 character ( len = :), allocatable :: child_cmd integer :: code , attempt real :: delay child_cmd = build_child_command ( exe0 ) attempt = 0 delay = max ( 0.0 , delay0 ) do code = 0 call execute_command_line ( child_cmd , exitstat = code ) if ( code == 0 ) exit attempt = attempt + 1 if ( max0 > 0 . and . attempt >= max0 ) then write ( error_unit , '(a)' ) \"fpm-watch: child exited with nonzero status; restart limit reached\" stop code end if write ( error_unit , '(a,i0,a,i0,a,f0.2,a)' ) \"fpm-watch: child crashed/aborted (exit=\" , code , \"), restart #\" , attempt , \" in \" , delay , \"s\" call sleep_seconds ( delay ) end do stop 0 end subroutine supervisor_loop","tags":"","url":"proc/supervisor_loop.html"},{"title":"default_build_dir – fpm-watch","text":"private pure function default_build_dir() result(dir) Return the default build directory used by fpm-watch . Arguments None Return Value character(len=:), allocatable Called by proc~~default_build_dir~~CalledByGraph proc~default_build_dir default_build_dir proc~parse_cli parse_cli proc~parse_cli->proc~default_build_dir proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function default_build_dir () result ( dir ) character ( len = :), allocatable :: dir dir = \"build\" end function default_build_dir","tags":"","url":"proc/default_build_dir.html"},{"title":"is_supported_subcmd – fpm-watch","text":"private pure function is_supported_subcmd(s) result(ok) Return whether a given subcommand token is supported by fpm-watch . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value logical Called by proc~~is_supported_subcmd~~CalledByGraph proc~is_supported_subcmd is_supported_subcmd proc~parse_cli parse_cli proc~parse_cli->proc~is_supported_subcmd proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function is_supported_subcmd ( s ) result ( ok ) character ( len =* ), intent ( in ) :: s ok = ( trim ( s ) == \"build\" ) . or . ( trim ( s ) == \"test\" ) . or . ( trim ( s ) == \"run\" ) end function is_supported_subcmd","tags":"","url":"proc/is_supported_subcmd.html"},{"title":"is_watch_flag – fpm-watch","text":"private pure function is_watch_flag(a) result(ok) Detect whether an argv token is a watcher-specific flag. Watcher flags are of the form --watch-* and are consumed by fpm-watch itself rather than forwarded to fpm . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a Return Value logical Called by proc~~is_watch_flag~~CalledByGraph proc~is_watch_flag is_watch_flag proc~parse_cli parse_cli proc~parse_cli->proc~is_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure logical function is_watch_flag ( a ) result ( ok ) character ( len =* ), intent ( in ) :: a ok = ( len_trim ( a ) >= 8 . and . a ( 1 : 8 ) == \"--watch-\" ) end function is_watch_flag","tags":"","url":"proc/is_watch_flag.html"},{"title":"parse_cli_config – fpm-watch","text":"public  subroutine parse_cli_config(cfg) Uses watch_cmdsplice proc~~parse_cli_config~~UsesGraph proc~parse_cli_config parse_cli_config module~watch_cmdsplice watch_cmdsplice proc~parse_cli_config->module~watch_cmdsplice Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Parse CLI arguments and build the full watcher configuration. Produces a watch_config_t :\n- cfg%w contains watcher options (polling, debounce, flags, etc.)\n- cfg%settings holds the typed fpm settings for the selected subcommand\n- cfg%fpm_cmdline is the effective command string\n- cfg%cmd_prefix and cfg%cmd_rest are helper fields used to inject\n  target names into run / test commands. Arguments Type Intent Optional Attributes Name type( watch_config_t ), intent(out) :: cfg Calls proc~~parse_cli_config~~CallsGraph proc~parse_cli_config parse_cli_config proc~parse_cli parse_cli proc~parse_cli_config->proc~parse_cli proc~split_cmd_after_subcmd split_cmd_after_subcmd proc~parse_cli_config->proc~split_cmd_after_subcmd proc~add_features_csv add_features_csv proc~parse_cli->proc~add_features_csv proc~apply_watch_flag apply_watch_flag proc~parse_cli->proc~apply_watch_flag proc~apply_watch_from_manifest apply_watch_from_manifest proc~parse_cli->proc~apply_watch_from_manifest proc~default_build_dir default_build_dir proc~parse_cli->proc~default_build_dir proc~get_arg get_arg proc~parse_cli->proc~get_arg proc~init_build_settings init_build_settings proc~parse_cli->proc~init_build_settings proc~is_supported_subcmd is_supported_subcmd proc~parse_cli->proc~is_supported_subcmd proc~is_watch_flag is_watch_flag proc~parse_cli->proc~is_watch_flag proc~join_argv join_argv proc~parse_cli->proc~join_argv proc~normalize_watch_opts normalize_watch_opts proc~parse_cli->proc~normalize_watch_opts proc~push_feature push_feature proc~parse_cli->proc~push_feature proc~set_names set_names proc~parse_cli->proc~set_names proc~set_watch_defaults set_watch_defaults proc~parse_cli->proc~set_watch_defaults proc~usage_and_stop usage_and_stop proc~parse_cli->proc~usage_and_stop proc~usage_and_stop_ok usage_and_stop_ok proc~parse_cli->proc~usage_and_stop_ok proc~add_features_csv->proc~push_feature proc~apply_watch_flag->proc~get_arg proc~apply_watch_flag->proc~normalize_watch_opts proc~apply_watch_flag->proc~push_feature proc~apply_watch_flag->proc~usage_and_stop proc~apply_watch_flag->proc~usage_and_stop_ok proc~parse_int parse_int proc~apply_watch_flag->proc~parse_int proc~parse_real parse_real proc~apply_watch_flag->proc~parse_real proc~apply_watch_from_manifest->proc~normalize_watch_opts proc~load_watch_table load_watch_table proc~apply_watch_from_manifest->proc~load_watch_table proc~toml_get_int toml_get_int proc~apply_watch_from_manifest->proc~toml_get_int proc~toml_get_list_strings toml_get_list_strings proc~apply_watch_from_manifest->proc~toml_get_list_strings proc~toml_get_logical toml_get_logical proc~apply_watch_from_manifest->proc~toml_get_logical proc~toml_get_real toml_get_real proc~apply_watch_from_manifest->proc~toml_get_real features features proc~init_build_settings->features proc~join_argv->proc~get_arg proc~needs_quotes needs_quotes proc~join_argv->proc~needs_quotes proc~quote_arg quote_arg proc~join_argv->proc~quote_arg name name proc~set_names->name colorize colorize proc~usage_and_stop->colorize proc~usage_print_only usage_print_only proc~usage_and_stop->proc~usage_print_only proc~usage_and_stop_ok->proc~usage_print_only exists exists proc~load_watch_table->exists get_value get_value proc~load_watch_table->get_value read_package_file read_package_file proc~load_watch_table->read_package_file proc~is_windows_os is_windows_os proc~quote_arg->proc~is_windows_os proc~toml_get_int->get_value get_list get_list proc~toml_get_list_strings->get_list proc~toml_get_logical->get_value proc~toml_get_real->get_value proc~usage_print_only->colorize get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_cli_config ( cfg ) use watch_cmdsplice , only : split_cmd_after_subcmd type ( watch_config_t ), intent ( out ) :: cfg character ( len = :), allocatable :: fpm_cmdline class ( fpm_build_settings ), allocatable :: settings character ( len = :), allocatable :: subcmd call parse_cli ( cfg % w , settings , fpm_cmdline , subcmd ) cfg % fpm_cmdline = fpm_cmdline cfg % subcmd = subcmd call move_alloc ( settings , cfg % settings ) call split_cmd_after_subcmd ( cfg % fpm_cmdline , cfg % cmd_prefix , cfg % cmd_rest ) end subroutine parse_cli_config","tags":"","url":"proc/parse_cli_config.html"},{"title":"add_features_csv – fpm-watch","text":"private  subroutine add_features_csv(features, csv) Parse a comma-separated --features value into the features array. Empty tokens are ignored; whitespace around tokens is stripped. Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: features (:) character(len=*), intent(in) :: csv Calls proc~~add_features_csv~~CallsGraph proc~add_features_csv add_features_csv proc~push_feature push_feature proc~add_features_csv->proc~push_feature Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_features_csv~~CalledByGraph proc~add_features_csv add_features_csv proc~parse_cli parse_cli proc~parse_cli->proc~add_features_csv proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_features_csv ( features , csv ) type ( string_t ), allocatable , intent ( inout ) :: features (:) character ( len =* ), intent ( in ) :: csv integer :: n , p , q character ( len = :), allocatable :: s , tok s = trim ( csv ) if ( len_trim ( s ) == 0 ) return p = 1 n = len_trim ( s ) do if ( p > n ) exit q = index ( s ( p :), \",\" ) if ( q == 0 ) then tok = adjustl ( s ( p : n )) call push_feature ( features , trim ( tok )) exit else tok = adjustl ( s ( p : p + q - 2 )) call push_feature ( features , trim ( tok )) p = p + q end if end do end subroutine add_features_csv","tags":"","url":"proc/add_features_csv.html"},{"title":"apply_watch_flag – fpm-watch","text":"private  subroutine apply_watch_flag(a, i, narg, w) Apply a single --watch-* flag to the watcher options. Supports both --flag=value and --flag value styles for flags that take\na value. This routine is called while scanning the argv prefix before the fpm subcommand token. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a integer, intent(inout) :: i integer, intent(in) :: narg type( watch_opts_t ), intent(inout) :: w Calls proc~~apply_watch_flag~~CallsGraph proc~apply_watch_flag apply_watch_flag proc~get_arg get_arg proc~apply_watch_flag->proc~get_arg proc~normalize_watch_opts normalize_watch_opts proc~apply_watch_flag->proc~normalize_watch_opts proc~parse_int parse_int proc~apply_watch_flag->proc~parse_int proc~parse_real parse_real proc~apply_watch_flag->proc~parse_real proc~push_feature push_feature proc~apply_watch_flag->proc~push_feature proc~usage_and_stop usage_and_stop proc~apply_watch_flag->proc~usage_and_stop proc~usage_and_stop_ok usage_and_stop_ok proc~apply_watch_flag->proc~usage_and_stop_ok colorize colorize proc~usage_and_stop->colorize proc~usage_print_only usage_print_only proc~usage_and_stop->proc~usage_print_only proc~usage_and_stop_ok->proc~usage_print_only proc~usage_print_only->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~apply_watch_flag~~CalledByGraph proc~apply_watch_flag apply_watch_flag proc~parse_cli parse_cli proc~parse_cli->proc~apply_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apply_watch_flag ( a , i , narg , w ) character ( len =* ), intent ( in ) :: a integer , intent ( inout ) :: i integer , intent ( in ) :: narg type ( watch_opts_t ), intent ( inout ) :: w character ( len = :), allocatable :: key , val integer :: eq key = trim ( a ) val = \"\" eq = index ( key , \"=\" ) if ( eq > 0 ) then val = key ( eq + 1 :) key = key ( 1 : eq - 1 ) end if select case ( key ) case ( \"--watch-child\" ) continue case ( \"--watch-auto-restart\" ) continue case ( \"--watch-restart-delay\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 <= narg ) i = i + 1 end if case ( \"--watch-restart-max\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 <= narg ) i = i + 1 end if case ( \"--watch-self\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 <= narg ) i = i + 1 end if case ( \"--watch-deps\" ) if ( len_trim ( val ) > 0 ) then w % watch_deps = parse_bool ( val , . true .) else w % watch_deps = . true . end if case ( \"--watch-no-deps\" ) w % watch_deps = . false . case ( \"--watch-low-cpu\" ) if ( len_trim ( val ) > 0 ) then w % low_cpu = parse_bool ( val , . true .) else w % low_cpu = . true . end if case ( \"--watch-no-low-cpu\" ) w % low_cpu = . false . case ( \"--watch-quiet\" ) w % verbosity = - 1 case ( \"--watch-verbose\" ) if ( len_trim ( val ) > 0 ) then w % verbosity = max ( w % verbosity , parse_int ( val , 1 )) else w % verbosity = max ( w % verbosity , 1 ) end if case ( \"--watch-very-verbose\" ) w % verbosity = max ( w % verbosity , 2 ) case ( \"--watch-debug\" ) w % debug = . true . case ( \"--watch-print-files\" ) w % print_files_once = . true . w % verbosity = max ( w % verbosity , 2 ) case ( \"--watch-silent-fpm\" ) w % silent_fpm = . true . case ( \"--watch-run-on-start\" ) w % run_on_start = . true . case ( \"--watch-no-run-on-start\" ) w % run_on_start = . false . case ( \"--watch-rescan\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-rescan requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if w % rescan = parse_real ( val , w % rescan ) case ( \"--watch-no-rescan\" ) w % rescan = 0.0 case ( \"--watch-ignore\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-ignore requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if call push_feature ( w % ignore , trim ( val )) case ( \"--watch-include\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-include requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if call push_feature ( w % include , trim ( val )) case ( \"--watch-feature\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-feature requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if call push_feature ( w % enabled_features , trim ( val )) case ( \"--watch-poll\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-poll requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if w % poll = parse_real ( val , w % poll ) case ( \"--watch-debounce\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-debounce requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if w % debounce = parse_real ( val , w % debounce ) case ( \"--watch-once\" ) if ( len_trim ( val ) > 0 ) then w % once = parse_bool ( val , . true .) else w % once = . true . end if case ( \"--watch-help\" ) call usage_and_stop_ok () case default call usage_and_stop ( \"unknown watch flag: \" // trim ( a )) end select call normalize_watch_opts ( w ) contains pure logical function parse_bool ( s , default ) result ( v ) character ( len =* ), intent ( in ) :: s logical , intent ( in ) :: default character ( len = :), allocatable :: t t = trim ( adjustl ( lower_ascii ( s ))) select case ( t ) case ( \"1\" , \"true\" , \"on\" , \"yes\" , \"y\" , \"t\" ) v = . true . case ( \"0\" , \"false\" , \"off\" , \"no\" , \"n\" , \"f\" ) v = . false . case default v = default end select end function parse_bool pure function lower_ascii ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = len ( s )) :: r integer :: k , c , da da = iachar ( 'a' ) - iachar ( 'A' ) do k = 1 , len ( s ) c = iachar ( s ( k : k )) if ( c >= iachar ( 'A' ) . and . c <= iachar ( 'Z' )) then r ( k : k ) = achar ( c + da ) else r ( k : k ) = s ( k : k ) end if end do end function lower_ascii end subroutine apply_watch_flag","tags":"","url":"proc/apply_watch_flag.html"},{"title":"init_build_settings – fpm-watch","text":"private  subroutine init_build_settings(settings, build_dir, prune, profile, features, compiler_in, c_compiler_in, cxx_compiler_in, archiver_in, flag_in, cflag_in, cxxflag_in, ldflag_in) Populate settings with parsed values and environment fallbacks. This routine centralizes:\n- build_dir , profile , features ,\n- Fortran/C/C++ toolchain selection ( FC , CC , CXX , AR ),\n- Common compile and link flags ( --flag , --c-flag , --cxx-flag , --link-flag ). Environment variables are consulted only when the corresponding CLI option\nis empty. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(inout) :: settings character(len=*), intent(in) :: build_dir logical, intent(in) :: prune character(len=*), intent(in) :: profile type(string_t), intent(in), allocatable :: features (:) character(len=*), intent(in) :: compiler_in character(len=*), intent(in) :: c_compiler_in character(len=*), intent(in) :: cxx_compiler_in character(len=*), intent(in) :: archiver_in character(len=*), intent(in) :: flag_in character(len=*), intent(in) :: cflag_in character(len=*), intent(in) :: cxxflag_in character(len=*), intent(in) :: ldflag_in Calls proc~~init_build_settings~~CallsGraph proc~init_build_settings init_build_settings features features proc~init_build_settings->features Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_build_settings~~CalledByGraph proc~init_build_settings init_build_settings proc~parse_cli parse_cli proc~parse_cli->proc~init_build_settings proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_build_settings ( settings , build_dir , prune , profile , features , compiler_in , c_compiler_in , cxx_compiler_in , archiver_in , flag_in , cflag_in , cxxflag_in , ldflag_in ) class ( fpm_build_settings ), intent ( inout ) :: settings character ( len =* ), intent ( in ) :: build_dir logical , intent ( in ) :: prune character ( len =* ), intent ( in ) :: profile type ( string_t ), allocatable , intent ( in ) :: features (:) character ( len =* ), intent ( in ) :: compiler_in , c_compiler_in , cxx_compiler_in , archiver_in character ( len =* ), intent ( in ) :: flag_in , cflag_in , cxxflag_in , ldflag_in character ( len = :), allocatable :: v character ( len = 2048 ) :: buf integer :: n , stat settings % verbose = . false . settings % prune = prune if ( len_trim ( build_dir ) > 0 ) then settings % build_dir = trim ( build_dir ) end if if ( len_trim ( profile ) > 0 ) settings % profile = trim ( profile ) if ( allocated ( settings % features )) deallocate ( settings % features ) if ( allocated ( features )) then if ( size ( features ) > 0 ) then allocate ( settings % features ( size ( features ))) settings % features = features end if end if v = trim ( compiler_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"FC\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) == 0 ) v = \"gfortran\" settings % compiler = trim ( v ) v = trim ( c_compiler_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"CC\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) > 0 ) settings % c_compiler = trim ( v ) v = trim ( cxx_compiler_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"CXX\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) > 0 ) settings % cxx_compiler = trim ( v ) v = trim ( archiver_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"AR\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) > 0 ) settings % archiver = trim ( v ) v = trim ( flag_in ) if ( len_trim ( v ) > 0 ) settings % flag = trim ( v ) v = trim ( cflag_in ) if ( len_trim ( v ) > 0 ) settings % cflag = trim ( v ) v = trim ( cxxflag_in ) if ( len_trim ( v ) > 0 ) settings % cxxflag = trim ( v ) v = trim ( ldflag_in ) if ( len_trim ( v ) > 0 ) settings % ldflag = trim ( v ) end subroutine init_build_settings","tags":"","url":"proc/init_build_settings.html"},{"title":"parse_cli – fpm-watch","text":"private  subroutine parse_cli(w, settings, fpm_cmdline, subcmd) Parse the complete CLI and produce watcher options + typed fpm settings. Parsing order:\n1. Initialize watcher options from defaults and fpm.toml .\n2. Consume leading --watch-* options and verbosity flags ( -q , -v ).\n3. Identify the fpm subcommand ( build|test|run ).\n4. Parse selected fpm settings used to build the model (profile, flags,\n   compilers, build-dir, features, and run/test names). All arguments after the subcommand are also preserved in fpm_cmdline . Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(out) :: w class(fpm_build_settings), intent(out), allocatable :: settings character(len=:), intent(out), allocatable :: fpm_cmdline character(len=:), intent(out), allocatable :: subcmd Calls proc~~parse_cli~~CallsGraph proc~parse_cli parse_cli proc~add_features_csv add_features_csv proc~parse_cli->proc~add_features_csv proc~apply_watch_flag apply_watch_flag proc~parse_cli->proc~apply_watch_flag proc~apply_watch_from_manifest apply_watch_from_manifest proc~parse_cli->proc~apply_watch_from_manifest proc~default_build_dir default_build_dir proc~parse_cli->proc~default_build_dir proc~get_arg get_arg proc~parse_cli->proc~get_arg proc~init_build_settings init_build_settings proc~parse_cli->proc~init_build_settings proc~is_supported_subcmd is_supported_subcmd proc~parse_cli->proc~is_supported_subcmd proc~is_watch_flag is_watch_flag proc~parse_cli->proc~is_watch_flag proc~join_argv join_argv proc~parse_cli->proc~join_argv proc~normalize_watch_opts normalize_watch_opts proc~parse_cli->proc~normalize_watch_opts proc~push_feature push_feature proc~parse_cli->proc~push_feature proc~set_names set_names proc~parse_cli->proc~set_names proc~set_watch_defaults set_watch_defaults proc~parse_cli->proc~set_watch_defaults proc~usage_and_stop usage_and_stop proc~parse_cli->proc~usage_and_stop proc~usage_and_stop_ok usage_and_stop_ok proc~parse_cli->proc~usage_and_stop_ok proc~add_features_csv->proc~push_feature proc~apply_watch_flag->proc~get_arg proc~apply_watch_flag->proc~normalize_watch_opts proc~apply_watch_flag->proc~push_feature proc~apply_watch_flag->proc~usage_and_stop proc~apply_watch_flag->proc~usage_and_stop_ok proc~parse_int parse_int proc~apply_watch_flag->proc~parse_int proc~parse_real parse_real proc~apply_watch_flag->proc~parse_real proc~apply_watch_from_manifest->proc~normalize_watch_opts proc~load_watch_table load_watch_table proc~apply_watch_from_manifest->proc~load_watch_table proc~toml_get_int toml_get_int proc~apply_watch_from_manifest->proc~toml_get_int proc~toml_get_list_strings toml_get_list_strings proc~apply_watch_from_manifest->proc~toml_get_list_strings proc~toml_get_logical toml_get_logical proc~apply_watch_from_manifest->proc~toml_get_logical proc~toml_get_real toml_get_real proc~apply_watch_from_manifest->proc~toml_get_real features features proc~init_build_settings->features proc~join_argv->proc~get_arg proc~needs_quotes needs_quotes proc~join_argv->proc~needs_quotes proc~quote_arg quote_arg proc~join_argv->proc~quote_arg name name proc~set_names->name colorize colorize proc~usage_and_stop->colorize proc~usage_print_only usage_print_only proc~usage_and_stop->proc~usage_print_only proc~usage_and_stop_ok->proc~usage_print_only exists exists proc~load_watch_table->exists get_value get_value proc~load_watch_table->get_value read_package_file read_package_file proc~load_watch_table->read_package_file proc~is_windows_os is_windows_os proc~quote_arg->proc~is_windows_os proc~toml_get_int->get_value get_list get_list proc~toml_get_list_strings->get_list proc~toml_get_logical->get_value proc~toml_get_real->get_value proc~usage_print_only->colorize get_os_type get_os_type proc~is_windows_os->get_os_type Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~parse_cli~~CalledByGraph proc~parse_cli parse_cli proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine parse_cli ( w , settings , fpm_cmdline , subcmd ) type ( watch_opts_t ), intent ( out ) :: w class ( fpm_build_settings ), allocatable , intent ( out ) :: settings character ( len = :), allocatable , intent ( out ) :: fpm_cmdline character ( len = :), allocatable , intent ( out ) :: subcmd integer :: narg , i , subcmd_pos character ( len = :), allocatable :: a character ( len = :), allocatable :: profile , build_dir character ( len = :), allocatable :: compiler , c_compiler , cxx_compiler , archiver character ( len = :), allocatable :: flag , cflag , cxxflag , ldflag character ( len = :), allocatable :: runner type ( string_t ), allocatable :: features (:) type ( string_t ), allocatable :: names (:) logical :: prune , example call set_watch_defaults ( w ) call apply_watch_from_manifest ( w ) prune = . true . example = . false . profile = \"\" build_dir = default_build_dir () compiler = \"\" c_compiler = \"\" cxx_compiler = \"\" archiver = \"\" flag = \"\" cflag = \"\" cxxflag = \"\" ldflag = \"\" runner = \"\" allocate ( features ( 0 )) allocate ( names ( 0 )) narg = command_argument_count () if ( narg < 1 ) then call usage_and_stop ( \"missing fpm subcommand (build/test/run)\" ) end if a = get_arg ( 1 ) if ( a == \"--help\" . or . a == \"-h\" ) then call usage_and_stop_ok () end if i = 1 do while ( i <= narg ) a = get_arg ( i ) if ( is_watch_flag ( a )) then call apply_watch_flag ( a , i , narg , w ) i = i + 1 cycle end if if ( a == \"-q\" ) then w % verbosity = - 1 i = i + 1 cycle end if if ( a == \"-v\" ) then w % verbosity = max ( w % verbosity , 1 ) i = i + 1 cycle end if if ( a == \"-vv\" ) then w % verbosity = max ( w % verbosity , 2 ) i = i + 1 cycle end if exit end do if ( i > narg ) call usage_and_stop ( \"missing fpm subcommand (build/test/run)\" ) a = get_arg ( i ) if ( a == \"--help\" . or . a == \"-h\" ) then call usage_and_stop_ok () end if subcmd_pos = i subcmd = get_arg ( subcmd_pos ) if (. not . is_supported_subcmd ( subcmd )) then call usage_and_stop ( \"unsupported subcommand: \" // trim ( subcmd ) // \" (supported: build,test,run)\" ) end if if ( subcmd_pos < narg ) then fpm_cmdline = \"fpm \" // trim ( subcmd ) // \" \" // join_argv ( subcmd_pos + 1 , narg ) else fpm_cmdline = \"fpm \" // trim ( subcmd ) end if i = subcmd_pos + 1 do while ( i <= narg ) a = get_arg ( i ) if ( a == \"--\" ) exit select case ( a ) case ( \"--profile\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--profile requires a value\" ) profile = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--features\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--features requires a value\" ) call add_features_csv ( features , get_arg ( i + 1 )) i = i + 2 cycle case ( \"--build-dir\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--build-dir requires a value\" ) build_dir = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--compiler\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--compiler requires a value\" ) compiler = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--c-compiler\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--c-compiler requires a value\" ) c_compiler = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--cxx-compiler\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--cxx-compiler requires a value\" ) cxx_compiler = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--archiver\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--archiver requires a value\" ) archiver = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--flag requires a value\" ) flag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--c-flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--c-flag requires a value\" ) cflag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--cxx-flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--cxx-flag requires a value\" ) cxxflag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--link-flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--link-flag requires a value\" ) ldflag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--runner\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--runner requires a value\" ) runner = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--prune\" ) prune = . true . i = i + 1 cycle case ( \"--no-prune\" ) prune = . false . i = i + 1 cycle case ( \"--example\" ) example = . true . i = i + 1 cycle case default if ( trim ( subcmd ) == \"run\" . or . trim ( subcmd ) == \"test\" ) then if ( len_trim ( a ) > 0 ) then if ( a ( 1 : 1 ) /= \"-\" ) call push_feature ( names , a ) end if end if i = i + 1 cycle end select end do select case ( trim ( subcmd )) case ( \"build\" ) allocate ( fpm_build_settings :: settings ) call init_build_settings ( settings , build_dir , prune , profile , features , compiler , c_compiler , cxx_compiler , archiver , flag , cflag , cxxflag , ldflag ) case ( \"test\" ) allocate ( fpm_test_settings :: settings ) call init_build_settings ( settings , build_dir , prune , profile , features , compiler , c_compiler , cxx_compiler , archiver , flag , cflag , cxxflag , ldflag ) select type ( s => settings ) type is ( fpm_test_settings ) s % build_tests = . true . if ( len_trim ( runner ) > 0 ) s % runner = trim ( runner ) call set_names ( s , names ) end select case ( \"run\" ) allocate ( fpm_run_settings :: settings ) call init_build_settings ( settings , build_dir , prune , profile , features , compiler , c_compiler , cxx_compiler , archiver , flag , cflag , cxxflag , ldflag ) select type ( s => settings ) type is ( fpm_run_settings ) s % example = example if ( len_trim ( runner ) > 0 ) s % runner = trim ( runner ) call set_names ( s , names ) end select case default call usage_and_stop ( \"unsupported subcommand: \" // trim ( subcmd ) // \" (supported: build,test,run)\" ) end select call normalize_watch_opts ( w ) end subroutine parse_cli","tags":"","url":"proc/parse_cli.html"},{"title":"set_names – fpm-watch","text":"private pure subroutine set_names(s, names) Transfer collected name patterns into a run/test settings object. The names array contains tokens collected from positional arguments in fpm-watch run/test invocations. Only non-empty entries are copied. Arguments Type Intent Optional Attributes Name class(fpm_run_settings), intent(inout) :: s type(string_t), intent(in), allocatable :: names (:) Calls proc~~set_names~~CallsGraph proc~set_names set_names name name proc~set_names->name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_names~~CalledByGraph proc~set_names set_names proc~parse_cli parse_cli proc~parse_cli->proc~set_names proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine set_names ( s , names ) class ( fpm_run_settings ), intent ( inout ) :: s type ( string_t ), allocatable , intent ( in ) :: names (:) integer :: i , k , n if (. not . allocated ( names )) return n = 0 do i = 1 , size ( names ) if ( len_trim ( names ( i )% s ) > 0 ) n = n + 1 end do if ( n == 0 ) return allocate ( s % name ( n )) k = 0 do i = 1 , size ( names ) if ( len_trim ( names ( i )% s ) == 0 ) cycle k = k + 1 s % name ( k ) = trim ( names ( i )% s ) end do end subroutine set_names","tags":"","url":"proc/set_names.html"},{"title":"usage_and_stop – fpm-watch","text":"private  subroutine usage_and_stop(msg) Print a usage message and terminate with a non-zero exit status. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg Calls proc~~usage_and_stop~~CallsGraph proc~usage_and_stop usage_and_stop colorize colorize proc~usage_and_stop->colorize proc~usage_print_only usage_print_only proc~usage_and_stop->proc~usage_print_only proc~usage_print_only->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~usage_and_stop~~CalledByGraph proc~usage_and_stop usage_and_stop proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~usage_and_stop proc~parse_cli parse_cli proc~parse_cli->proc~usage_and_stop proc~parse_cli->proc~apply_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine usage_and_stop ( msg ) character ( len =* ), intent ( in ) :: msg write ( error_unit , '(a)' ) & colorize ( \"fpm-watch: error:\" , color_fg = 'red_intense' , style = 'bold_on' ) // \" \" // trim ( msg ) write ( error_unit , '(a)' ) \"\" call usage_print_only () stop 2 end subroutine usage_and_stop","tags":"","url":"proc/usage_and_stop.html"},{"title":"usage_and_stop_ok – fpm-watch","text":"private  subroutine usage_and_stop_ok() Print a usage message and terminate successfully. Arguments None Calls proc~~usage_and_stop_ok~~CallsGraph proc~usage_and_stop_ok usage_and_stop_ok proc~usage_print_only usage_print_only proc~usage_and_stop_ok->proc~usage_print_only colorize colorize proc~usage_print_only->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~usage_and_stop_ok~~CalledByGraph proc~usage_and_stop_ok usage_and_stop_ok proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~usage_and_stop_ok proc~parse_cli parse_cli proc~parse_cli->proc~usage_and_stop_ok proc~parse_cli->proc~apply_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine usage_and_stop_ok () call usage_print_only () stop 0 end subroutine usage_and_stop_ok","tags":"","url":"proc/usage_and_stop_ok.html"},{"title":"usage_print_only – fpm-watch","text":"private  subroutine usage_print_only() Print the fpm-watch help text. The help includes:\n- Watcher options ( --watch-* ),\n- Project configuration ( [extra.fpm-watch] ),\n- Examples and behavioral notes. Arguments None Calls proc~~usage_print_only~~CallsGraph proc~usage_print_only usage_print_only colorize colorize proc~usage_print_only->colorize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~usage_print_only~~CalledByGraph proc~usage_print_only usage_print_only proc~usage_and_stop usage_and_stop proc~usage_and_stop->proc~usage_print_only proc~usage_and_stop_ok usage_and_stop_ok proc~usage_and_stop_ok->proc~usage_print_only proc~apply_watch_flag apply_watch_flag proc~apply_watch_flag->proc~usage_and_stop proc~apply_watch_flag->proc~usage_and_stop_ok proc~parse_cli parse_cli proc~parse_cli->proc~usage_and_stop proc~parse_cli->proc~usage_and_stop_ok proc~parse_cli->proc~apply_watch_flag proc~parse_cli_config parse_cli_config proc~parse_cli_config->proc~parse_cli Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine usage_print_only () character ( len = :), allocatable :: title title = colorize ( & colorize ( \"fpm-watch — Smart file watcher plugin for fpm projects\" , & color_fg = 'cyan_intense' , style = 'bold_on' ), & style = 'underline_on' ) write ( error_unit , '(a)' ) title write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"USAGE\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch\" ) // \" \" // arg ( \"[watch options]\" ) // \" \" // arg ( \"<build|test|run>\" ) // \" \" // arg ( \"[fpm options]\" ) write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  Everything after \" // arg ( \"<build|test|run>\" ) // \" is passed to \" // cmd ( \"fpm\" ) // \" unchanged.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"WATCH OPTIONS\" ) write ( error_unit , '(a)' ) \"  --watch-help\" write ( error_unit , '(a)' ) \"      Show this help and exit.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-quiet | -q\" write ( error_unit , '(a)' ) \"      Quiet mode (errors only).\" write ( error_unit , '(a)' ) \"  --watch-verbose[=N] | -v\" write ( error_unit , '(a)' ) \"      Increase verbosity. N: 0..2 (default: 1).\" write ( error_unit , '(a)' ) \"  --watch-very-verbose | -vv\" write ( error_unit , '(a)' ) \"      Same as verbosity=2 (prints watch list, more details).\" write ( error_unit , '(a)' ) \"  --watch-debug\" write ( error_unit , '(a)' ) \"      Extra debug logs (watch list rebuilds, counts, keys).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-deps\" write ( error_unit , '(a)' ) \"      Also watch dependency source trees (including deps under build/).\" write ( error_unit , '(a)' ) \"  --watch-no-deps\" write ( error_unit , '(a)' ) \"      Disable dependency watching (default).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-low-cpu\" write ( error_unit , '(a)' ) \"      Use OS sleep instead of busy-waiting (near 0% idle CPU).\" write ( error_unit , '(a)' ) \"  --watch-no-low-cpu\" write ( error_unit , '(a)' ) \"      Disable low CPU mode (default).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-poll <sec>\" write ( error_unit , '(a)' ) \"      Poll interval for file checks. Default: 0.5\" write ( error_unit , '(a)' ) \"  --watch-debounce <sec>\" write ( error_unit , '(a)' ) \"      Wait after first change to coalesce edits. Default: 0.2\" write ( error_unit , '(a)' ) \"  --watch-rescan <sec>\" write ( error_unit , '(a)' ) \"      Rebuild the fpm model periodically (slow on big projects). Default: 0 (off).\" write ( error_unit , '(a)' ) \"  --watch-no-rescan\" write ( error_unit , '(a)' ) \"      Disable periodic rebuild (recommended).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-run-on-start\" write ( error_unit , '(a)' ) \"      Run the command once immediately on startup. Default: on.\" write ( error_unit , '(a)' ) \"  --watch-no-run-on-start\" write ( error_unit , '(a)' ) \"      Only run after a change is detected.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-silent-fpm\" write ( error_unit , '(a)' ) \"      Suppress fpm output; keep only fpm-watch status lines.\" write ( error_unit , '(a)' ) \"  --watch-print-files\" write ( error_unit , '(a)' ) \"      Print the watched file list (limited) at startup.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-ignore <glob>\" write ( error_unit , '(a)' ) \"      Ignore files matching glob (repeatable).\" write ( error_unit , '(a)' ) \"  --watch-include <glob>\" write ( error_unit , '(a)' ) \"      Only watch files matching glob (repeatable). Empty means include all.\" write ( error_unit , '(a)' ) \"  --watch-feature <name>\" write ( error_unit , '(a)' ) \"      Enable optional feature plugin (repeatable).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-auto-restart\" write ( error_unit , '(a)' ) \"      Restart fpm-watch automatically if it crashes.\" write ( error_unit , '(a)' ) \"  --watch-restart-delay <sec>\" write ( error_unit , '(a)' ) \"      Delay before restart. Default: 1.0\" write ( error_unit , '(a)' ) \"  --watch-restart-max <N>\" write ( error_unit , '(a)' ) \"      Maximum restart attempts (0 = unlimited). Default: 0\" write ( error_unit , '(a)' ) \"  --watch-self <path>\" write ( error_unit , '(a)' ) \"      Explicit path to fpm-watch executable (advanced).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-once\" write ( error_unit , '(a)' ) \"      Initialize (and optionally run once) then exit. Good for CI.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"CONFIGURATION (fpm.toml)\" ) write ( error_unit , '(a)' ) \"  \" // arg ( \"[extra.fpm-watch]\" ) // \"  (same names as flags, without the --watch- prefix)\" write ( error_unit , '(a)' ) \"  poll         = 0.5\" write ( error_unit , '(a)' ) \"  debounce     = 0.2\" write ( error_unit , '(a)' ) \"  rescan       = 0.0\" write ( error_unit , '(a)' ) \"  run-on-start = true\" write ( error_unit , '(a)' ) \"  silent-fpm   = false\" write ( error_unit , '(a)' ) \"  print-files  = false\" write ( error_unit , '(a)' ) \"  deps         = false\" write ( error_unit , '(a)' ) \"  low-cpu      = false\" write ( error_unit , '(a)' ) \"  auto-restart = false\" write ( error_unit , '(a)' ) \"  restart-delay= 1.0\" write ( error_unit , '(a)' ) \"  restart-max  = 0\" write ( error_unit , '(a)' ) \"  self         = \"\"\"\"\" write ( error_unit , '(a)' ) \"  debug        = false\" write ( error_unit , '(a)' ) \"  verbosity    = 0\" write ( error_unit , '(a)' ) \"  ignore       = []\" write ( error_unit , '(a)' ) \"  include      = []\" write ( error_unit , '(a)' ) \"  features     = []\" write ( error_unit , '(a)' ) \"  once         = false\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"EXAMPLES\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch build\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch --watch-low-cpu test\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch --watch-deps test\" ) // \" \" // arg ( \"--\" ) // \" \" // arg ( \"--list\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch --watch-auto-restart test\" ) write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"NOTES\" ) write ( error_unit , '(a)' ) \"  fpm-watch ignores \" // arg ( \"build/\" ) // \" to avoid infinite rebuild loops.\" write ( error_unit , '(a)' ) \"  Enable \" // arg ( \"deps\" ) // \" only if you want dependency source changes to trigger runs.\" write ( error_unit , '(a)' ) \"  Enable \" // arg ( \"low-cpu\" ) // \" to avoid busy-waiting and reduce idle CPU usage.\" write ( error_unit , '(a)' ) \"  To quit, press Ctrl+C (or create an empty file named \" // arg ( \".fpm-watch.stop\" ) // \").\" write ( error_unit , '(a)' ) \"\" contains function sec ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r r = colorize ( s , color_fg = 'blue_intense' , style = 'bold_on' ) end function sec function cmd ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r r = colorize ( s , color_fg = 'cyan_intense' , style = 'bold_on' ) end function cmd function arg ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r r = colorize ( s , color_fg = 'yellow_intense' ) end function arg end subroutine usage_print_only","tags":"","url":"proc/usage_print_only.html"},{"title":"watch_cmdline – fpm-watch","text":"Command-line helpers. Provides convenience wrappers around get_command_argument and a small\ncollection of parsing and quoting helpers used throughout fpm-watch . Notes:\n- Argument quoting here is intended for building a safe command string ,\n  not for implementing a complete shell escaping library.\n- Windows vs POSIX quoting behavior is handled via get_os_type() . Uses fpm_environment module~~watch_cmdline~~UsesGraph module~watch_cmdline watch_cmdline fpm_environment fpm_environment module~watch_cmdline->fpm_environment Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_cmdline~~UsedByGraph module~watch_cmdline watch_cmdline module~watch_cli watch_cli module~watch_cli->module~watch_cmdline module~watch_restart watch_restart module~watch_restart->module~watch_cmdline Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function get_arg (i) result(a) Retrieve a command-line argument as an allocatable string. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i 0-based/1-based index passed to get_command_argument . Return Value character(len=:), allocatable public  function is_windows_os () Return whether the current OS should be treated as Windows for quoting. Arguments None Return Value logical public  function join_argv (i1, i2) result(s) Join a range of argv entries into a single command-line string. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: i1 Inclusive range of argv indices to join. integer, intent(in) :: i2 Inclusive range of argv indices to join. Return Value character(len=:), allocatable public pure function needs_quotes (a) result(q) Determine whether an argument requires quoting for safe shell parsing. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a Return Value logical public pure function parse_int (s, default) result(v) Parse an integer with a default fallback on I/O error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer, intent(in) :: default Return Value integer public pure function parse_real (s, default) result(v) Parse a real with a default fallback on I/O error. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s real, intent(in) :: default Return Value real public  function quote_arg (a) result(q) Quote an argument for the host shell, escaping embedded quotes as needed. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a Return Value character(len=:), allocatable public pure function starts_with (s, prefix) result(ok) Check whether a string begins with a given prefix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: prefix Return Value logical","tags":"","url":"module/watch_cmdline.html"},{"title":"watch_feature_api – fpm-watch","text":"Feature plugin API. Defines the base watch_feature_t type, which acts as a lightweight\ncallback interface. Feature implementations can extend this type and\noverride any subset of callbacks. Callback order (typical) init(cfg) once during watcher init on_start() once after init on_watch_list_built(files, roots) after watch list computation (and on rebuild) on_manifest_changed(old_key, new_key) when the manifest requires rebuild on_change_detected(changed) when file changes are detected on_before_run(cmd) just before running the command on_after_run(exitstat, seconds) after command completion Default implementations are no-ops. Dummy references are used where needed\nto avoid compiler warnings about unused dummy arguments. Uses iso_fortran_env fpm_strings watch_types module~~watch_feature_api~~UsesGraph module~watch_feature_api watch_feature_api fpm_strings fpm_strings module~watch_feature_api->fpm_strings iso_fortran_env iso_fortran_env module~watch_feature_api->iso_fortran_env module~watch_types watch_types module~watch_feature_api->module~watch_types module~watch_types->fpm_strings module~watch_types->iso_fortran_env fpm_command_line fpm_command_line module~watch_types->fpm_command_line Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_feature_api~~UsedByGraph module~watch_feature_api watch_feature_api module~watch_feat_stats watch_feat_stats module~watch_feat_stats->module~watch_feature_api module~watch_feature_factory watch_feature_factory module~watch_feature_factory->module~watch_feature_api module~watch_feature_factory->module~watch_feat_stats module~watch_feature_manager watch_feature_manager module~watch_feature_factory->module~watch_feature_manager module~watch_feature_manager->module~watch_feature_api module~watch_engine watch_engine module~watch_engine->module~watch_feature_factory module~watch_engine->module~watch_feature_manager Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: watch_feature_t Base feature type (override callbacks to implement behavior). Type-Bound Procedures procedure, public :: init => feat_init_noop procedure, public :: on_after_run => feat_after_noop procedure, public :: on_before_run => feat_before_noop procedure, public :: on_change_detected => feat_change_noop procedure, public :: on_manifest_changed => feat_manifest_noop procedure, public :: on_start => feat_noop procedure, public :: on_watch_list_built => feat_list_noop Subroutines private  subroutine feat_after_noop (self, exitstat, seconds) No-op callback invoked after executing the command. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds private  subroutine feat_before_noop (self, cmd) No-op callback invoked just before executing the command. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self character(len=:), intent(inout), allocatable :: cmd private  subroutine feat_change_noop (self, changed) No-op callback for detected file changes. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(in), allocatable :: changed (:) private  subroutine feat_init_noop (self, cfg) No-op init callback. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg private  subroutine feat_list_noop (self, files, roots) No-op callback for watch list rebuild completion. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self type(string_t), intent(inout), allocatable :: files (:) type( root_info_t ), intent(inout), allocatable :: roots (:) private  subroutine feat_manifest_noop (self, old_key, new_key) No-op callback for manifest key change. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self integer(kind=int64), intent(in) :: old_key integer(kind=int64), intent(in) :: new_key private  subroutine feat_noop (self) No-op start callback. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(inout) :: self","tags":"","url":"module/watch_feature_api.html"},{"title":"watch_util – fpm-watch","text":"Miscellaneous string utilities. Provides small helpers for formatting and manipulating allocatable strings\nand string arrays. Uses fpm_strings module~~watch_util~~UsesGraph module~watch_util watch_util fpm_strings fpm_strings module~watch_util->fpm_strings Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_util~~UsedByGraph module~watch_util watch_util module~watch_banner watch_banner module~watch_banner->module~watch_util module~watch_engine watch_engine module~watch_engine->module~watch_util module~watch_engine->module~watch_banner module~watch_exec watch_exec module~watch_engine->module~watch_exec module~watch_fpm_graph watch_fpm_graph module~watch_engine->module~watch_fpm_graph module~watch_exec->module~watch_util module~watch_fpm_graph->module~watch_util Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: string_accum_t Simple amortized string accumulator. Read more… Components Type Visibility Attributes Name Initial type(string_t), public, allocatable :: a (:) integer, public :: n = 0 Type-Bound Procedures procedure, public :: push => accum_push procedure, public :: to_array => accum_to_array Functions public pure function ftoa (x) result(s) Format a real number with two decimal places. Arguments Type Intent Optional Attributes Name real, intent(in) :: x Return Value character(len=:), allocatable public pure function join_csv (a, empty) result(s) Join a list of strings into a comma-separated value string. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: a (:) character(len=*), intent(in) :: empty Return Value character(len=:), allocatable public pure function trim_or_default (s, default) result(r) Trim an allocatable string or return a default if empty/unallocated. Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: s character(len=*), intent(in) :: default Return Value character(len=:), allocatable public pure function trim_or_empty (s) result(r) Trim an allocatable string or return an empty string if unallocated. Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: s Return Value character(len=:), allocatable Subroutines public  subroutine sort_unique_strings (a) Sort an array of strings and remove duplicates. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: a (:) private  subroutine accum_push (self, s) Append a string to the accumulator (grows capacity as needed). Arguments Type Intent Optional Attributes Name class( string_accum_t ), intent(inout) :: self character(len=*), intent(in) :: s private  subroutine accum_to_array (self, out) Materialize the accumulator into a right-sized array. Read more… Arguments Type Intent Optional Attributes Name class( string_accum_t ), intent(inout) :: self type(string_t), intent(out), allocatable :: out (:)","tags":"","url":"module/watch_util.html"},{"title":"watch_feature_manager – fpm-watch","text":"Feature plugin manager. Provides storage and fan-out calls to a set of enabled feature plugins. The manager owns a growable array of feature objects. Calls are forwarded\nto each feature in insertion order. Uses watch_feature_api iso_fortran_env fpm_strings watch_types module~~watch_feature_manager~~UsesGraph module~watch_feature_manager watch_feature_manager fpm_strings fpm_strings module~watch_feature_manager->fpm_strings iso_fortran_env iso_fortran_env module~watch_feature_manager->iso_fortran_env module~watch_feature_api watch_feature_api module~watch_feature_manager->module~watch_feature_api module~watch_types watch_types module~watch_feature_manager->module~watch_types module~watch_feature_api->fpm_strings module~watch_feature_api->iso_fortran_env module~watch_feature_api->module~watch_types module~watch_types->fpm_strings module~watch_types->iso_fortran_env fpm_command_line fpm_command_line module~watch_types->fpm_command_line Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_feature_manager~~UsedByGraph module~watch_feature_manager watch_feature_manager module~watch_engine watch_engine module~watch_engine->module~watch_feature_manager module~watch_feature_factory watch_feature_factory module~watch_engine->module~watch_feature_factory module~watch_feature_factory->module~watch_feature_manager Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: feature_manager_t Container for multiple feature instances and their callback fan-out. Components Type Visibility Attributes Name Initial type( feature_box_t ), public, allocatable :: feat (:) Type-Bound Procedures procedure, public :: add => fm_add procedure, public :: init_all procedure, public :: on_after_run_all procedure, public :: on_before_run_all procedure, public :: on_change_detected_all procedure, public :: on_manifest_changed_all procedure, public :: on_start_all procedure, public :: on_watch_list_built_all type, private :: feature_box_t A thin wrapper to store an allocatable polymorphic feature instance. Components Type Visibility Attributes Name Initial class( watch_feature_t ), public, allocatable :: p Subroutines private  subroutine fm_add (self, f) Add a feature instance to the manager, transferring ownership. Read more… Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self class( watch_feature_t ), intent(inout), allocatable :: f private  subroutine init_all (self, cfg) Call init(cfg) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg private  subroutine on_after_run_all (self, exitstat, seconds) Call on_after_run(exitstat, seconds) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds private  subroutine on_before_run_all (self, cmd) Call on_before_run(cmd) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self character(len=:), intent(inout), allocatable :: cmd private  subroutine on_change_detected_all (self, changed) Call on_change_detected(changed) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type(string_t), intent(in), allocatable :: changed (:) private  subroutine on_manifest_changed_all (self, old_key, new_key) Call on_manifest_changed(old_key, new_key) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self integer(kind=int64), intent(in) :: old_key integer(kind=int64), intent(in) :: new_key private  subroutine on_start_all (self) Call on_start() on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self private  subroutine on_watch_list_built_all (self, files, roots) Call on_watch_list_built(files, roots) on all registered features. Arguments Type Intent Optional Attributes Name class( feature_manager_t ), intent(inout) :: self type(string_t), intent(inout), allocatable :: files (:) type( root_info_t ), intent(inout), allocatable :: roots (:)","tags":"","url":"module/watch_feature_manager.html"},{"title":"watch_engine – fpm-watch","text":"Watch loop engine and watcher state. This module contains the watcher_t type, which:\n- Builds and maintains the watch list,\n- Tracks file fingerprints for change detection,\n- Runs fpm commands when changes are detected,\n- Coordinates optional feature plugins. The engine is intentionally \"poll-based\" to remain portable across platforms. Uses watch_banner watch_time fpm_filesystem iso_fortran_env watch_feature_factory fpm_strings watch_fingerprint watch_exec watch_log watch_feature_manager watch_types watch_util watch_fpm_graph module~~watch_engine~~UsesGraph module~watch_engine watch_engine fpm_filesystem fpm_filesystem module~watch_engine->fpm_filesystem fpm_strings fpm_strings module~watch_engine->fpm_strings iso_fortran_env iso_fortran_env module~watch_engine->iso_fortran_env module~watch_banner watch_banner module~watch_engine->module~watch_banner module~watch_exec watch_exec module~watch_engine->module~watch_exec module~watch_feature_factory watch_feature_factory module~watch_engine->module~watch_feature_factory module~watch_feature_manager watch_feature_manager module~watch_engine->module~watch_feature_manager module~watch_fingerprint watch_fingerprint module~watch_engine->module~watch_fingerprint module~watch_fpm_graph watch_fpm_graph module~watch_engine->module~watch_fpm_graph module~watch_log watch_log module~watch_engine->module~watch_log module~watch_time watch_time module~watch_engine->module~watch_time module~watch_types watch_types module~watch_engine->module~watch_types module~watch_util watch_util module~watch_engine->module~watch_util module~watch_banner->fpm_strings module~watch_banner->iso_fortran_env module~watch_banner->module~watch_types module~watch_banner->module~watch_util face face module~watch_banner->face fpm_command_line fpm_command_line module~watch_banner->fpm_command_line module~watch_exec->fpm_filesystem module~watch_exec->fpm_strings module~watch_exec->iso_fortran_env module~watch_exec->module~watch_types module~watch_exec->module~watch_util module~watch_exec->face module~watch_exec->fpm_command_line module~watch_feature_factory->module~watch_feature_manager module~watch_feature_factory->module~watch_log module~watch_feature_factory->module~watch_types module~watch_feat_stats watch_feat_stats module~watch_feature_factory->module~watch_feat_stats module~watch_feature_api watch_feature_api module~watch_feature_factory->module~watch_feature_api module~watch_feature_manager->fpm_strings module~watch_feature_manager->iso_fortran_env module~watch_feature_manager->module~watch_types module~watch_feature_manager->module~watch_feature_api module~watch_fingerprint->fpm_filesystem module~watch_fingerprint->fpm_strings module~watch_fingerprint->iso_fortran_env module~watch_fingerprint->fpm_command_line module~watch_fpm_graph->fpm_filesystem module~watch_fpm_graph->fpm_strings module~watch_fpm_graph->iso_fortran_env module~watch_fpm_graph->module~watch_log module~watch_fpm_graph->module~watch_types module~watch_fpm_graph->module~watch_util fpm fpm module~watch_fpm_graph->fpm module~watch_fpm_graph->fpm_command_line fpm_dependency fpm_dependency module~watch_fpm_graph->fpm_dependency fpm_error fpm_error module~watch_fpm_graph->fpm_error fpm_manifest fpm_manifest module~watch_fpm_graph->fpm_manifest fpm_model fpm_model module~watch_fpm_graph->fpm_model fpm_targets fpm_targets module~watch_fpm_graph->fpm_targets module~watch_filter watch_filter module~watch_fpm_graph->module~watch_filter module~watch_log->iso_fortran_env module~watch_log->module~watch_types module~watch_log->face module~watch_time->iso_fortran_env iso_c_binding iso_c_binding module~watch_time->iso_c_binding module~watch_types->fpm_strings module~watch_types->iso_fortran_env module~watch_types->fpm_command_line module~watch_util->fpm_strings module~watch_feat_stats->module~watch_log module~watch_feat_stats->module~watch_types module~watch_feat_stats->module~watch_feature_api module~watch_feature_api->fpm_strings module~watch_feature_api->iso_fortran_env module~watch_feature_api->module~watch_types module~watch_filter->fpm_filesystem module~watch_filter->fpm_strings module~watch_filter->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: watcher_t Main watcher state and methods. Read more… Components Type Visibility Attributes Name Initial type( watch_config_t ), public :: cfg integer, public, allocatable :: changed_idx (:) integer(kind=int64), public, allocatable :: file_mask (:) type(string_t), public, allocatable :: files (:) type( feature_manager_t ), public :: fm integer(kind=int64), public, allocatable :: fp_now (:) integer(kind=int64), public, allocatable :: fp_prev (:) integer(kind=int64), public :: man_prev = 0_int64 type( root_info_t ), public, allocatable :: roots (:) Type-Bound Procedures procedure, public :: init => watcher_init procedure, public :: run => watcher_run Functions private  function any_manifest_changed (files, changed_idx, changed_count) result(hit) Return whether the changed set contains fpm.toml . Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count Return Value logical Subroutines private  subroutine handle_manifest_change (self) Handle a manifest change ( fpm.toml ) by rebuilding the watch list. Read more… Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self private  subroutine rebuild_watch_list (self, print_header) Recompute the watch list, rebuild fingerprints, and print/log the result. Read more… Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self logical, intent(in) :: print_header private  subroutine run_once (self, cmd0) Run the configured command once without change detection. Read more… Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self character(len=*), intent(in) :: cmd0 private  subroutine watcher_init (self, cfg) Initialize a watcher instance from configuration. Read more… Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg private  subroutine watcher_run (self) Run the main watch loop until termination. Read more… Arguments Type Intent Optional Attributes Name class( watcher_t ), intent(inout) :: self","tags":"","url":"module/watch_engine.html"},{"title":"watch_fpm_graph – fpm-watch","text":"Compute watch lists from the fpm dependency graph. Builds the fpm model and expands targets into a set of source files to\nwatch. Optional dependency watching can include dependency project trees\n(including those located under the build directory). This module is responsible for connecting fpm-watch to the fpm internal\nmodel/target structures. It selects the relevant closure of targets for the\nconfigured command (build/test/run), and produces:\n- files : unique normalized file paths\n- file_mask : bitmasks mapping each file to root targets\n- roots : the root targets corresponding to runnable/testable executables Uses watch_filter fpm_manifest fpm_filesystem iso_fortran_env fpm_model fpm_strings fpm_error watch_log watch_types fpm_dependency fpm_targets fpm fpm_command_line watch_util module~~watch_fpm_graph~~UsesGraph module~watch_fpm_graph watch_fpm_graph fpm fpm module~watch_fpm_graph->fpm fpm_command_line fpm_command_line module~watch_fpm_graph->fpm_command_line fpm_dependency fpm_dependency module~watch_fpm_graph->fpm_dependency fpm_error fpm_error module~watch_fpm_graph->fpm_error fpm_filesystem fpm_filesystem module~watch_fpm_graph->fpm_filesystem fpm_manifest fpm_manifest module~watch_fpm_graph->fpm_manifest fpm_model fpm_model module~watch_fpm_graph->fpm_model fpm_strings fpm_strings module~watch_fpm_graph->fpm_strings fpm_targets fpm_targets module~watch_fpm_graph->fpm_targets iso_fortran_env iso_fortran_env module~watch_fpm_graph->iso_fortran_env module~watch_filter watch_filter module~watch_fpm_graph->module~watch_filter module~watch_log watch_log module~watch_fpm_graph->module~watch_log module~watch_types watch_types module~watch_fpm_graph->module~watch_types module~watch_util watch_util module~watch_fpm_graph->module~watch_util module~watch_filter->fpm_filesystem module~watch_filter->fpm_strings module~watch_filter->iso_fortran_env module~watch_log->iso_fortran_env module~watch_log->module~watch_types face face module~watch_log->face module~watch_types->fpm_command_line module~watch_types->fpm_strings module~watch_types->iso_fortran_env module~watch_util->fpm_strings Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_fpm_graph~~UsedByGraph module~watch_fpm_graph watch_fpm_graph module~watch_engine watch_engine module~watch_engine->module~watch_fpm_graph Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function find_ptr_index (p, all) result(idx) Arguments Type Intent Optional Attributes Name type(build_target_t), intent(in), pointer :: p type(build_target_ptr), intent(in) :: all (:) Return Value integer private pure function is_in_dep_dirs (p, dep_dirs) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: p type(string_t), intent(in), allocatable :: dep_dirs (:) Return Value logical private  function is_run_or_test (settings) Return whether the settings correspond to fpm run or fpm test . Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value logical Subroutines public  subroutine compute_watch_files_from_settings (settings, w, files, file_mask, roots, manifest_key, build_secs, secs_model, secs_targets, secs_watch) Compute watched files and masks from current fpm settings. Read more… Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(inout) :: settings type( watch_opts_t ), intent(in) :: w type(string_t), intent(out), allocatable :: files (:) integer(kind=int64), intent(out), allocatable :: file_mask (:) type( root_info_t ), intent(out), allocatable :: roots (:) integer(kind=int64), intent(out) :: manifest_key real, intent(out) :: build_secs real, intent(out) :: secs_model real, intent(out) :: secs_targets real, intent(out) :: secs_watch private recursive subroutine dfs_mark_bool (node, all, visited) Arguments Type Intent Optional Attributes Name type(build_target_t), intent(in), pointer :: node type(build_target_ptr), intent(in) :: all (:) logical, intent(inout) :: visited (:) private recursive subroutine dfs_mark_mask (node, all, tmask, mask) Arguments Type Intent Optional Attributes Name type(build_target_t), intent(in), pointer :: node type(build_target_ptr), intent(in) :: all (:) integer(kind=int64), intent(inout) :: tmask (:) integer(kind=int64), intent(in) :: mask private  subroutine gather_files_with_mask (targets, visited, target_mask, files, file_mask, build_dir, dep_dirs) Arguments Type Intent Optional Attributes Name type(build_target_ptr), intent(in) :: targets (:) logical, intent(in) :: visited (:) integer(kind=int64), intent(in), optional, allocatable :: target_mask (:) type(string_t), intent(out), allocatable :: files (:) integer(kind=int64), intent(out), allocatable :: file_mask (:) character(len=*), intent(in) :: build_dir type(string_t), intent(in), optional, allocatable :: dep_dirs (:) private  subroutine push_file_with_mask (files, file_mask, path, build_dir, mask, dep_dirs) Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: files (:) integer(kind=int64), intent(inout), allocatable :: file_mask (:) character(len=*), intent(in) :: path character(len=*), intent(in) :: build_dir integer(kind=int64), intent(in) :: mask type(string_t), intent(in), optional, allocatable :: dep_dirs (:) private  subroutine select_names_or_all (targets, scope, names, keep) Arguments Type Intent Optional Attributes Name type(build_target_ptr), intent(in) :: targets (:) integer, intent(in) :: scope character(len=*), intent(in), optional :: names (:) logical, intent(inout) :: keep (:) private  subroutine vec_grow (buf, mbuf, cap) Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: buf (:) integer(kind=int64), intent(inout), allocatable :: mbuf (:) integer, intent(inout) :: cap private  subroutine vec_push_unique (buf, mbuf, n, cap, path, build_dir, mask, dep_dirs) Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: buf (:) integer(kind=int64), intent(inout), allocatable :: mbuf (:) integer, intent(inout) :: n integer, intent(inout) :: cap character(len=*), intent(in) :: path character(len=*), intent(in) :: build_dir integer(kind=int64), intent(in) :: mask type(string_t), intent(in), optional, allocatable :: dep_dirs (:)","tags":"","url":"module/watch_fpm_graph.html"},{"title":"watch_banner – fpm-watch","text":"Console banner and watch-list reporting. This module centralizes user-facing console output that is shown on startup\nand when printing the computed watch list. It is intentionally \"UI-only\":\nit does not compute any watch state, it only presents it. Output is generally suppressed when w%verbosity < 0 (quiet mode). Uses iso_fortran_env fpm_strings face watch_types fpm_command_line watch_util module~~watch_banner~~UsesGraph module~watch_banner watch_banner face face module~watch_banner->face fpm_command_line fpm_command_line module~watch_banner->fpm_command_line fpm_strings fpm_strings module~watch_banner->fpm_strings iso_fortran_env iso_fortran_env module~watch_banner->iso_fortran_env module~watch_types watch_types module~watch_banner->module~watch_types module~watch_util watch_util module~watch_banner->module~watch_util module~watch_types->fpm_command_line module~watch_types->fpm_strings module~watch_types->iso_fortran_env module~watch_util->fpm_strings Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_banner~~UsedByGraph module~watch_banner watch_banner module~watch_engine watch_engine module~watch_engine->module~watch_banner Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function active_features (settings) result(f) Return a comma-separated feature list for banner display. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value character(len=:), allocatable private pure function active_profile (settings) result(p) Return the active build profile for banner display. Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value character(len=:), allocatable private pure function command_mode (settings) result(mode) Derive a human-readable mode label from fpm settings. Read more… Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings Return Value character(len=:), allocatable Subroutines public  subroutine print_banner (full_cmdline, settings, w, files, build_secs, roots_count, secs_model, secs_targets, secs_watch) Print the startup banner and an initialization timing summary. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full_cmdline class(fpm_build_settings), intent(in) :: settings type( watch_opts_t ), intent(in) :: w type(string_t), intent(in), allocatable :: files (:) real, intent(in) :: build_secs integer, intent(in) :: roots_count real, intent(in) :: secs_model real, intent(in) :: secs_targets real, intent(in) :: secs_watch public  subroutine print_file_list (files, w) Print the computed watch list (limited output). Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) type( watch_opts_t ), intent(in) :: w","tags":"","url":"module/watch_banner.html"},{"title":"watch_fingerprint – fpm-watch","text":"Lightweight file fingerprinting for change detection. Uses a size-mixed FNV-1a hash of up to three fixed-size blocks from the file\n(head, mid, tail) to efficiently detect modifications. This fingerprint is intended as a fast heuristic:\n- It is not a cryptographic hash.\n- It trades perfect detection for performance on large trees.\n- Combining size + multiple sample blocks provides good practical coverage. Uses fpm_filesystem iso_fortran_env fpm_command_line fpm_strings module~~watch_fingerprint~~UsesGraph module~watch_fingerprint watch_fingerprint fpm_command_line fpm_command_line module~watch_fingerprint->fpm_command_line fpm_filesystem fpm_filesystem module~watch_fingerprint->fpm_filesystem fpm_strings fpm_strings module~watch_fingerprint->fpm_strings iso_fortran_env iso_fortran_env module~watch_fingerprint->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_fingerprint~~UsedByGraph module~watch_fingerprint watch_fingerprint module~watch_engine watch_engine module~watch_engine->module~watch_fingerprint Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: BLOCK_SIZE = 4096 integer(kind=int64), private, parameter :: FNV_OFFSET = 1469598103934665603_int64 integer(kind=int64), private, parameter :: FNV_PRIME = 1099511628211_int64 character(len=1), private, allocatable, save :: io_buf (:) Functions public  function file_fingerprint (path) result(fp) Compute a fingerprint for a file path. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value integer(kind=int64) public  function manifest_key_from_files (settings, files) result(k) Compute a key representing the current manifest-related configuration. Read more… Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings type(string_t), intent(in), allocatable :: files (:) Return Value integer(kind=int64) Subroutines public  subroutine accept_changes (fp_prev, fp_now, changed_idx, changed_count) Accept the new fingerprints for the subset of changed indices. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: fp_prev (:) integer(kind=int64), intent(in) :: fp_now (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count public  subroutine init_fingerprints (files, fp_prev, fp_now, changed_idx) Initialize fingerprint arrays for a watch list. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer(kind=int64), intent(inout), allocatable :: fp_prev (:) integer(kind=int64), intent(inout), allocatable :: fp_now (:) integer, intent(inout), allocatable :: changed_idx (:) public  subroutine scan_changes (files, fp_prev, fp_now, changed_idx, changed_count) Scan files and return indices of changed entries. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer(kind=int64), intent(in) :: fp_prev (:) integer(kind=int64), intent(inout) :: fp_now (:) integer, intent(inout) :: changed_idx (:) integer, intent(out) :: changed_count private  subroutine fnv1a_mix_i64 (h, x) Mix a single 64-bit value into a 64-bit FNV-1a state. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: h integer(kind=int64), intent(in) :: x private  subroutine fnv1a_mix_str (h, s) Mix a string into a 64-bit FNV-1a state. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: h character(len=*), intent(in) :: s private  subroutine hash_block (u, pos, n, h) Hash a single file block at a specific stream position. Arguments Type Intent Optional Attributes Name integer, intent(in) :: u integer(kind=int64), intent(in) :: pos integer, intent(in) :: n integer(kind=int64), intent(inout) :: h","tags":"","url":"module/watch_fingerprint.html"},{"title":"watch_log – fpm-watch","text":"Lightweight structured logging for console output. Provides a consistent key | message style format with optional color. Logging respects w%verbosity :\n- < 0 : suppress info/warn output\n- debug messages require w%debug = .true. Uses iso_fortran_env face watch_types module~~watch_log~~UsesGraph module~watch_log watch_log face face module~watch_log->face iso_fortran_env iso_fortran_env module~watch_log->iso_fortran_env module~watch_types watch_types module~watch_log->module~watch_types module~watch_types->iso_fortran_env fpm_command_line fpm_command_line module~watch_types->fpm_command_line fpm_strings fpm_strings module~watch_types->fpm_strings Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_log~~UsedByGraph module~watch_log watch_log module~watch_engine watch_engine module~watch_engine->module~watch_log module~watch_feature_factory watch_feature_factory module~watch_engine->module~watch_feature_factory module~watch_fpm_graph watch_fpm_graph module~watch_engine->module~watch_fpm_graph module~watch_feat_stats watch_feat_stats module~watch_feat_stats->module~watch_log module~watch_feature_factory->module~watch_log module~watch_feature_factory->module~watch_feat_stats module~watch_fpm_graph->module~watch_log Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine log_debug (w, msg) Log a debug message (prints only when debug is enabled). Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(in) :: w character(len=*), intent(in) :: msg public  subroutine log_err (msg) Log an error message (always prints). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg public  subroutine log_info (w, msg) Log an informational message. Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(in) :: w character(len=*), intent(in) :: msg public  subroutine log_warn (w, msg) Log a warning message. Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(in) :: w character(len=*), intent(in) :: msg","tags":"","url":"module/watch_log.html"},{"title":"watch_time – fpm-watch","text":"Sleep utilities and low-CPU waiting. fpm-watch is primarily poll-based. To avoid burning CPU while idle, this\nmodule provides:\n- a default spin-wait implementation ( sleep_spin ) for portability, and\n- an OS sleep implementation ( sleep_os ) for near-zero CPU usage. set_low_cpu(.true.) selects OS sleep for sleep_seconds . Uses iso_fortran_env iso_c_binding module~~watch_time~~UsesGraph module~watch_time watch_time iso_c_binding iso_c_binding module~watch_time->iso_c_binding iso_fortran_env iso_fortran_env module~watch_time->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_time~~UsedByGraph module~watch_time watch_time module~watch_engine watch_engine module~watch_engine->module~watch_time module~watch_restart watch_restart module~watch_restart->module~watch_time Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private, save :: low_cpu_mode = .false. Global mode switch that selects OS sleep vs spin sleep. Interfaces interface private  function c_nanosleep(req, rem) bind(C, name=\"nanosleep\") Arguments Type Intent Optional Attributes Name type( timespec ), intent(in) :: req type( timespec ), intent(out) :: rem Return Value integer(kind=c_int) Derived Types type, private, bind(C) :: timespec Components Type Visibility Attributes Name Initial integer(kind=c_long), public :: tv_nsec integer(kind=c_long), public :: tv_sec Subroutines public  subroutine set_low_cpu (flag) Enable or disable low-CPU mode. Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: flag public  subroutine sleep_seconds (s) Sleep for a number of seconds. Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: s private  subroutine sleep_os (s) OS-backed sleep for approximately s seconds. Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: s private  subroutine sleep_spin (s) Busy-wait for approximately s seconds. Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: s","tags":"","url":"module/watch_time.html"},{"title":"watch_cmdsplice – fpm-watch","text":"Helpers for manipulating fpm command lines. Provides utilities to split an fpm <subcmd> ... command into a prefix and\nremainder, and to inject target names into the correct position while\npreserving a -- delimiter for arguments passed to the executed program. These utilities operate on plain strings and assume a space-delimited\ntoken structure. They do not implement general shell parsing. Used by module~~watch_cmdsplice~~UsedByGraph module~watch_cmdsplice watch_cmdsplice proc~build_run_command build_run_command proc~build_run_command->module~watch_cmdsplice proc~parse_cli_config parse_cli_config proc~parse_cli_config->module~watch_cmdsplice Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function inject_names_into_cmd (prefix, rest, names) result(out) Inject target names into a command line while respecting a -- delimiter. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: prefix Prefix up to and including the subcommand. character(len=*), intent(in) :: rest Remaining arguments after the subcommand. character(len=*), intent(in) :: names Space-separated names to inject. Return Value character(len=:), allocatable Subroutines public  subroutine split_cmd_after_subcmd (full, prefix, rest) Split a command line into <fpm subcmd> prefix and remaining arguments. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: full Full command string. character(len=:), intent(out), allocatable :: prefix Prefix up to and including the subcommand token. character(len=:), intent(out), allocatable :: rest Remaining arguments after the subcommand.","tags":"","url":"module/watch_cmdsplice.html"},{"title":"watch_feature_factory – fpm-watch","text":"Feature enablement and factory wiring. Maps feature names (strings) to concrete feature implementations. Feature selection is user-controlled via:\n- --watch-feature <name> flags, and/or\n- features = [\"...\"] in fpm.toml [extra.fpm-watch] . Uses watch_feature_api watch_feature_manager watch_log watch_types watch_feat_stats module~~watch_feature_factory~~UsesGraph module~watch_feature_factory watch_feature_factory module~watch_feat_stats watch_feat_stats module~watch_feature_factory->module~watch_feat_stats module~watch_feature_api watch_feature_api module~watch_feature_factory->module~watch_feature_api module~watch_feature_manager watch_feature_manager module~watch_feature_factory->module~watch_feature_manager module~watch_log watch_log module~watch_feature_factory->module~watch_log module~watch_types watch_types module~watch_feature_factory->module~watch_types module~watch_feat_stats->module~watch_feature_api module~watch_feat_stats->module~watch_log module~watch_feat_stats->module~watch_types module~watch_feature_api->module~watch_types fpm_strings fpm_strings module~watch_feature_api->fpm_strings iso_fortran_env iso_fortran_env module~watch_feature_api->iso_fortran_env module~watch_feature_manager->module~watch_feature_api module~watch_feature_manager->module~watch_types module~watch_feature_manager->fpm_strings module~watch_feature_manager->iso_fortran_env module~watch_log->module~watch_types face face module~watch_log->face module~watch_log->iso_fortran_env fpm_command_line fpm_command_line module~watch_types->fpm_command_line module~watch_types->fpm_strings module~watch_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_feature_factory~~UsedByGraph module~watch_feature_factory watch_feature_factory module~watch_engine watch_engine module~watch_engine->module~watch_feature_factory Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine enable_features (fm, w) Enable features requested in watch options. Read more… Arguments Type Intent Optional Attributes Name type( feature_manager_t ), intent(inout) :: fm type( watch_opts_t ), intent(in) :: w private  subroutine add_stats (fm) Factory helper: add the built-in stats feature. Arguments Type Intent Optional Attributes Name type( feature_manager_t ), intent(inout) :: fm","tags":"","url":"module/watch_feature_factory.html"},{"title":"watch_clock – fpm-watch","text":"Clock utilities for timing measurements. Provides a small wrapper over system_clock that standardizes rate/max\ninitialization and offers helpers for deltas and conversion to seconds. These helpers are intended for lightweight runtime timing, not for strict\nprofiling or performance benchmarking. Uses iso_fortran_env module~~watch_clock~~UsesGraph module~watch_clock watch_clock iso_fortran_env iso_fortran_env module~watch_clock->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function clock_delta (t0, t1, max) result(dt) Compute tick delta between two readings with wraparound handling. Read more… Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: t0 Start tick, end tick, and maximum tick before wrap. integer(kind=int64), intent(in) :: t1 Start tick, end tick, and maximum tick before wrap. integer(kind=int64), intent(in) :: max Start tick, end tick, and maximum tick before wrap. Return Value integer(kind=int64) public pure function ticks_to_seconds (ticks, rate) result(secs) Convert ticks to seconds using a specified tick rate. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: ticks Tick delta and tick rate. integer(kind=int64), intent(in) :: rate Tick delta and tick rate. Return Value real Subroutines public pure subroutine clock_init (rate, max) Initialize system_clock parameters. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out) :: rate Clock tick rate and maximum tick count as reported by system_clock . Read more… integer(kind=int64), intent(out) :: max Clock tick rate and maximum tick count as reported by system_clock . Read more… public  subroutine clock_now (t) Fetch the current clock tick count. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(out) :: t Current tick count from system_clock .","tags":"","url":"module/watch_clock.html"},{"title":"watch_types – fpm-watch","text":"Shared types used throughout fpm-watch . This module defines the configuration records used to pass options and fpm settings into the engine. Uses iso_fortran_env fpm_command_line fpm_strings module~~watch_types~~UsesGraph module~watch_types watch_types fpm_command_line fpm_command_line module~watch_types->fpm_command_line fpm_strings fpm_strings module~watch_types->fpm_strings iso_fortran_env iso_fortran_env module~watch_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_types~~UsedByGraph module~watch_types watch_types module~watch_banner watch_banner module~watch_banner->module~watch_types module~watch_cli watch_cli module~watch_cli->module~watch_types module~watch_config watch_config module~watch_cli->module~watch_config module~watch_config->module~watch_types module~watch_engine watch_engine module~watch_engine->module~watch_types module~watch_engine->module~watch_banner module~watch_exec watch_exec module~watch_engine->module~watch_exec module~watch_feature_factory watch_feature_factory module~watch_engine->module~watch_feature_factory module~watch_feature_manager watch_feature_manager module~watch_engine->module~watch_feature_manager module~watch_fpm_graph watch_fpm_graph module~watch_engine->module~watch_fpm_graph module~watch_log watch_log module~watch_engine->module~watch_log module~watch_exec->module~watch_types module~watch_feat_stats watch_feat_stats module~watch_feat_stats->module~watch_types module~watch_feature_api watch_feature_api module~watch_feat_stats->module~watch_feature_api module~watch_feat_stats->module~watch_log module~watch_feature_api->module~watch_types module~watch_feature_factory->module~watch_types module~watch_feature_factory->module~watch_feat_stats module~watch_feature_factory->module~watch_feature_api module~watch_feature_factory->module~watch_feature_manager module~watch_feature_factory->module~watch_log module~watch_feature_manager->module~watch_types module~watch_feature_manager->module~watch_feature_api module~watch_fpm_graph->module~watch_types module~watch_fpm_graph->module~watch_log module~watch_log->module~watch_types module~watch_restart watch_restart module~watch_restart->module~watch_config Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: root_info_t Root target metadata used for change → target mapping. Read more… Components Type Visibility Attributes Name Initial integer(kind=int64), public :: mask = 0_int64 character(len=:), public, allocatable :: name type, public :: watch_config_t Fully assembled watcher configuration. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: cmd_prefix Cached remainder after the subcommand token (for injection). character(len=:), public, allocatable :: cmd_rest character(len=:), public, allocatable :: fpm_cmdline Selected fpm subcommand ( build , test , or run ). class(fpm_build_settings), public, allocatable :: settings Cached prefix up to and including the subcommand token (for injection). character(len=:), public, allocatable :: subcmd Typed fpm settings corresponding to subcmd . type( watch_opts_t ), public :: w Full command line string to execute (e.g., fpm test -- ... ). type, public :: watch_opts_t Watcher configuration options. Read more… Components Type Visibility Attributes Name Initial real, public :: debounce = 0.2 Optional periodic rescan interval (seconds). 0 disables periodic rescans. logical, public :: debug = .false. Poll interval (seconds) between change scans. type(string_t), public, allocatable :: enabled_features (:) Run once (init + optional run-on-start) and exit (CI-friendly). type(string_t), public, allocatable :: ignore (:) Glob patterns to include; if empty, includes all. type(string_t), public, allocatable :: include (:) Names of optional feature plugins to enable. logical, public :: low_cpu = .false. Glob patterns to ignore. logical, public :: once = .false. real, public :: poll = 0.5 Debounce interval (seconds) used after the first detected change. logical, public :: print_files_once = .false. Suppress fpm output; keep only fpm-watch status lines. real, public :: rescan = 0.0 Run the command once immediately on startup. logical, public :: run_on_start = .true. Print the watched file list once at startup (requires high verbosity). logical, public :: silent_fpm = .false. Also watch dependency project sources (can include paths under build dir). integer, public :: verbosity = 0 Enable extra debug output and internal timing/status messages. logical, public :: watch_deps = .false. Use OS sleep for waiting to minimize idle CPU usage.","tags":"","url":"module/watch_types.html"},{"title":"watch_platform – fpm-watch","text":"Platform-specific helpers. Provides shell wrapping and null-device paths for portable command execution. This module is intentionally minimal and uses fpm_environment:get_os_type for OS detection. Uses fpm_environment module~~watch_platform~~UsesGraph module~watch_platform watch_platform fpm_environment fpm_environment module~watch_platform->fpm_environment Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function is_windows () Return whether the current OS is Windows. Arguments None Return Value logical public  function null_device () result(p) Return the system null device path. Arguments None Return Value character(len=:), allocatable public  function shell_wrap (cmd) result(wrapped) Wrap a command for execution by the platform shell. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd Return Value character(len=:), allocatable","tags":"","url":"module/watch_platform.html"},{"title":"watch_exec – fpm-watch","text":"Command execution and run reporting. Provides the user-facing change summary and the mechanics to construct and\nexecute the effective fpm command. Uses fpm_filesystem iso_fortran_env fpm_strings face watch_types fpm_command_line watch_util module~~watch_exec~~UsesGraph module~watch_exec watch_exec face face module~watch_exec->face fpm_command_line fpm_command_line module~watch_exec->fpm_command_line fpm_filesystem fpm_filesystem module~watch_exec->fpm_filesystem fpm_strings fpm_strings module~watch_exec->fpm_strings iso_fortran_env iso_fortran_env module~watch_exec->iso_fortran_env module~watch_types watch_types module~watch_exec->module~watch_types module~watch_util watch_util module~watch_exec->module~watch_util module~watch_types->fpm_command_line module~watch_types->fpm_strings module~watch_types->iso_fortran_env module~watch_util->fpm_strings Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_exec~~UsedByGraph module~watch_exec watch_exec module~watch_engine watch_engine module~watch_engine->module~watch_exec Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function build_run_command (settings, full_cmdline, cmd_prefix, cmd_rest, roots, file_mask, changed_idx, changed_count) result(cmd) Construct the effective command to run based on changes and target masks. Read more… Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(in) :: settings character(len=*), intent(in) :: full_cmdline character(len=*), intent(in) :: cmd_prefix character(len=*), intent(in) :: cmd_rest type( root_info_t ), intent(in), allocatable :: roots (:) integer(kind=int64), intent(in), allocatable :: file_mask (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count Return Value character(len=:), allocatable Subroutines public  subroutine report_changes (files, changed_idx, changed_count, w) Print a summary of changed files. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(in), allocatable :: files (:) integer, intent(in) :: changed_idx (:) integer, intent(in) :: changed_count type( watch_opts_t ), intent(in) :: w public  subroutine run_command_and_report (cmd, w, exitstat, secs) Execute a command and print pre/post status lines. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: cmd type( watch_opts_t ), intent(in) :: w integer, intent(out) :: exitstat real, intent(out) :: secs","tags":"","url":"module/watch_exec.html"},{"title":"watch_filter – fpm-watch","text":"Watch list filtering and path normalization. Contains helpers to normalize paths and apply include/ignore globs to the\ncomputed set of watched files. Key behaviors:\n- Paths are normalized to use / separators.\n- Leading ./ segments are removed for consistent matching.\n- Build directory filtering is handled elsewhere (but helper exists here). Uses fpm_filesystem iso_fortran_env fpm_strings module~~watch_filter~~UsesGraph module~watch_filter watch_filter fpm_filesystem fpm_filesystem module~watch_filter->fpm_filesystem fpm_strings fpm_strings module~watch_filter->fpm_strings iso_fortran_env iso_fortran_env module~watch_filter->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_filter~~UsedByGraph module~watch_filter watch_filter module~watch_fpm_graph watch_fpm_graph module~watch_fpm_graph->module~watch_filter module~watch_engine watch_engine module~watch_engine->module~watch_fpm_graph Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function is_ignored_path (path, build_dir) result(ignored) Identify paths that should be ignored due to being inside the build directory. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path character(len=*), intent(in) :: build_dir Return Value logical public pure function normalize_path (path) result(p) Normalize a path to a consistent form for matching. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value character(len=:), allocatable public pure function starts_with (s, prefix) result(ok) Check whether a string begins with a given prefix. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: prefix Return Value logical private pure function contains_path_fragment (p, frag) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: p character(len=*), intent(in) :: frag Return Value logical private pure function ends_with (s, suffix) result(ok) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s character(len=*), intent(in) :: suffix Return Value logical Subroutines public  subroutine filter_watch_files (files, include, ignore, masks) Apply include/ignore rules to the watch list. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: files (:) type(string_t), intent(in), allocatable :: include (:) type(string_t), intent(in), allocatable :: ignore (:) integer(kind=int64), intent(inout), optional, allocatable :: masks (:)","tags":"","url":"module/watch_filter.html"},{"title":"watch_config – fpm-watch","text":"Project configuration and defaults. Reads watcher configuration from:\n- Built-in defaults ( set_watch_defaults )\n- fpm.toml under [extra.fpm-watch] ( apply_watch_from_manifest ) Also provides helper routines used by the supervisor ( watch_restart ) for\nauto-restart defaults (delay, max restarts, self path). Uses fpm_filesystem fpm_strings fpm_error tomlf fpm_toml watch_types module~~watch_config~~UsesGraph module~watch_config watch_config fpm_error fpm_error module~watch_config->fpm_error fpm_filesystem fpm_filesystem module~watch_config->fpm_filesystem fpm_strings fpm_strings module~watch_config->fpm_strings fpm_toml fpm_toml module~watch_config->fpm_toml module~watch_types watch_types module~watch_config->module~watch_types tomlf tomlf module~watch_config->tomlf module~watch_types->fpm_strings fpm_command_line fpm_command_line module~watch_types->fpm_command_line iso_fortran_env iso_fortran_env module~watch_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_config~~UsedByGraph module~watch_config watch_config module~watch_cli watch_cli module~watch_cli->module~watch_config module~watch_restart watch_restart module~watch_restart->module~watch_config Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine apply_watch_from_manifest (w) Apply configuration overrides from fpm.toml [extra.fpm-watch] . Read more… Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(inout) :: w public  subroutine get_restart_defaults (auto_restart, restart_delay, restart_max, self_exe) Read supervisor defaults from the manifest (when present). Read more… Arguments Type Intent Optional Attributes Name logical, intent(out) :: auto_restart real, intent(out) :: restart_delay integer, intent(out) :: restart_max character(len=:), intent(out), allocatable :: self_exe public  subroutine normalize_watch_opts (w) Normalize watcher options and clamp to safe bounds. Read more… Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(inout) :: w public  subroutine push_feature (features, name) Append a feature name to a string_t array if not already present. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: features (:) character(len=*), intent(in) :: name public  subroutine set_watch_defaults (w) Apply built-in defaults to watcher options. Read more… Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(inout) :: w private  subroutine load_watch_table (root, wt, ok) Locate and return the [extra.fpm-watch] table from fpm.toml . Read more… Arguments Type Intent Optional Attributes Name type(toml_table), intent(out), allocatable :: root type(toml_table), intent(out), pointer :: wt logical, intent(out) :: ok private  subroutine toml_get_int (table, key, v) Read a TOML integer value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key integer, intent(inout) :: v private  subroutine toml_get_list_strings (table, key, list) Read a TOML string list into an allocatable string_t array. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key type(string_t), intent(inout), allocatable :: list (:) private  subroutine toml_get_logical (table, key, v) Read a TOML logical value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key logical, intent(inout) :: v private  subroutine toml_get_real (table, key, v) Read a TOML real value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key real, intent(inout) :: v private  subroutine toml_get_string (table, key, v) Read a TOML string value if present. Arguments Type Intent Optional Attributes Name type(toml_table), intent(inout) :: table character(len=*), intent(in) :: key character(len=:), intent(inout), allocatable :: v","tags":"","url":"module/watch_config.html"},{"title":"watch_feat_stats – fpm-watch","text":"Example \"stats\" feature plugin. This feature demonstrates the plugin system by tracking the number of runs.\nIt currently does not print or export statistics; it simply increments an\ninternal counter after each run. The exitstat and seconds arguments are accepted to conform to the plugin\ninterface. Dummy references are used to prevent unused-argument warnings. Uses watch_feature_api watch_log watch_types module~~watch_feat_stats~~UsesGraph module~watch_feat_stats watch_feat_stats module~watch_feature_api watch_feature_api module~watch_feat_stats->module~watch_feature_api module~watch_log watch_log module~watch_feat_stats->module~watch_log module~watch_types watch_types module~watch_feat_stats->module~watch_types module~watch_feature_api->module~watch_types fpm_strings fpm_strings module~watch_feature_api->fpm_strings iso_fortran_env iso_fortran_env module~watch_feature_api->iso_fortran_env module~watch_log->module~watch_types face face module~watch_log->face module~watch_log->iso_fortran_env fpm_command_line fpm_command_line module~watch_types->fpm_command_line module~watch_types->fpm_strings module~watch_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~watch_feat_stats~~UsedByGraph module~watch_feat_stats watch_feat_stats module~watch_feature_factory watch_feature_factory module~watch_feature_factory->module~watch_feat_stats module~watch_engine watch_engine module~watch_engine->module~watch_feature_factory Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, private, extends( watch_feature_t ) :: stats_feature_t A feature that counts how many command runs have completed. Components Type Visibility Attributes Name Initial integer, public :: runs = 0 Type-Bound Procedures procedure, public :: init => stats_init procedure, public :: on_after_run => stats_after procedure, public :: on_before_run => feat_before_noop procedure, public :: on_change_detected => feat_change_noop procedure, public :: on_manifest_changed => feat_manifest_noop procedure, public :: on_start => feat_noop procedure, public :: on_watch_list_built => feat_list_noop Subroutines public  subroutine new_stats_feature (f) Allocate a new stats feature instance. Arguments Type Intent Optional Attributes Name class( watch_feature_t ), intent(out), allocatable :: f private  subroutine stats_after (self, exitstat, seconds) Update run counter after each completed command execution. Read more… Arguments Type Intent Optional Attributes Name class( stats_feature_t ), intent(inout) :: self integer, intent(in) :: exitstat real, intent(in) :: seconds private  subroutine stats_init (self, cfg) Initialize the stats feature. Read more… Arguments Type Intent Optional Attributes Name class( stats_feature_t ), intent(inout) :: self type( watch_config_t ), intent(in) :: cfg","tags":"","url":"module/watch_feat_stats.html"},{"title":"watch_restart – fpm-watch","text":"Supervisor and auto-restart support. When enabled, fpm-watch can run under a supervisor loop that restarts the\nwatcher on failure (non-zero exit status). Configuration sources:\n- CLI flags:\n  - --watch-auto-restart - --watch-restart-delay <sec> - --watch-restart-max <n> - --watch-self <path> - fpm.toml [extra.fpm-watch] keys:\n  - auto-restart , restart-delay , restart-max , self / self-exe Low CPU mode is also applied here so the supervisor delay sleeps are idle. Uses watch_config iso_fortran_env watch_time watch_cmdline module~~watch_restart~~UsesGraph module~watch_restart watch_restart iso_fortran_env iso_fortran_env module~watch_restart->iso_fortran_env module~watch_cmdline watch_cmdline module~watch_restart->module~watch_cmdline module~watch_config watch_config module~watch_restart->module~watch_config module~watch_time watch_time module~watch_restart->module~watch_time fpm_environment fpm_environment module~watch_cmdline->fpm_environment fpm_error fpm_error module~watch_config->fpm_error fpm_filesystem fpm_filesystem module~watch_config->fpm_filesystem fpm_strings fpm_strings module~watch_config->fpm_strings fpm_toml fpm_toml module~watch_config->fpm_toml module~watch_types watch_types module~watch_config->module~watch_types tomlf tomlf module~watch_config->tomlf module~watch_time->iso_fortran_env iso_c_binding iso_c_binding module~watch_time->iso_c_binding module~watch_types->iso_fortran_env module~watch_types->fpm_strings fpm_command_line fpm_command_line module~watch_types->fpm_command_line Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function build_child_command (exe0) result(cmd) Build the command line used to spawn the supervised child. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exe0 Return Value character(len=:), allocatable private  function choose_self_exe (exe0) result(exe) Determine the executable to use when spawning the child watcher. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: exe0 Return Value character(len=:), allocatable Subroutines public  subroutine maybe_supervise () Enter supervisor mode when requested, otherwise return immediately. Read more… Arguments None private  subroutine parse_restart_flags (auto_restart, restart_delay, restart_max, is_child, self_exe) Parse restart-related flags and apply manifest defaults. Read more… Arguments Type Intent Optional Attributes Name logical, intent(out) :: auto_restart real, intent(out) :: restart_delay integer, intent(out) :: restart_max logical, intent(out) :: is_child character(len=:), intent(out), allocatable :: self_exe private  subroutine supervisor_loop (delay0, max0, exe0) Run the supervisor loop, restarting the child on non-zero exit. Read more… Arguments Type Intent Optional Attributes Name real, intent(in) :: delay0 integer, intent(in) :: max0 character(len=*), intent(in) :: exe0","tags":"","url":"module/watch_restart.html"},{"title":"watch_cli – fpm-watch","text":"Command-line parsing and configuration assembly. This module:\n- Applies built-in defaults ( set_watch_defaults ),\n- Applies project-level overrides from fpm.toml ( apply_watch_from_manifest ),\n- Parses --watch-* options and fpm subcommand arguments,\n- Produces a watch_config_t that drives the watcher engine. Parsing is deliberately simple and \"argv-token based\": it does not implement\na full shell parser. The fpm_cmdline string is built for display and for\nexecution via execute_command_line / fpm_filesystem:run . Uses iso_fortran_env fpm_strings face watch_config watch_types watch_cmdline fpm_command_line module~~watch_cli~~UsesGraph module~watch_cli watch_cli face face module~watch_cli->face fpm_command_line fpm_command_line module~watch_cli->fpm_command_line fpm_strings fpm_strings module~watch_cli->fpm_strings iso_fortran_env iso_fortran_env module~watch_cli->iso_fortran_env module~watch_cmdline watch_cmdline module~watch_cli->module~watch_cmdline module~watch_config watch_config module~watch_cli->module~watch_config module~watch_types watch_types module~watch_cli->module~watch_types fpm_environment fpm_environment module~watch_cmdline->fpm_environment module~watch_config->fpm_strings module~watch_config->module~watch_types fpm_error fpm_error module~watch_config->fpm_error fpm_filesystem fpm_filesystem module~watch_config->fpm_filesystem fpm_toml fpm_toml module~watch_config->fpm_toml tomlf tomlf module~watch_config->tomlf module~watch_types->fpm_command_line module~watch_types->fpm_strings module~watch_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function default_build_dir () result(dir) Return the default build directory used by fpm-watch . Arguments None Return Value character(len=:), allocatable private pure function is_supported_subcmd (s) result(ok) Return whether a given subcommand token is supported by fpm-watch . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s Return Value logical private pure function is_watch_flag (a) result(ok) Detect whether an argv token is a watcher-specific flag. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a Return Value logical Subroutines public  subroutine parse_cli_config (cfg) Parse CLI arguments and build the full watcher configuration. Read more… Arguments Type Intent Optional Attributes Name type( watch_config_t ), intent(out) :: cfg private  subroutine add_features_csv (features, csv) Parse a comma-separated --features value into the features array. Read more… Arguments Type Intent Optional Attributes Name type(string_t), intent(inout), allocatable :: features (:) character(len=*), intent(in) :: csv private  subroutine apply_watch_flag (a, i, narg, w) Apply a single --watch-* flag to the watcher options. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: a integer, intent(inout) :: i integer, intent(in) :: narg type( watch_opts_t ), intent(inout) :: w private  subroutine init_build_settings (settings, build_dir, prune, profile, features, compiler_in, c_compiler_in, cxx_compiler_in, archiver_in, flag_in, cflag_in, cxxflag_in, ldflag_in) Populate settings with parsed values and environment fallbacks. Read more… Arguments Type Intent Optional Attributes Name class(fpm_build_settings), intent(inout) :: settings character(len=*), intent(in) :: build_dir logical, intent(in) :: prune character(len=*), intent(in) :: profile type(string_t), intent(in), allocatable :: features (:) character(len=*), intent(in) :: compiler_in character(len=*), intent(in) :: c_compiler_in character(len=*), intent(in) :: cxx_compiler_in character(len=*), intent(in) :: archiver_in character(len=*), intent(in) :: flag_in character(len=*), intent(in) :: cflag_in character(len=*), intent(in) :: cxxflag_in character(len=*), intent(in) :: ldflag_in private  subroutine parse_cli (w, settings, fpm_cmdline, subcmd) Parse the complete CLI and produce watcher options + typed fpm settings. Read more… Arguments Type Intent Optional Attributes Name type( watch_opts_t ), intent(out) :: w class(fpm_build_settings), intent(out), allocatable :: settings character(len=:), intent(out), allocatable :: fpm_cmdline character(len=:), intent(out), allocatable :: subcmd private pure subroutine set_names (s, names) Transfer collected name patterns into a run/test settings object. Read more… Arguments Type Intent Optional Attributes Name class(fpm_run_settings), intent(inout) :: s type(string_t), intent(in), allocatable :: names (:) private  subroutine usage_and_stop (msg) Print a usage message and terminate with a non-zero exit status. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: msg private  subroutine usage_and_stop_ok () Print a usage message and terminate successfully. Arguments None private  subroutine usage_print_only () Print the fpm-watch help text. Read more… Arguments None","tags":"","url":"module/watch_cli.html"},{"title":"watch_cmdline.f90 – fpm-watch","text":"Files dependent on this one sourcefile~~watch_cmdline.f90~~AfferentGraph sourcefile~watch_cmdline.f90 watch_cmdline.f90 sourcefile~watch_cli.f90 watch_cli.f90 sourcefile~watch_cli.f90->sourcefile~watch_cmdline.f90 sourcefile~watch_restart.f90 watch_restart.f90 sourcefile~watch_restart.f90->sourcefile~watch_cmdline.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Command-line helpers. !! !! Provides convenience wrappers around `get_command_argument` and a small !! collection of parsing and quoting helpers used throughout `fpm-watch`. !! !! Notes: !! - Argument quoting here is intended for building a safe *command string*, !!   not for implementing a complete shell escaping library. !! - Windows vs POSIX quoting behavior is handled via `get_os_type()`. module watch_cmdline use fpm_environment , only : get_os_type , OS_WINDOWS implicit none private public get_arg , join_argv , parse_int , parse_real , needs_quotes , quote_arg , is_windows_os , starts_with contains !> Retrieve a command-line argument as an allocatable string. function get_arg ( i ) result ( a ) integer , intent ( in ) :: i !! 0-based/1-based index passed to `get_command_argument`. character ( len = :), allocatable :: a integer :: n , istat n = 0 call get_command_argument ( i , length = n , status = istat ) if ( istat /= 0 . or . n <= 0 ) then a = \"\" return end if allocate ( character ( len = n ) :: a ) call get_command_argument ( i , value = a , status = istat ) if ( istat /= 0 ) a = \"\" end function get_arg !> Join a range of argv entries into a single command-line string. !! !! Each token is quoted when needed, using `quote_arg()`; quoting rules are !! platform-dependent (Windows vs POSIX). function join_argv ( i1 , i2 ) result ( s ) integer , intent ( in ) :: i1 , i2 !! Inclusive range of argv indices to join. character ( len = :), allocatable :: s character ( len = :), allocatable :: a integer :: i s = \"\" do i = i1 , i2 a = get_arg ( i ) if ( len_trim ( a ) == 0 ) cycle if ( needs_quotes ( a )) then s = s // quote_arg ( a ) // \" \" else s = s // trim ( a ) // \" \" end if end do s = trim ( s ) end function join_argv !> Check whether a string begins with a given prefix. pure logical function starts_with ( s , prefix ) result ( ok ) character ( len =* ), intent ( in ) :: s , prefix integer :: n n = len_trim ( prefix ) if ( n <= 0 ) then ok = . true . else if ( len_trim ( s ) < n ) then ok = . false . else ok = ( s ( 1 : n ) == prefix ( 1 : n )) end if end function starts_with !> Determine whether an argument requires quoting for safe shell parsing. !! !! A conservative check: any whitespace or quotes trigger quoting. pure logical function needs_quotes ( a ) result ( q ) character ( len =* ), intent ( in ) :: a q = ( index ( a , ' ' ) /= 0 ) . or . ( index ( a , char ( 9 )) /= 0 ) . or . ( index ( a , '\"' ) /= 0 ) . or . ( index ( a , \"'\" ) /= 0 ) end function needs_quotes !> Quote an argument for the host shell, escaping embedded quotes as needed. !! !! - On Windows, `\"` is doubled. !! - On POSIX shells, `'` is escaped using a standard `'` → `'\"'\"'` pattern. function quote_arg ( a ) result ( q ) character ( len =* ), intent ( in ) :: a character ( len = :), allocatable :: q if ( is_windows_os ()) then q = '\"' // escape_quotes_win ( trim ( a )) // '\"' else q = \"'\" // escape_quotes_sh ( trim ( a )) // \"'\" end if contains pure function escape_quotes_win ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: j r = \"\" do j = 1 , len_trim ( s ) if ( s ( j : j ) == '\"' ) then r = r // '\"\"' else r = r // s ( j : j ) end if end do end function escape_quotes_win pure function escape_quotes_sh ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: j r = \"\" do j = 1 , len_trim ( s ) if ( s ( j : j ) == \"'\" ) then r = r // \"'\"\"'\"\"'\" else r = r // s ( j : j ) end if end do end function escape_quotes_sh end function quote_arg !> Return whether the current OS should be treated as Windows for quoting. logical function is_windows_os () is_windows_os = ( get_os_type () == OS_WINDOWS ) end function is_windows_os !> Parse an integer with a default fallback on I/O error. pure integer function parse_int ( s , default ) result ( v ) character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: default integer :: ios read ( s , * , iostat = ios ) v if ( ios /= 0 ) v = default end function parse_int !> Parse a real with a default fallback on I/O error. pure real function parse_real ( s , default ) result ( v ) character ( len =* ), intent ( in ) :: s real , intent ( in ) :: default integer :: ios read ( s , * , iostat = ios ) v if ( ios /= 0 ) v = default end function parse_real end module watch_cmdline","tags":"","url":"sourcefile/watch_cmdline.f90.html"},{"title":"watch_feature_api.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_feature_api.f90~~EfferentGraph sourcefile~watch_feature_api.f90 watch_feature_api.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_feature_api.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_feature_api.f90~~AfferentGraph sourcefile~watch_feature_api.f90 watch_feature_api.f90 sourcefile~watch_feat_stats.f90 watch_feat_stats.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feat_stats.f90 sourcefile~watch_feature_manager.f90 watch_feature_manager.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_manager.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_factory.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_manager.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Feature plugin API. !! !! Defines the base `watch_feature_t` type, which acts as a lightweight !! callback interface. Feature implementations can extend this type and !! override any subset of callbacks. !! !! ### Callback order (typical) !! - `init(cfg)` once during watcher init !! - `on_start()` once after init !! - `on_watch_list_built(files, roots)` after watch list computation (and on rebuild) !! - `on_manifest_changed(old_key, new_key)` when the manifest requires rebuild !! - `on_change_detected(changed)` when file changes are detected !! - `on_before_run(cmd)` just before running the command !! - `on_after_run(exitstat, seconds)` after command completion !! !! Default implementations are no-ops. Dummy references are used where needed !! to avoid compiler warnings about unused dummy arguments. module watch_feature_api use , intrinsic :: iso_fortran_env , only : int64 use watch_types , only : watch_config_t , root_info_t use fpm_strings , only : string_t implicit none private public watch_feature_t !> Base feature type (override callbacks to implement behavior). type watch_feature_t contains procedure :: init => feat_init_noop procedure :: on_start => feat_noop procedure :: on_watch_list_built => feat_list_noop procedure :: on_manifest_changed => feat_manifest_noop procedure :: on_change_detected => feat_change_noop procedure :: on_before_run => feat_before_noop procedure :: on_after_run => feat_after_noop end type watch_feature_t contains !> No-op init callback. subroutine feat_init_noop ( self , cfg ) class ( watch_feature_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg if (. false .) then if ( cfg % w % verbosity < - 1 ) continue end if end subroutine feat_init_noop !> No-op start callback. subroutine feat_noop ( self ) class ( watch_feature_t ), intent ( inout ) :: self end subroutine feat_noop !> No-op callback for watch list rebuild completion. subroutine feat_list_noop ( self , files , roots ) class ( watch_feature_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( inout ) :: files (:) type ( root_info_t ), allocatable , intent ( inout ) :: roots (:) if (. false .) then if ( allocated ( files )) continue if ( allocated ( roots )) continue end if end subroutine feat_list_noop !> No-op callback for manifest key change. subroutine feat_manifest_noop ( self , old_key , new_key ) class ( watch_feature_t ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: old_key , new_key if (. false .) then if ( old_key == new_key ) continue end if end subroutine feat_manifest_noop !> No-op callback for detected file changes. subroutine feat_change_noop ( self , changed ) class ( watch_feature_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( in ) :: changed (:) if (. false .) then if ( allocated ( changed )) continue end if end subroutine feat_change_noop !> No-op callback invoked just before executing the command. subroutine feat_before_noop ( self , cmd ) class ( watch_feature_t ), intent ( inout ) :: self character ( len = :), allocatable , intent ( inout ) :: cmd if (. false .) then if ( allocated ( cmd )) continue end if end subroutine feat_before_noop !> No-op callback invoked after executing the command. subroutine feat_after_noop ( self , exitstat , seconds ) class ( watch_feature_t ), intent ( inout ) :: self integer , intent ( in ) :: exitstat real , intent ( in ) :: seconds if (. false .) then if ( exitstat /= 0 ) continue if ( seconds < 0.0 ) continue end if end subroutine feat_after_noop end module watch_feature_api","tags":"","url":"sourcefile/watch_feature_api.f90.html"},{"title":"watch_util.f90 – fpm-watch","text":"Files dependent on this one sourcefile~~watch_util.f90~~AfferentGraph sourcefile~watch_util.f90 watch_util.f90 sourcefile~watch_banner.f90 watch_banner.f90 sourcefile~watch_banner.f90->sourcefile~watch_util.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_util.f90 sourcefile~watch_engine.f90->sourcefile~watch_banner.f90 sourcefile~watch_exec.f90 watch_exec.f90 sourcefile~watch_engine.f90->sourcefile~watch_exec.f90 sourcefile~watch_fpm_graph.f90 watch_fpm_graph.f90 sourcefile~watch_engine.f90->sourcefile~watch_fpm_graph.f90 sourcefile~watch_exec.f90->sourcefile~watch_util.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Miscellaneous string utilities. !! !! Provides small helpers for formatting and manipulating allocatable strings !! and string arrays. module watch_util use fpm_strings , only : string_t implicit none private public ftoa , trim_or_default , trim_or_empty , join_csv , string_accum_t , sort_unique_strings !> Simple amortized string accumulator. !! !! Used to build arrays of strings efficiently without repeated reallocation. type string_accum_t type ( string_t ), allocatable :: a (:) integer :: n = 0 contains procedure :: push => accum_push procedure :: to_array => accum_to_array end type string_accum_t contains !> Format a real number with two decimal places. pure function ftoa ( x ) result ( s ) real , intent ( in ) :: x character ( len = :), allocatable :: s character ( len = 64 ) :: buf write ( buf , '(f0.2)' ) x s = trim ( buf ) end function ftoa !> Trim an allocatable string or return a default if empty/unallocated. pure function trim_or_default ( s , default ) result ( r ) character ( len = :), allocatable , intent ( in ) :: s character ( len =* ), intent ( in ) :: default character ( len = :), allocatable :: r if ( allocated ( s )) then if ( len_trim ( s ) > 0 ) then r = trim ( s ) else r = default end if else r = default end if end function trim_or_default !> Trim an allocatable string or return an empty string if unallocated. pure function trim_or_empty ( s ) result ( r ) character ( len = :), allocatable , intent ( in ) :: s character ( len = :), allocatable :: r if ( allocated ( s )) then r = trim ( s ) else r = \"\" end if end function trim_or_empty !> Join a list of strings into a comma-separated value string. !! !! Empty entries are skipped. If all entries are empty (or the array is not !! allocated), returns the provided `empty` placeholder string. pure function join_csv ( a , empty ) result ( s ) type ( string_t ), allocatable , intent ( in ) :: a (:) character ( len =* ), intent ( in ) :: empty character ( len = :), allocatable :: s character ( len = :), allocatable :: tmp integer :: i tmp = \"\" if ( allocated ( a )) then do i = 1 , size ( a ) if ( len_trim ( a ( i )% s ) == 0 ) cycle if ( len ( tmp ) > 0 ) tmp = tmp // \",\" tmp = tmp // trim ( a ( i )% s ) end do end if if ( len ( tmp ) == 0 ) then s = empty else s = tmp end if end function join_csv !> Append a string to the accumulator (grows capacity as needed). subroutine accum_push ( self , s ) class ( string_accum_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: s type ( string_t ), allocatable :: tmp (:) integer :: cap if ( len_trim ( s ) == 0 ) return if (. not . allocated ( self % a )) then allocate ( self % a ( 256 )) self % n = 0 end if cap = size ( self % a ) if ( self % n >= cap ) then allocate ( tmp ( max ( 1 , 2 * cap ))) if ( cap > 0 ) tmp ( 1 : cap ) = self % a ( 1 : cap ) call move_alloc ( tmp , self % a ) end if self % n = self % n + 1 self % a ( self % n )% s = s end subroutine accum_push !> Materialize the accumulator into a right-sized array. !! !! The accumulator storage is released after conversion. subroutine accum_to_array ( self , out ) class ( string_accum_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( out ) :: out (:) if (. not . allocated ( self % a ) . or . self % n <= 0 ) then allocate ( out ( 0 )) return end if allocate ( out ( self % n )) out = self % a ( 1 : self % n ) deallocate ( self % a ) self % n = 0 end subroutine accum_to_array !> Sort an array of strings and remove duplicates. !! !! Sorting is lexicographic on `string_t%s`. subroutine sort_unique_strings ( a ) type ( string_t ), allocatable , intent ( inout ) :: a (:) type ( string_t ), allocatable :: out (:) integer :: i , nuniq if (. not . allocated ( a )) return if ( size ( a ) <= 1 ) return call qsort ( a , 1 , size ( a )) nuniq = 1 do i = 2 , size ( a ) if ( a ( i )% s /= a ( i - 1 )% s ) nuniq = nuniq + 1 end do if ( nuniq == size ( a )) return allocate ( out ( nuniq )) out ( 1 ) = a ( 1 ) nuniq = 1 do i = 2 , size ( a ) if ( a ( i )% s == a ( i - 1 )% s ) cycle nuniq = nuniq + 1 out ( nuniq ) = a ( i ) end do call move_alloc ( out , a ) contains recursive subroutine qsort ( x , lo , hi ) type ( string_t ), intent ( inout ) :: x (:) integer , intent ( in ) :: lo , hi integer :: i , j character ( len = :), allocatable :: p type ( string_t ) :: t if ( lo >= hi ) return i = lo j = hi p = x (( lo + hi ) / 2 )% s do do while ( x ( i )% s < p ) i = i + 1 end do do while ( p < x ( j )% s ) j = j - 1 end do if ( i <= j ) then t = x ( i ) x ( i ) = x ( j ) x ( j ) = t i = i + 1 j = j - 1 end if if ( i > j ) exit end do if ( lo < j ) call qsort ( x , lo , j ) if ( i < hi ) call qsort ( x , i , hi ) end subroutine qsort end subroutine sort_unique_strings end module watch_util","tags":"","url":"sourcefile/watch_util.f90.html"},{"title":"watch_feature_manager.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_feature_manager.f90~~EfferentGraph sourcefile~watch_feature_manager.f90 watch_feature_manager.f90 sourcefile~watch_feature_api.f90 watch_feature_api.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_api.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_feature_manager.f90~~AfferentGraph sourcefile~watch_feature_manager.f90 watch_feature_manager.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_manager.f90 sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_factory.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_manager.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Feature plugin manager. !! !! Provides storage and fan-out calls to a set of enabled feature plugins. !! !! The manager owns a growable array of feature objects. Calls are forwarded !! to each feature in insertion order. module watch_feature_manager use , intrinsic :: iso_fortran_env , only : int64 use watch_feature_api , only : watch_feature_t use watch_types , only : watch_config_t , root_info_t use fpm_strings , only : string_t implicit none private public feature_manager_t !> A thin wrapper to store an allocatable polymorphic feature instance. type feature_box_t class ( watch_feature_t ), allocatable :: p end type feature_box_t !> Container for multiple feature instances and their callback fan-out. type feature_manager_t type ( feature_box_t ), allocatable :: feat (:) contains procedure :: add => fm_add procedure :: init_all procedure :: on_start_all procedure :: on_watch_list_built_all procedure :: on_manifest_changed_all procedure :: on_change_detected_all procedure :: on_before_run_all procedure :: on_after_run_all end type feature_manager_t contains !> Add a feature instance to the manager, transferring ownership. !! !! The `f` argument is moved into internal storage using `move_alloc`. subroutine fm_add ( self , f ) class ( feature_manager_t ), intent ( inout ) :: self class ( watch_feature_t ), allocatable , intent ( inout ) :: f type ( feature_box_t ), allocatable :: tmp (:) integer :: n , i if (. not . allocated ( self % feat )) then allocate ( self % feat ( 1 )) call move_alloc ( f , self % feat ( 1 )% p ) return end if n = size ( self % feat ) allocate ( tmp ( n + 1 )) do i = 1 , n call move_alloc ( self % feat ( i )% p , tmp ( i )% p ) end do call move_alloc ( f , tmp ( n + 1 )% p ) call move_alloc ( tmp , self % feat ) end subroutine fm_add !> Call `init(cfg)` on all registered features. subroutine init_all ( self , cfg ) class ( feature_manager_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % init ( cfg ) end do end subroutine init_all !> Call `on_start()` on all registered features. subroutine on_start_all ( self ) class ( feature_manager_t ), intent ( inout ) :: self integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_start () end do end subroutine on_start_all !> Call `on_watch_list_built(files, roots)` on all registered features. subroutine on_watch_list_built_all ( self , files , roots ) class ( feature_manager_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( inout ) :: files (:) type ( root_info_t ), allocatable , intent ( inout ) :: roots (:) integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_watch_list_built ( files , roots ) end do end subroutine on_watch_list_built_all !> Call `on_manifest_changed(old_key, new_key)` on all registered features. subroutine on_manifest_changed_all ( self , old_key , new_key ) class ( feature_manager_t ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: old_key , new_key integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_manifest_changed ( old_key , new_key ) end do end subroutine on_manifest_changed_all !> Call `on_change_detected(changed)` on all registered features. subroutine on_change_detected_all ( self , changed ) class ( feature_manager_t ), intent ( inout ) :: self type ( string_t ), allocatable , intent ( in ) :: changed (:) integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_change_detected ( changed ) end do end subroutine on_change_detected_all !> Call `on_before_run(cmd)` on all registered features. subroutine on_before_run_all ( self , cmd ) class ( feature_manager_t ), intent ( inout ) :: self character ( len = :), allocatable , intent ( inout ) :: cmd integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_before_run ( cmd ) end do end subroutine on_before_run_all !> Call `on_after_run(exitstat, seconds)` on all registered features. subroutine on_after_run_all ( self , exitstat , seconds ) class ( feature_manager_t ), intent ( inout ) :: self integer , intent ( in ) :: exitstat real , intent ( in ) :: seconds integer :: i if (. not . allocated ( self % feat )) return do i = 1 , size ( self % feat ) if ( allocated ( self % feat ( i )% p )) call self % feat ( i )% p % on_after_run ( exitstat , seconds ) end do end subroutine on_after_run_all end module watch_feature_manager","tags":"","url":"sourcefile/watch_feature_manager.f90.html"},{"title":"watch_engine.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_engine.f90~~EfferentGraph sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_banner.f90 watch_banner.f90 sourcefile~watch_engine.f90->sourcefile~watch_banner.f90 sourcefile~watch_exec.f90 watch_exec.f90 sourcefile~watch_engine.f90->sourcefile~watch_exec.f90 sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_factory.f90 sourcefile~watch_feature_manager.f90 watch_feature_manager.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_manager.f90 sourcefile~watch_fingerprint.f90 watch_fingerprint.f90 sourcefile~watch_engine.f90->sourcefile~watch_fingerprint.f90 sourcefile~watch_fpm_graph.f90 watch_fpm_graph.f90 sourcefile~watch_engine.f90->sourcefile~watch_fpm_graph.f90 sourcefile~watch_log.f90 watch_log.f90 sourcefile~watch_engine.f90->sourcefile~watch_log.f90 sourcefile~watch_time.f90 watch_time.F90 sourcefile~watch_engine.f90->sourcefile~watch_time.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_engine.f90->sourcefile~watch_types.f90 sourcefile~watch_util.f90 watch_util.f90 sourcefile~watch_engine.f90->sourcefile~watch_util.f90 sourcefile~watch_banner.f90->sourcefile~watch_types.f90 sourcefile~watch_banner.f90->sourcefile~watch_util.f90 sourcefile~watch_exec.f90->sourcefile~watch_types.f90 sourcefile~watch_exec.f90->sourcefile~watch_util.f90 sourcefile~watch_cmdsplice.f90 watch_cmdsplice.f90 sourcefile~watch_exec.f90->sourcefile~watch_cmdsplice.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_manager.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_log.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_types.f90 sourcefile~watch_feat_stats.f90 watch_feat_stats.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feat_stats.f90 sourcefile~watch_feature_api.f90 watch_feature_api.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_log.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_types.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_util.f90 sourcefile~watch_filter.f90 watch_filter.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_filter.f90 sourcefile~watch_log.f90->sourcefile~watch_types.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_log.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_types.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feature_api.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Watch loop engine and watcher state. !! !! This module contains the `watcher_t` type, which: !! - Builds and maintains the watch list, !! - Tracks file fingerprints for change detection, !! - Runs `fpm` commands when changes are detected, !! - Coordinates optional feature plugins. !! !! The engine is intentionally \"poll-based\" to remain portable across platforms. module watch_engine use , intrinsic :: iso_fortran_env , only : int64 use watch_types , only : watch_config_t , root_info_t use watch_feature_manager , only : feature_manager_t use watch_feature_factory , only : enable_features use watch_log , only : log_info use watch_fpm_graph , only : compute_watch_files_from_settings use watch_fingerprint , only : init_fingerprints , scan_changes , accept_changes , manifest_key_from_files use watch_time , only : sleep_seconds , set_low_cpu use watch_exec , only : report_changes , build_run_command , run_command_and_report use watch_banner , only : print_banner , print_file_list use watch_util , only : ftoa use fpm_strings , only : string_t , str use fpm_filesystem , only : basename , exists implicit none private public watcher_t !> Main watcher state and methods. !! !! `watcher_t` owns: !! - The effective configuration (`cfg`) !! - Feature plugins (`fm`) !! - Watch list (`files`) plus per-file target masks (`file_mask`) !! - Fingerprinting buffers for change detection (`fp_prev`, `fp_now`) !! - The current manifest key used to detect \"rebuild needed\" events (`man_prev`) type watcher_t type ( watch_config_t ) :: cfg type ( feature_manager_t ) :: fm type ( string_t ), allocatable :: files (:) integer ( int64 ), allocatable :: file_mask (:) type ( root_info_t ), allocatable :: roots (:) integer ( int64 ), allocatable :: fp_prev (:) integer ( int64 ), allocatable :: fp_now (:) integer , allocatable :: changed_idx (:) integer ( int64 ) :: man_prev = 0_int64 contains procedure :: init => watcher_init procedure :: run => watcher_run end type watcher_t contains !> Initialize a watcher instance from configuration. !! !! This routine: !! - Applies low-CPU mode selection to the sleep implementation. !! - Enables requested feature plugins and calls their init/start callbacks. !! - Builds the initial watch list and fingerprints. !! - Optionally performs an initial run (`w%run_on_start`). subroutine watcher_init ( self , cfg ) class ( watcher_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg self % cfg = cfg call set_low_cpu ( self % cfg % w % low_cpu ) call enable_features ( self % fm , self % cfg % w ) call self % fm % init_all ( self % cfg ) call self % fm % on_start_all () call rebuild_watch_list ( self , print_header = . true .) if ( self % cfg % w % run_on_start ) then call run_once ( self , trim ( self % cfg % fpm_cmdline )) end if end subroutine watcher_init !> Run the main watch loop until termination. !! !! Termination conditions: !! - The sentinel file `.fpm-watch.stop` exists, or !! - The process receives an external termination (e.g., Ctrl+C). !! !! Each iteration performs: !! 1. Sleep for `poll` seconds. !! 2. Scan for changes (fingerprints). !! 3. If changes were found, sleep for `debounce` seconds and rescan. !! 4. If `fpm.toml` changed, rebuild watch list. !! 5. Otherwise, run the computed `fpm` command (with target injection !!    for run/test), notify plugins, and accept fingerprints. subroutine watcher_run ( self ) class ( watcher_t ), intent ( inout ) :: self integer :: changed_count type ( string_t ), allocatable :: changed (:) character ( len = :), allocatable :: cmd integer :: exitstat , j , idx real :: secs integer ( int64 ) :: rate , t_last_rescan , t_now real :: dt if ( self % cfg % w % once ) return call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 call system_clock ( t_last_rescan ) do if ( exists ( \".fpm-watch.stop\" )) exit call sleep_seconds ( self % cfg % w % poll ) call scan_changes ( self % files , self % fp_prev , self % fp_now , self % changed_idx , changed_count ) if ( changed_count > 0 ) then call sleep_seconds ( self % cfg % w % debounce ) call scan_changes ( self % files , self % fp_prev , self % fp_now , self % changed_idx , changed_count ) end if if ( changed_count > 0 ) then if ( any_manifest_changed ( self % files , self % changed_idx , changed_count )) then call handle_manifest_change ( self ) cycle end if allocate ( changed ( changed_count )) do j = 1 , changed_count idx = self % changed_idx ( j ) if ( idx >= 1 . and . idx <= size ( self % files )) then changed ( j )% s = self % files ( idx )% s else changed ( j )% s = \"\" end if end do call self % fm % on_change_detected_all ( changed ) call report_changes ( self % files , self % changed_idx , changed_count , self % cfg % w ) cmd = build_run_command ( & settings = self % cfg % settings , & full_cmdline = self % cfg % fpm_cmdline , & cmd_prefix = self % cfg % cmd_prefix , & cmd_rest = self % cfg % cmd_rest , & roots = self % roots , & file_mask = self % file_mask , & changed_idx = self % changed_idx , & changed_count = changed_count ) call self % fm % on_before_run_all ( cmd ) call run_command_and_report ( cmd , self % cfg % w , exitstat , secs ) call self % fm % on_after_run_all ( exitstat , secs ) call accept_changes ( self % fp_prev , self % fp_now , self % changed_idx , changed_count ) deallocate ( changed ) end if if ( self % cfg % w % rescan > 0.0 ) then call system_clock ( t_now ) if ( t_now < t_last_rescan ) then t_last_rescan = t_now else dt = real ( t_now - t_last_rescan ) / real ( rate ) if ( dt >= self % cfg % w % rescan ) then call log_info ( self % cfg % w , \"rescan triggered -> rebuilding watch list\" ) call rebuild_watch_list ( self , print_header = . false .) call system_clock ( t_last_rescan ) end if end if end if end do end subroutine watcher_run !> Handle a manifest change (`fpm.toml`) by rebuilding the watch list. !! !! This also notifies feature plugins via `on_manifest_changed`. subroutine handle_manifest_change ( self ) class ( watcher_t ), intent ( inout ) :: self integer ( int64 ) :: man_now man_now = manifest_key_from_files ( self % cfg % settings , self % files ) if ( man_now /= self % man_prev ) then call self % fm % on_manifest_changed_all ( self % man_prev , man_now ) self % man_prev = man_now end if call log_info ( self % cfg % w , \"manifest changed -> rebuilding watch list\" ) call rebuild_watch_list ( self , print_header = . false .) end subroutine handle_manifest_change !> Return whether the changed set contains `fpm.toml`. !! !! This detection is based on the basename only and therefore triggers if !! any watched file named `fpm.toml` changes (main or dependency manifests). logical function any_manifest_changed ( files , changed_idx , changed_count ) result ( hit ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count integer :: j , idx character ( len = :), allocatable :: b hit = . false . if (. not . allocated ( files )) return do j = 1 , changed_count idx = changed_idx ( j ) if ( idx < 1 . or . idx > size ( files )) cycle b = basename ( files ( idx )% s ) if ( b == \"fpm.toml\" ) then hit = . true . return end if end do end function any_manifest_changed !> Run the configured command once without change detection. !! !! Used for the optional \"run on start\" behavior. subroutine run_once ( self , cmd0 ) class ( watcher_t ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: cmd0 character ( len = :), allocatable :: cmd integer :: exitstat real :: secs cmd = trim ( cmd0 ) call self % fm % on_before_run_all ( cmd ) call run_command_and_report ( cmd , self % cfg % w , exitstat , secs ) call self % fm % on_after_run_all ( exitstat , secs ) end subroutine run_once !> Recompute the watch list, rebuild fingerprints, and print/log the result. !! !! Called: !! - During initialization, !! - When the manifest changes, !! - Periodically when `rescan > 0`. subroutine rebuild_watch_list ( self , print_header ) class ( watcher_t ), intent ( inout ) :: self logical , intent ( in ) :: print_header integer ( int64 ) :: rate , t0 , t1 real :: build_secs_total real :: secs_model , secs_targets , secs_watch integer :: nfiles , nroots real :: dummy_build type ( string_t ), allocatable :: new_files (:) integer ( int64 ), allocatable :: new_mask (:) type ( root_info_t ), allocatable :: new_roots (:) call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 call system_clock ( t0 ) call compute_watch_files_from_settings ( & settings = self % cfg % settings , & w = self % cfg % w , & files = new_files , & file_mask = new_mask , & roots = new_roots , & manifest_key = self % man_prev , & build_secs = dummy_build , & secs_model = secs_model , & secs_targets = secs_targets , & secs_watch = secs_watch ) call move_alloc ( new_files , self % files ) call move_alloc ( new_mask , self % file_mask ) call move_alloc ( new_roots , self % roots ) call self % fm % on_watch_list_built_all ( self % files , self % roots ) self % man_prev = manifest_key_from_files ( self % cfg % settings , self % files ) call init_fingerprints ( self % files , self % fp_prev , self % fp_now , self % changed_idx ) call system_clock ( t1 ) build_secs_total = real ( t1 - t0 ) / real ( rate ) nfiles = 0 if ( allocated ( self % files )) nfiles = size ( self % files ) nroots = 0 if ( allocated ( self % roots )) nroots = size ( self % roots ) if ( self % cfg % w % debug ) then call log_info ( self % cfg % w , \"debug: manifest_key=\" // str ( self % man_prev )) call log_info ( self % cfg % w , \"debug: roots=\" // str ( nroots ) // \" files=\" // str ( nfiles )) end if if ( print_header ) then call print_banner ( & full_cmdline = self % cfg % fpm_cmdline , & settings = self % cfg % settings , & w = self % cfg % w , & files = self % files , & build_secs = build_secs_total , & roots_count = nroots , & secs_model = secs_model , & secs_targets = secs_targets , & secs_watch = secs_watch ) if ( self % cfg % w % print_files_once ) call print_file_list ( self % files , self % cfg % w ) else call log_info ( self % cfg % w , \"watch list updated in \" // ftoa ( build_secs_total ) // \"s; files=\" // str ( nfiles )) if ( self % cfg % w % verbosity >= 2 ) call print_file_list ( self % files , self % cfg % w ) end if end subroutine rebuild_watch_list end module watch_engine","tags":"","url":"sourcefile/watch_engine.f90.html"},{"title":"watch_fpm_graph.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_fpm_graph.f90~~EfferentGraph sourcefile~watch_fpm_graph.f90 watch_fpm_graph.f90 sourcefile~watch_filter.f90 watch_filter.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_filter.f90 sourcefile~watch_log.f90 watch_log.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_log.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_types.f90 sourcefile~watch_util.f90 watch_util.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_util.f90 sourcefile~watch_log.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_fpm_graph.f90~~AfferentGraph sourcefile~watch_fpm_graph.f90 watch_fpm_graph.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_fpm_graph.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Compute watch lists from the `fpm` dependency graph. !! !! Builds the `fpm` model and expands targets into a set of source files to !! watch. Optional dependency watching can include dependency project trees !! (including those located under the build directory). !! !! This module is responsible for connecting `fpm-watch` to the `fpm` internal !! model/target structures. It selects the relevant closure of targets for the !! configured command (build/test/run), and produces: !! - `files`: unique normalized file paths !! - `file_mask`: bitmasks mapping each file to root targets !! - `roots`: the root targets corresponding to runnable/testable executables module watch_fpm_graph use , intrinsic :: iso_fortran_env , only : int64 , error_unit use watch_types , only : watch_opts_t , root_info_t use watch_log , only : log_info use watch_filter , only : normalize_path , is_ignored_path , filter_watch_files , starts_with use watch_util , only : ftoa , trim_or_empty use fpm , only : build_model use fpm_manifest , only : package_config_t , get_package_data use fpm_model , only : fpm_model_t , FPM_SCOPE_APP , FPM_SCOPE_TEST , FPM_SCOPE_EXAMPLE use fpm_targets , only : build_target_ptr , targets_from_sources use fpm_filesystem , only : basename , exists , join_path use fpm_strings , only : string_t , glob , str use fpm_error , only : error_t use fpm_dependency , only : dependency_tree_t , new_dependency_tree use fpm_command_line , only : fpm_build_settings , fpm_run_settings , fpm_test_settings implicit none private public compute_watch_files_from_settings contains !> Compute watched files and masks from current `fpm` settings. !! !! This is the primary \"graph to watchlist\" entry point. !! !! ### Outputs !! - `files`: normalized, unique file paths to watch. !! - `file_mask`: a bitmask per file that encodes which root target(s) the !!   file belongs to (used for name injection on run/test). !! - `roots`: root executable/test targets. `roots(r)%mask` is a 1-bit mask. !! - `manifest_key`: placeholder output (computed elsewhere); set to `0` here. !! - `build_secs`: sum of `secs_model + secs_targets + secs_watch`. !! - `secs_model`: time spent building the `fpm` model. !! - `secs_targets`: time spent expanding sources into targets. !! - `secs_watch`: time spent collecting and filtering file paths. !! !! ### Notes !! - Root bitmasks are limited to `bit_size(0_int64)` (typically 64 roots). !! - Build directory paths are excluded from the watch list unless dependency !!   watching is enabled and the path is identified as belonging to a dep. subroutine compute_watch_files_from_settings ( settings , w , files , file_mask , roots , manifest_key , build_secs , secs_model , secs_targets , secs_watch ) class ( fpm_build_settings ), intent ( inout ) :: settings type ( watch_opts_t ), intent ( in ) :: w type ( string_t ), allocatable , intent ( out ) :: files (:) integer ( int64 ), allocatable , intent ( out ) :: file_mask (:) type ( root_info_t ), allocatable , intent ( out ) :: roots (:) integer ( int64 ), intent ( out ) :: manifest_key real , intent ( out ) :: build_secs real , intent ( out ) :: secs_model , secs_targets , secs_watch type ( package_config_t ), allocatable :: package type ( fpm_model_t ), allocatable :: model type ( build_target_ptr ), allocatable :: targets (:) type ( error_t ), allocatable :: err type ( dependency_tree_t ) :: tree logical , allocatable :: keep (:) logical , allocatable :: visited (:) integer ( int64 ), allocatable :: target_mask (:) type ( string_t ), allocatable :: dep_dirs (:) integer :: i , r , nroots integer ( int64 ) :: rate , t0 , t1 , tw0 , tw1 integer :: n_before , n_after secs_model = 0.0 secs_targets = 0.0 secs_watch = 0.0 build_secs = 0.0 call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 allocate ( package , model ) call get_package_data ( package , \"fpm.toml\" , err , apply_defaults = . true .) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: manifest error: \" // err % message stop 1 end if call new_dependency_tree ( tree , build_dir = trim_or_empty ( settings % build_dir ), path_to_config = trim_or_empty ( settings % path_to_config )) call tree % add ( package , err ) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: dependency error: \" // err % message stop 1 end if if ( w % watch_deps ) then call collect_dep_dirs ( tree , dep_dirs ) if ( w % verbosity >= 1 ) then call log_info ( w , \"deps: watching dependency sources (deps=\" // str ( size ( dep_dirs )) // \")\" ) end if else if ( allocated ( dep_dirs )) deallocate ( dep_dirs ) allocate ( dep_dirs ( 0 )) end if call system_clock ( t0 ) call build_model ( model , settings , package , err ) call system_clock ( t1 ) secs_model = real ( t1 - t0 ) / real ( rate ) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: model error: \" // err % message stop 1 end if call system_clock ( t0 ) call targets_from_sources ( targets , model , settings % prune , package % library , err ) call system_clock ( t1 ) secs_targets = real ( t1 - t0 ) / real ( rate ) if ( allocated ( err )) then write ( error_unit , '(a)' ) \"fpm-watch: targets error: \" // err % message stop 1 end if call system_clock ( tw0 ) allocate ( keep ( size ( targets ))) keep = . false . select type ( s => settings ) type is ( fpm_test_settings ) do i = 1 , size ( targets ) if ( targets ( i )% ptr % is_executable_target ( FPM_SCOPE_TEST )) keep ( i ) = . true . end do type is ( fpm_run_settings ) if ( s % example ) then call select_names_or_all ( targets , FPM_SCOPE_EXAMPLE , s % name , keep ) else call select_names_or_all ( targets , FPM_SCOPE_APP , s % name , keep ) end if class default keep = . true . end select nroots = count ( keep ) allocate ( visited ( size ( targets ))) visited = . false . if ( is_run_or_test ( settings ) . and . nroots > 0 . and . nroots <= bit_size ( 0_int64 )) then allocate ( roots ( nroots )) allocate ( target_mask ( size ( targets ))) target_mask = 0_int64 r = 0 do i = 1 , size ( targets ) if (. not . keep ( i )) cycle r = r + 1 roots ( r )% name = basename ( targets ( i )% ptr % output_file , suffix = . false .) roots ( r )% mask = shiftl ( 1_int64 , r - 1 ) call dfs_mark_mask ( targets ( i )% ptr , targets , target_mask , roots ( r )% mask ) end do visited = ( target_mask /= 0_int64 ) else if ( allocated ( roots )) deallocate ( roots ) allocate ( roots ( 0 )) if ( allocated ( target_mask )) deallocate ( target_mask ) if ( all ( keep )) then visited = . true . else do i = 1 , size ( targets ) if ( keep ( i )) call dfs_mark_bool ( targets ( i )% ptr , targets , visited ) end do end if end if if ( w % watch_deps ) then call gather_files_with_mask ( targets , visited , target_mask , files , file_mask , trim_or_empty ( settings % build_dir ), dep_dirs ) else call gather_files_with_mask ( targets , visited , target_mask , files , file_mask , trim_or_empty ( settings % build_dir )) end if if ( w % watch_deps ) then call push_file_with_mask ( files , file_mask , \"fpm.toml\" , trim_or_empty ( settings % build_dir ), 0_int64 , dep_dirs ) else call push_file_with_mask ( files , file_mask , \"fpm.toml\" , trim_or_empty ( settings % build_dir ), 0_int64 ) end if do i = 1 , tree % ndep if (. not . allocated ( tree % dep ( i )% proj_dir )) cycle if ( len_trim ( tree % dep ( i )% proj_dir ) == 0 ) cycle if ( w % watch_deps ) then call push_file_with_mask ( files , file_mask , join_path ( tree % dep ( i )% proj_dir , \"fpm.toml\" ), trim_or_empty ( settings % build_dir ), 0_int64 , dep_dirs ) else call push_file_with_mask ( files , file_mask , join_path ( tree % dep ( i )% proj_dir , \"fpm.toml\" ), trim_or_empty ( settings % build_dir ), 0_int64 ) end if end do n_before = 0 if ( allocated ( files )) n_before = size ( files ) call filter_watch_files ( files , w % include , w % ignore , file_mask ) n_after = 0 if ( allocated ( files )) n_after = size ( files ) if ( w % debug ) then call log_info ( w , \"debug: watch files filtered: \" // str ( n_before ) // \" -> \" // str ( n_after )) end if call system_clock ( tw1 ) secs_watch = real ( tw1 - tw0 ) / real ( rate ) build_secs = secs_model + secs_targets + secs_watch manifest_key = 0_int64 if ( w % verbosity >= 1 ) then call log_info ( w , \"timings: model=\" // ftoa ( secs_model ) // \"s targets=\" // ftoa ( secs_targets ) // \"s watchlist=\" // ftoa ( secs_watch ) // \"s\" ) call log_info ( w , \"targets: total=\" // str ( size ( targets )) // \" closure=\" // str ( count ( visited ))) end if deallocate ( package , model ) if ( allocated ( targets )) deallocate ( targets ) if ( allocated ( keep )) deallocate ( keep ) if ( allocated ( visited )) deallocate ( visited ) if ( allocated ( target_mask )) deallocate ( target_mask ) if ( allocated ( dep_dirs )) deallocate ( dep_dirs ) contains subroutine collect_dep_dirs ( tree , dep_dirs ) type ( dependency_tree_t ), intent ( in ) :: tree type ( string_t ), allocatable , intent ( out ) :: dep_dirs (:) integer :: i if ( tree % ndep <= 0 ) then allocate ( dep_dirs ( 0 )) return end if allocate ( dep_dirs ( tree % ndep )) do i = 1 , tree % ndep if ( allocated ( tree % dep ( i )% proj_dir )) then dep_dirs ( i )% s = normalize_path ( trim ( tree % dep ( i )% proj_dir )) else dep_dirs ( i )% s = \"\" end if end do end subroutine collect_dep_dirs end subroutine compute_watch_files_from_settings !> Return whether the settings correspond to `fpm run` or `fpm test`. logical function is_run_or_test ( settings ) class ( fpm_build_settings ), intent ( in ) :: settings is_run_or_test = . false . select type ( settings ) type is ( fpm_test_settings ) is_run_or_test = . true . type is ( fpm_run_settings ) is_run_or_test = . true . end select end function is_run_or_test subroutine gather_files_with_mask ( targets , visited , target_mask , files , file_mask , build_dir , dep_dirs ) type ( build_target_ptr ), intent ( in ) :: targets (:) logical , intent ( in ) :: visited (:) integer ( int64 ), allocatable , intent ( in ), optional :: target_mask (:) type ( string_t ), allocatable , intent ( out ) :: files (:) integer ( int64 ), allocatable , intent ( out ) :: file_mask (:) character ( len =* ), intent ( in ) :: build_dir type ( string_t ), allocatable , intent ( in ), optional :: dep_dirs (:) type ( string_t ), allocatable :: buf (:) integer ( int64 ), allocatable :: mbuf (:) integer :: n , cap integer :: i , j integer ( int64 ) :: m n = 0 cap = 256 allocate ( buf ( cap ), mbuf ( cap )) do i = 1 , size ( targets ) if (. not . visited ( i )) cycle if (. not . allocated ( targets ( i )% ptr % source )) cycle m = 0_int64 if ( present ( target_mask )) then if ( allocated ( target_mask )) m = target_mask ( i ) end if if ( present ( dep_dirs )) then call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % file_name , build_dir , m , dep_dirs ) else call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % file_name , build_dir , m ) end if if ( allocated ( targets ( i )% ptr % source % include_dependencies )) then do j = 1 , size ( targets ( i )% ptr % source % include_dependencies ) if ( present ( dep_dirs )) then call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % include_dependencies ( j )% s , build_dir , m , dep_dirs ) else call vec_push_unique ( buf , mbuf , n , cap , targets ( i )% ptr % source % include_dependencies ( j )% s , build_dir , m ) end if end do end if end do call finalize_vec ( buf , mbuf , n , files , file_mask ) contains subroutine finalize_vec ( buf , mbuf , n , files , file_mask ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( in ) :: n type ( string_t ), allocatable , intent ( out ) :: files (:) integer ( int64 ), allocatable , intent ( out ) :: file_mask (:) integer :: k if ( n <= 0 ) then allocate ( files ( 0 ), file_mask ( 0 )) deallocate ( buf , mbuf ) return end if allocate ( files ( n ), file_mask ( n )) do k = 1 , n call move_alloc ( buf ( k )% s , files ( k )% s ) file_mask ( k ) = mbuf ( k ) end do deallocate ( buf , mbuf ) end subroutine finalize_vec end subroutine gather_files_with_mask subroutine push_file_with_mask ( files , file_mask , path , build_dir , mask , dep_dirs ) type ( string_t ), allocatable , intent ( inout ) :: files (:) integer ( int64 ), allocatable , intent ( inout ) :: file_mask (:) character ( len =* ), intent ( in ) :: path character ( len =* ), intent ( in ) :: build_dir integer ( int64 ), intent ( in ) :: mask type ( string_t ), allocatable , intent ( in ), optional :: dep_dirs (:) type ( string_t ), allocatable :: buf (:) integer ( int64 ), allocatable :: mbuf (:) integer :: n , cap , i if (. not . allocated ( files )) then n = 0 cap = 8 allocate ( buf ( cap ), mbuf ( cap )) else n = size ( files ) cap = max ( 8 , n ) allocate ( buf ( cap ), mbuf ( cap )) do i = 1 , n buf ( i )% s = files ( i )% s mbuf ( i ) = file_mask ( i ) end do end if if ( present ( dep_dirs )) then call vec_push_unique ( buf , mbuf , n , cap , path , build_dir , mask , dep_dirs ) else call vec_push_unique ( buf , mbuf , n , cap , path , build_dir , mask ) end if call finalize_vec ( buf , mbuf , n , files , file_mask ) contains subroutine finalize_vec ( buf , mbuf , n , files , file_mask ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( in ) :: n type ( string_t ), allocatable , intent ( inout ) :: files (:) integer ( int64 ), allocatable , intent ( inout ) :: file_mask (:) type ( string_t ), allocatable :: out (:) integer ( int64 ), allocatable :: outm (:) integer :: k if ( allocated ( files )) deallocate ( files ) if ( allocated ( file_mask )) deallocate ( file_mask ) if ( n <= 0 ) then allocate ( files ( 0 ), file_mask ( 0 )) deallocate ( buf , mbuf ) return end if allocate ( out ( n ), outm ( n )) do k = 1 , n call move_alloc ( buf ( k )% s , out ( k )% s ) outm ( k ) = mbuf ( k ) end do deallocate ( buf , mbuf ) call move_alloc ( out , files ) call move_alloc ( outm , file_mask ) end subroutine finalize_vec end subroutine push_file_with_mask subroutine vec_push_unique ( buf , mbuf , n , cap , path , build_dir , mask , dep_dirs ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( inout ) :: n , cap character ( len =* ), intent ( in ) :: path character ( len =* ), intent ( in ) :: build_dir integer ( int64 ), intent ( in ) :: mask type ( string_t ), allocatable , intent ( in ), optional :: dep_dirs (:) character ( len = :), allocatable :: p integer :: i p = normalize_path ( path ) if ( len_trim ( p ) == 0 ) return if ( is_ignored_path ( p , build_dir )) then if (. not . present ( dep_dirs )) return if (. not . is_in_dep_dirs ( p , dep_dirs )) return end if if (. not . exists ( p )) return do i = 1 , n if ( buf ( i )% s == p ) then mbuf ( i ) = ior ( mbuf ( i ), mask ) return end if end do if ( n >= cap ) call vec_grow ( buf , mbuf , cap ) n = n + 1 buf ( n )% s = p mbuf ( n ) = mask end subroutine vec_push_unique pure logical function is_in_dep_dirs ( p , dep_dirs ) result ( ok ) character ( len =* ), intent ( in ) :: p type ( string_t ), allocatable , intent ( in ) :: dep_dirs (:) integer :: j character ( len = :), allocatable :: d ok = . false . if (. not . allocated ( dep_dirs )) return if ( size ( dep_dirs ) == 0 ) return do j = 1 , size ( dep_dirs ) if ( len_trim ( dep_dirs ( j )% s ) == 0 ) cycle d = normalize_path ( trim ( dep_dirs ( j )% s )) if ( len_trim ( d ) == 0 ) cycle if ( p == d ) then ok = . true . return end if if ( starts_with ( p , d // \"/\" )) then ok = . true . return end if end do end function is_in_dep_dirs subroutine vec_grow ( buf , mbuf , cap ) type ( string_t ), allocatable , intent ( inout ) :: buf (:) integer ( int64 ), allocatable , intent ( inout ) :: mbuf (:) integer , intent ( inout ) :: cap type ( string_t ), allocatable :: nb (:) integer ( int64 ), allocatable :: nm (:) integer :: newcap , i newcap = max ( 16 , cap + cap / 2 ) allocate ( nb ( newcap ), nm ( newcap )) do i = 1 , cap nb ( i )% s = buf ( i )% s nm ( i ) = mbuf ( i ) end do call move_alloc ( nb , buf ) call move_alloc ( nm , mbuf ) cap = newcap end subroutine vec_grow subroutine select_names_or_all ( targets , scope , names , keep ) type ( build_target_ptr ), intent ( in ) :: targets (:) integer , intent ( in ) :: scope character ( len =* ), intent ( in ), optional :: names (:) logical , intent ( inout ) :: keep (:) integer :: i , j character ( len = :), allocatable :: outbase_full , outbase_stem logical :: any_name any_name = . false . if ( present ( names )) then if ( size ( names ) > 0 ) then do j = 1 , size ( names ) if ( len_trim ( names ( j )) > 0 ) then any_name = . true . exit end if end do end if end if if (. not . any_name ) then do i = 1 , size ( targets ) if ( targets ( i )% ptr % is_executable_target ( scope )) keep ( i ) = . true . end do return end if do i = 1 , size ( targets ) if (. not . targets ( i )% ptr % is_executable_target ( scope )) cycle outbase_full = basename ( targets ( i )% ptr % output_file ) outbase_stem = basename ( targets ( i )% ptr % output_file , suffix = . false .) do j = 1 , size ( names ) if ( len_trim ( names ( j )) == 0 ) cycle if ( glob ( trim ( names ( j )), outbase_full ) . or . glob ( trim ( names ( j )), outbase_stem )) then keep ( i ) = . true . exit end if end do end do end subroutine select_names_or_all recursive subroutine dfs_mark_mask ( node , all , tmask , mask ) use fpm_targets , only : build_target_t type ( build_target_t ), pointer , intent ( in ) :: node type ( build_target_ptr ), intent ( in ) :: all (:) integer ( int64 ), intent ( inout ) :: tmask (:) integer ( int64 ), intent ( in ) :: mask integer :: idx , i idx = find_ptr_index ( node , all ) if ( idx <= 0 ) return if ( iand ( tmask ( idx ), mask ) /= 0_int64 ) return tmask ( idx ) = ior ( tmask ( idx ), mask ) if ( allocated ( node % dependencies )) then do i = 1 , size ( node % dependencies ) if ( associated ( node % dependencies ( i )% ptr )) call dfs_mark_mask ( node % dependencies ( i )% ptr , all , tmask , mask ) end do end if end subroutine dfs_mark_mask recursive subroutine dfs_mark_bool ( node , all , visited ) use fpm_targets , only : build_target_t type ( build_target_t ), pointer , intent ( in ) :: node type ( build_target_ptr ), intent ( in ) :: all (:) logical , intent ( inout ) :: visited (:) integer :: idx , i idx = find_ptr_index ( node , all ) if ( idx <= 0 ) return if ( visited ( idx )) return visited ( idx ) = . true . if ( allocated ( node % dependencies )) then do i = 1 , size ( node % dependencies ) if ( associated ( node % dependencies ( i )% ptr )) call dfs_mark_bool ( node % dependencies ( i )% ptr , all , visited ) end do end if end subroutine dfs_mark_bool integer function find_ptr_index ( p , all ) result ( idx ) use fpm_targets , only : build_target_t type ( build_target_t ), pointer , intent ( in ) :: p type ( build_target_ptr ), intent ( in ) :: all (:) integer :: i idx = 0 do i = 1 , size ( all ) if ( associated ( all ( i )% ptr , p )) then idx = i return end if end do end function find_ptr_index end module watch_fpm_graph","tags":"","url":"sourcefile/watch_fpm_graph.f90.html"},{"title":"watch_banner.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_banner.f90~~EfferentGraph sourcefile~watch_banner.f90 watch_banner.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_banner.f90->sourcefile~watch_types.f90 sourcefile~watch_util.f90 watch_util.f90 sourcefile~watch_banner.f90->sourcefile~watch_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_banner.f90~~AfferentGraph sourcefile~watch_banner.f90 watch_banner.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_banner.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Console banner and watch-list reporting. !! !! This module centralizes user-facing console output that is shown on startup !! and when printing the computed watch list. It is intentionally \"UI-only\": !! it does not compute any watch state, it only presents it. !! !! Output is generally suppressed when `w%verbosity < 0` (quiet mode). module watch_banner use , intrinsic :: iso_fortran_env , only : output_unit use watch_types , only : watch_opts_t use watch_util , only : ftoa , trim_or_default , join_csv use fpm_strings , only : string_t , str use fpm_command_line , only : fpm_build_settings , fpm_test_settings , fpm_run_settings use face , only : colorize implicit none private public print_banner , print_file_list contains !> Print the startup banner and an initialization timing summary. !! !! The banner is a compact summary of the effective configuration and the !! computed watch set. !! !! ### Verbosity rules !! - If `w%verbosity < 0`, this routine returns without printing. !! - If `w%debug` is enabled, an extra debug line is printed. !! !! ### Arguments !! - `full_cmdline`: Full command that will be executed (typically `fpm ...`). !! - `settings`: Effective `fpm` settings used to build the model. !! - `w`: Watcher options (verbosity, polling, flags shown in banner). !! - `files`: Computed list of watched file paths (may be unallocated). !! - `build_secs`: Total init time (seconds). !! - `roots_count`: Number of root targets included in the watch closure. !! - `secs_model`, `secs_targets`, `secs_watch`: Timing breakdown (seconds). subroutine print_banner ( full_cmdline , settings , w , files , build_secs , roots_count , secs_model , secs_targets , secs_watch ) character ( len =* ), intent ( in ) :: full_cmdline class ( fpm_build_settings ), intent ( in ) :: settings type ( watch_opts_t ), intent ( in ) :: w type ( string_t ), allocatable , intent ( in ) :: files (:) real , intent ( in ) :: build_secs integer , intent ( in ) :: roots_count real , intent ( in ) :: secs_model , secs_targets , secs_watch integer :: nfiles character ( len = :), allocatable :: mode character ( len = :), allocatable :: initrun character ( len = :), allocatable :: deps character ( len = :), allocatable :: prune character ( len = :), allocatable :: lowcpu character ( len = :), allocatable :: silent character ( len = :), allocatable :: bdir if ( w % verbosity < 0 ) return nfiles = 0 if ( allocated ( files )) nfiles = size ( files ) mode = command_mode ( settings ) if ( w % run_on_start ) then initrun = \"on\" else initrun = \"off\" end if if ( w % watch_deps ) then deps = \"on\" else deps = \"off\" end if if ( settings % prune ) then prune = \"on\" else prune = \"off\" end if if ( w % low_cpu ) then lowcpu = \"on\" else lowcpu = \"off\" end if if ( w % silent_fpm ) then silent = \"on\" else silent = \"off\" end if bdir = trim_or_default ( settings % build_dir , \"build\" ) write ( output_unit , '(a)' ) & colorize ( \"fpm-watch\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  |  watching: \" // colorize ( mode , color_fg = 'yellow_intense' , style = 'bold_on' ) // & \"  |  \" // colorize ( \"Ctrl+C\" , color_fg = 'red_intense' , style = 'bold_on' ) // \" to stop\" write ( output_unit , '(a)' ) & colorize ( \"command    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( full_cmdline ), color_fg = 'white_intense' ) write ( output_unit , '(a)' ) & colorize ( \"build-dir  |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( bdir ), color_fg = 'yellow_intense' ) write ( output_unit , '(a)' ) & colorize ( \"options    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  prune=\" // colorize ( prune , color_fg = 'yellow' ) // & \"   deps=\" // colorize ( deps , color_fg = 'yellow' ) // & \"   low-cpu=\" // colorize ( lowcpu , color_fg = 'yellow' ) // & \"   silent-fpm=\" // colorize ( silent , color_fg = 'yellow' ) // & \"   verbosity=\" // colorize ( str ( w % verbosity ), color_fg = 'yellow' ) write ( output_unit , '(a)' ) & colorize ( \"compiler   |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim_or_default ( settings % compiler , \"(auto)\" ), color_fg = 'green_intense' ) write ( output_unit , '(a)' ) & colorize ( \"profile    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( active_profile ( settings ), color_fg = 'magenta_intense' ) write ( output_unit , '(a)' ) & colorize ( \"features   |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( active_features ( settings ), color_fg = 'blue_intense' ) write ( output_unit , '(a)' ) & colorize ( \"watch      |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  files=\" // colorize ( str ( nfiles ), color_fg = 'yellow_intense' , style = 'bold_on' ) // & \"  roots=\" // colorize ( str ( roots_count ), color_fg = 'yellow_intense' , style = 'bold_on' ) // & \"  poll=\" // colorize ( ftoa ( w % poll ), color_fg = 'yellow' ) // \"s\" // & \"  debounce=\" // colorize ( ftoa ( w % debounce ), color_fg = 'yellow' ) // \"s\" // & \"  rescan=\" // colorize ( ftoa ( w % rescan ), color_fg = 'yellow' ) // \"s\" // & \"  init-run=\" // colorize ( initrun , color_fg = 'yellow' ) write ( output_unit , '(a)' ) & colorize ( \"init       |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  model=\" // colorize ( ftoa ( secs_model ), color_fg = 'yellow' ) // \"s\" // & \"  targets=\" // colorize ( ftoa ( secs_targets ), color_fg = 'yellow' ) // \"s\" // & \"  watchlist=\" // colorize ( ftoa ( secs_watch ), color_fg = 'yellow' ) // \"s\" // & \"  total=\" // colorize ( ftoa ( build_secs ), color_fg = 'yellow_intense' , style = 'bold_on' ) // \"s\" write ( output_unit , '(a)' ) & colorize ( \"stop       |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  Ctrl+C or touch \" // colorize ( \".fpm-watch.stop\" , color_fg = 'yellow_intense' ) if ( w % debug ) then write ( output_unit , '(a)' ) & colorize ( \"debug      |\" , color_fg = 'magenta_intense' , style = 'bold_on' ) // & \"  debug=on  verbosity=\" // colorize ( str ( w % verbosity ), color_fg = 'magenta_intense' ) end if end subroutine print_banner !> Print the computed watch list (limited output). !! !! The printed list is capped to avoid overwhelming the terminal. !! !! ### Verbosity rules !! - Printed only when `w%verbosity >= 2`. !! - Returns immediately if `files` is not allocated. !! !! ### Arguments !! - `files`: Computed list of watched file paths. !! - `w`: Watcher options (controls whether printing is enabled). subroutine print_file_list ( files , w ) type ( string_t ), allocatable , intent ( in ) :: files (:) type ( watch_opts_t ), intent ( in ) :: w integer :: i , cap character ( len = :), allocatable :: pfx if ( w % verbosity < 2 ) return if (. not . allocated ( files )) return cap = 200 pfx = colorize ( \"fpm-watch info:\" , color_fg = 'blue_intense' , style = 'bold_on' ) write ( output_unit , '(a)' ) & pfx // \" watched files list (cap=200), n=\" // & colorize ( str ( size ( files )), color_fg = 'yellow_intense' , style = 'bold_on' ) do i = 1 , min ( size ( files ), cap ) write ( output_unit , '(a)' ) pfx // \"   \" // colorize ( trim ( files ( i )% s ), color_fg = 'white_intense' ) end do if ( size ( files ) > cap ) then write ( output_unit , '(a)' ) & pfx // \"   ... (\" // colorize ( str ( size ( files ) - cap ), color_fg = 'yellow' ) // \" more)\" end if end subroutine print_file_list !> Derive a human-readable mode label from `fpm` settings. !! !! The returned string is used only for banner presentation. pure function command_mode ( settings ) result ( mode ) class ( fpm_build_settings ), intent ( in ) :: settings character ( len = :), allocatable :: mode select type ( s => settings ) type is ( fpm_test_settings ) mode = \"test\" type is ( fpm_run_settings ) if ( s % example ) then mode = \"run --example\" else mode = \"run\" end if class default mode = \"build\" end select end function command_mode !> Return the active build profile for banner display. pure function active_profile ( settings ) result ( p ) class ( fpm_build_settings ), intent ( in ) :: settings character ( len = :), allocatable :: p p = trim_or_default ( settings % profile , \"default\" ) end function active_profile !> Return a comma-separated feature list for banner display. pure function active_features ( settings ) result ( f ) class ( fpm_build_settings ), intent ( in ) :: settings character ( len = :), allocatable :: f if ( allocated ( settings % features )) then f = join_csv ( settings % features , \"(none)\" ) else f = \"(none)\" end if end function active_features end module watch_banner","tags":"","url":"sourcefile/watch_banner.f90.html"},{"title":"watch_fingerprint.f90 – fpm-watch","text":"Files dependent on this one sourcefile~~watch_fingerprint.f90~~AfferentGraph sourcefile~watch_fingerprint.f90 watch_fingerprint.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_fingerprint.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Lightweight file fingerprinting for change detection. !! !! Uses a size-mixed FNV-1a hash of up to three fixed-size blocks from the file !! (head, mid, tail) to efficiently detect modifications. !! !! This fingerprint is intended as a fast heuristic: !! - It is not a cryptographic hash. !! - It trades perfect detection for performance on large trees. !! - Combining size + multiple sample blocks provides good practical coverage. module watch_fingerprint use , intrinsic :: iso_fortran_env , only : int64 use fpm_strings , only : string_t use fpm_filesystem , only : basename use fpm_command_line , only : fpm_build_settings implicit none private public init_fingerprints , scan_changes , accept_changes , manifest_key_from_files , file_fingerprint integer ( int64 ), parameter :: FNV_OFFSET = 1469598103934665603_int64 integer ( int64 ), parameter :: FNV_PRIME = 1099511628211_int64 integer , parameter :: BLOCK_SIZE = 4096 character ( len = 1 ), allocatable , save :: io_buf (:) contains !> Initialize fingerprint arrays for a watch list. !! !! Allocates `fp_prev`, `fp_now`, and `changed_idx` to match the size of !! `files`. Initial fingerprints are computed once and copied into `fp_now`. subroutine init_fingerprints ( files , fp_prev , fp_now , changed_idx ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer ( int64 ), allocatable , intent ( inout ) :: fp_prev (:) integer ( int64 ), allocatable , intent ( inout ) :: fp_now (:) integer , allocatable , intent ( inout ) :: changed_idx (:) integer :: n , i if (. not . allocated ( files )) then if ( allocated ( fp_prev )) deallocate ( fp_prev ) if ( allocated ( fp_now )) deallocate ( fp_now ) if ( allocated ( changed_idx )) deallocate ( changed_idx ) allocate ( fp_prev ( 0 ), fp_now ( 0 ), changed_idx ( 0 )) return end if n = size ( files ) if ( allocated ( fp_prev )) deallocate ( fp_prev ) if ( allocated ( fp_now )) deallocate ( fp_now ) if ( allocated ( changed_idx )) deallocate ( changed_idx ) allocate ( fp_prev ( n ), fp_now ( n ), changed_idx ( n )) do i = 1 , n fp_prev ( i ) = file_fingerprint ( files ( i )% s ) end do fp_now = fp_prev end subroutine init_fingerprints !> Scan files and return indices of changed entries. !! !! `changed_idx(1:changed_count)` contains the 1-based indices into `files` !! for which the fingerprint differs from `fp_prev`. subroutine scan_changes ( files , fp_prev , fp_now , changed_idx , changed_count ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer ( int64 ), intent ( in ) :: fp_prev (:) integer ( int64 ), intent ( inout ) :: fp_now (:) integer , intent ( inout ) :: changed_idx (:) integer , intent ( out ) :: changed_count integer :: i , n changed_count = 0 if (. not . allocated ( files )) return n = size ( files ) if ( n == 0 ) return do i = 1 , n fp_now ( i ) = file_fingerprint ( files ( i )% s ) if ( fp_now ( i ) /= fp_prev ( i )) then changed_count = changed_count + 1 changed_idx ( changed_count ) = i end if end do end subroutine scan_changes !> Accept the new fingerprints for the subset of changed indices. !! !! After a successful run, this updates `fp_prev` so future scans detect new !! changes relative to the latest known state. subroutine accept_changes ( fp_prev , fp_now , changed_idx , changed_count ) integer ( int64 ), intent ( inout ) :: fp_prev (:) integer ( int64 ), intent ( in ) :: fp_now (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count integer :: j , i do j = 1 , changed_count i = changed_idx ( j ) if ( i >= 1 . and . i <= size ( fp_prev )) fp_prev ( i ) = fp_now ( i ) end do end subroutine accept_changes !> Compute a key representing the current manifest-related configuration. !! !! This key is used to detect when changes require rebuilding the watch list. !! It includes: !! - Selected `fpm_build_settings` fields !! - Feature list (`settings%features`) !! - The fingerprint of any watched file named `fpm.toml` integer ( int64 ) function manifest_key_from_files ( settings , files ) result ( k ) class ( fpm_build_settings ), intent ( in ) :: settings type ( string_t ), allocatable , intent ( in ) :: files (:) integer :: i character ( len = :), allocatable :: b k = FNV_OFFSET call mix_alloc ( k , settings % build_dir ) call mix_alloc ( k , settings % compiler ) call mix_alloc ( k , settings % c_compiler ) call mix_alloc ( k , settings % cxx_compiler ) call mix_alloc ( k , settings % archiver ) call mix_alloc ( k , settings % profile ) call mix_alloc ( k , settings % flag ) call mix_alloc ( k , settings % cflag ) call mix_alloc ( k , settings % cxxflag ) call mix_alloc ( k , settings % ldflag ) if ( settings % prune ) then call fnv1a_mix_str ( k , \"prune=1\" ) else call fnv1a_mix_str ( k , \"prune=0\" ) end if if ( settings % build_tests ) then call fnv1a_mix_str ( k , \"build_tests=1\" ) else call fnv1a_mix_str ( k , \"build_tests=0\" ) end if if ( allocated ( settings % features )) then do i = 1 , size ( settings % features ) call fnv1a_mix_str ( k , trim ( settings % features ( i )% s )) end do end if if (. not . allocated ( files )) return do i = 1 , size ( files ) b = basename ( files ( i )% s ) if ( b == \"fpm.toml\" ) then call fnv1a_mix_str ( k , files ( i )% s ) call fnv1a_mix_i64 ( k , file_fingerprint ( files ( i )% s )) end if end do contains subroutine mix_alloc ( h , s ) integer ( int64 ), intent ( inout ) :: h character ( len = :), allocatable , intent ( in ) :: s if (. not . allocated ( s )) return if ( len_trim ( s ) == 0 ) return call fnv1a_mix_str ( h , trim ( s )) end subroutine mix_alloc end function manifest_key_from_files !> Compute a fingerprint for a file path. !! !! Strategy: !! - Read the file size (`inquire(size=...)`). !! - Hash up to three blocks (head/mid/tail) using FNV-1a mixing. !! - Combine with file size to reduce collision risk. !! !! Missing/unreadable files return `0`. integer ( int64 ) function file_fingerprint ( path ) result ( fp ) character ( len =* ), intent ( in ) :: path logical :: ex integer ( int64 ) :: sz , h , n64 , pos_mid , pos_end , pos_max integer :: u , ios , n inquire ( file = trim ( path ), exist = ex , size = sz , iostat = ios ) if ( ios /= 0 . or . . not . ex ) then fp = 0_int64 return end if if ( sz <= 0_int64 ) then fp = 0_int64 return end if n64 = min ( sz , int ( BLOCK_SIZE , int64 )) n = int ( n64 ) open ( newunit = u , file = trim ( path ), access = \"stream\" , form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios /= 0 ) then fp = ieor ( ishft ( sz , 1 ), FNV_OFFSET ) return end if if (. not . allocated ( io_buf )) allocate ( io_buf ( BLOCK_SIZE )) h = FNV_OFFSET call hash_block ( u , 1_int64 , n , h ) if ( sz > n64 ) then pos_max = max ( 1_int64 , sz - n64 + 1_int64 ) pos_mid = sz / 2_int64 - n64 / 2_int64 if ( pos_mid < 1_int64 ) pos_mid = 1_int64 if ( pos_mid > pos_max ) pos_mid = pos_max pos_end = pos_max call hash_block ( u , pos_mid , n , h ) call hash_block ( u , pos_end , n , h ) end if close ( u ) fp = ieor ( ishft ( sz , 1 ), h ) end function file_fingerprint !> Hash a single file block at a specific stream position. subroutine hash_block ( u , pos , n , h ) integer , intent ( in ) :: u integer ( int64 ), intent ( in ) :: pos integer , intent ( in ) :: n integer ( int64 ), intent ( inout ) :: h integer :: ios , i if ( n <= 0 ) return read ( u , pos = pos , iostat = ios ) io_buf ( 1 : n ) if ( ios == 0 ) then do i = 1 , n call fnv1a_mix_i64 ( h , int ( iachar ( io_buf ( i )), int64 )) end do end if end subroutine hash_block !> Mix a string into a 64-bit FNV-1a state. subroutine fnv1a_mix_str ( h , s ) integer ( int64 ), intent ( inout ) :: h character ( len =* ), intent ( in ) :: s integer :: i do i = 1 , len_trim ( s ) call fnv1a_mix_i64 ( h , int ( iachar ( s ( i : i )), int64 )) end do end subroutine fnv1a_mix_str !> Mix a single 64-bit value into a 64-bit FNV-1a state. subroutine fnv1a_mix_i64 ( h , x ) integer ( int64 ), intent ( inout ) :: h integer ( int64 ), intent ( in ) :: x h = ieor ( h , x ) h = h * FNV_PRIME end subroutine fnv1a_mix_i64 end module watch_fingerprint","tags":"","url":"sourcefile/watch_fingerprint.f90.html"},{"title":"watch_log.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_log.f90~~EfferentGraph sourcefile~watch_log.f90 watch_log.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_log.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_log.f90~~AfferentGraph sourcefile~watch_log.f90 watch_log.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_log.f90 sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_factory.f90 sourcefile~watch_fpm_graph.f90 watch_fpm_graph.f90 sourcefile~watch_engine.f90->sourcefile~watch_fpm_graph.f90 sourcefile~watch_feat_stats.f90 watch_feat_stats.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_log.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_log.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feat_stats.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_log.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Lightweight structured logging for console output. !! !! Provides a consistent `key | message` style format with optional color. !! !! Logging respects `w%verbosity`: !! - `< 0`: suppress info/warn output !! - `debug` messages require `w%debug = .true.` module watch_log use , intrinsic :: iso_fortran_env , only : output_unit , error_unit use watch_types , only : watch_opts_t use face , only : colorize implicit none private public log_info , log_warn , log_err , log_debug contains !> Log an informational message. subroutine log_info ( w , msg ) type ( watch_opts_t ), intent ( in ) :: w character ( len =* ), intent ( in ) :: msg if ( w % verbosity < 0 ) return write ( output_unit , '(a)' ) & colorize ( \"info       |\" , color_fg = 'blue_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_info !> Log a warning message. subroutine log_warn ( w , msg ) type ( watch_opts_t ), intent ( in ) :: w character ( len =* ), intent ( in ) :: msg if ( w % verbosity < 0 ) return write ( output_unit , '(a)' ) & colorize ( \"warn       |\" , color_fg = 'yellow_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_warn !> Log an error message (always prints). subroutine log_err ( msg ) character ( len =* ), intent ( in ) :: msg write ( error_unit , '(a)' ) & colorize ( \"error      |\" , color_fg = 'red_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_err !> Log a debug message (prints only when `debug` is enabled). subroutine log_debug ( w , msg ) type ( watch_opts_t ), intent ( in ) :: w character ( len =* ), intent ( in ) :: msg if (. not . w % debug ) return write ( output_unit , '(a)' ) & colorize ( \"debug      |\" , color_fg = 'magenta_intense' , style = 'bold_on' ) // \"  \" // trim ( msg ) end subroutine log_debug end module watch_log","tags":"","url":"sourcefile/watch_log.f90.html"},{"title":"watch_time.F90 – fpm-watch","text":"Files dependent on this one sourcefile~~watch_time.f90~~AfferentGraph sourcefile~watch_time.f90 watch_time.F90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_time.f90 sourcefile~watch_restart.f90 watch_restart.f90 sourcefile~watch_restart.f90->sourcefile~watch_time.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Sleep utilities and low-CPU waiting. !! !! `fpm-watch` is primarily poll-based. To avoid burning CPU while idle, this !! module provides: !! - a default spin-wait implementation (`sleep_spin`) for portability, and !! - an OS sleep implementation (`sleep_os`) for near-zero CPU usage. !! !! `set_low_cpu(.true.)` selects OS sleep for `sleep_seconds`. module watch_time use , intrinsic :: iso_fortran_env , only : int64 use , intrinsic :: iso_c_binding , only : c_int , c_long implicit none private public sleep_seconds , set_low_cpu !> Global mode switch that selects OS sleep vs spin sleep. logical , save :: low_cpu_mode = . false . #if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__MINGW64__) interface subroutine c_sleep_ms ( ms ) bind ( C , name = \"Sleep\" ) import c_int implicit none integer ( c_int ), value :: ms end subroutine c_sleep_ms end interface #else type , bind ( C ) :: timespec integer ( c_long ) :: tv_sec integer ( c_long ) :: tv_nsec end type timespec interface integer ( c_int ) function c_nanosleep ( req , rem ) bind ( C , name = \"nanosleep\" ) import c_int , timespec implicit none type ( timespec ), intent ( in ) :: req type ( timespec ), intent ( out ) :: rem end function c_nanosleep end interface #endif contains !> Enable or disable low-CPU mode. !! !! When enabled, `sleep_seconds` uses the OS sleep implementation. subroutine set_low_cpu ( flag ) logical , intent ( in ) :: flag low_cpu_mode = flag end subroutine set_low_cpu !> Sleep for a number of seconds. !! !! Dispatches to either `sleep_os` (low CPU) or `sleep_spin` (busy wait) !! depending on the global `low_cpu_mode`. subroutine sleep_seconds ( s ) real , intent ( in ) :: s if ( s <= 0.0 ) return if ( low_cpu_mode ) then call sleep_os ( s ) else call sleep_spin ( s ) end if end subroutine sleep_seconds !> Busy-wait for approximately `s` seconds. !! !! This is used only when low CPU mode is disabled. subroutine sleep_spin ( s ) real , intent ( in ) :: s integer ( int64 ) :: rate , t0 , t1 , ticks if ( s <= 0.0 ) return call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 ticks = int ( s * real ( rate ), int64 ) if ( ticks <= 0_int64 ) return call system_clock ( t0 ) do call system_clock ( t1 ) if ( t1 - t0 >= ticks ) exit end do end subroutine sleep_spin !> OS-backed sleep for approximately `s` seconds. !! !! - Windows: calls `Sleep(ms)` !! - POSIX: calls `nanosleep(timespec)` !! !! This is intended to minimize CPU usage while waiting. subroutine sleep_os ( s ) real , intent ( in ) :: s #if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) integer ( c_int ) :: ms real :: ss ss = s if ( ss <= 0.0 ) return ms = int ( ss * 100 0.0 + 0.5 , kind = c_int ) if ( ms <= 0_c_int ) ms = 1_c_int call c_sleep_ms ( ms ) #else type ( timespec ) :: req , rem integer ( c_int ) :: rc real :: ss , frac integer ( c_long ) :: sec integer ( c_long ) :: nsec ss = s if ( ss <= 0.0 ) return sec = int ( ss , kind = c_long ) frac = ss - real ( sec ) if ( frac < 0.0 ) frac = 0.0 nsec = int ( frac * 100000000 0.0 , kind = c_long ) if ( nsec < 0_c_long ) nsec = 0_c_long if ( nsec >= 1000000000_c_long ) then sec = sec + 1_c_long nsec = nsec - 1000000000_c_long end if req % tv_sec = sec req % tv_nsec = nsec do rc = c_nanosleep ( req , rem ) if ( rc == 0_c_int ) exit req = rem end do #endif end subroutine sleep_os end module watch_time","tags":"","url":"sourcefile/watch_time.f90.html"},{"title":"watch_cmdsplice.f90 – fpm-watch","text":"Files dependent on this one sourcefile~~watch_cmdsplice.f90~~AfferentGraph sourcefile~watch_cmdsplice.f90 watch_cmdsplice.f90 sourcefile~watch_cli.f90 watch_cli.f90 sourcefile~watch_cli.f90->sourcefile~watch_cmdsplice.f90 sourcefile~watch_exec.f90 watch_exec.f90 sourcefile~watch_exec.f90->sourcefile~watch_cmdsplice.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_exec.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Helpers for manipulating `fpm` command lines. !! !! Provides utilities to split an `fpm <subcmd> ...` command into a prefix and !! remainder, and to inject target names into the correct position while !! preserving a `--` delimiter for arguments passed to the executed program. !! !! These utilities operate on *plain strings* and assume a space-delimited !! token structure. They do not implement general shell parsing. module watch_cmdsplice implicit none private public split_cmd_after_subcmd , inject_names_into_cmd contains !> Split a command line into `<fpm subcmd>` prefix and remaining arguments. !! !! This is used to support name injection for `fpm run`/`fpm test`: !! the injected names are inserted after `prefix` and before the rest, !! while respecting a `--` delimiter. subroutine split_cmd_after_subcmd ( full , prefix , rest ) character ( len =* ), intent ( in ) :: full !! Full command string. character ( len = :), allocatable , intent ( out ) :: prefix !! Prefix up to and including the subcommand token. character ( len = :), allocatable , intent ( out ) :: rest !! Remaining arguments after the subcommand. character ( len = :), allocatable :: s integer :: p_fpm_end , p_sub_start , p_sub_end s = adjustl ( trim ( full )) prefix = \"\" rest = \"\" if ( len_trim ( s ) == 0 ) return if (. not . starts_with_token ( s , \"fpm\" )) return p_fpm_end = token_end ( s , 1 ) p_sub_start = next_token_start ( s , p_fpm_end + 1 ) if ( p_sub_start == 0 ) return p_sub_end = token_end ( s , p_sub_start ) prefix = trim ( s ( 1 : p_sub_end )) if ( p_sub_end < len_trim ( s )) then rest = adjustl ( s ( p_sub_end + 1 :)) else rest = \"\" end if contains pure logical function starts_with_token ( str , tok ) result ( ok ) character ( len =* ), intent ( in ) :: str , tok integer :: e , n ok = . false . n = len_trim ( tok ) if ( n == 0 ) return if ( len_trim ( str ) < n ) return if ( str ( 1 : n ) /= tok ( 1 : n )) return e = token_end ( str , 1 ) ok = ( e == n ) end function starts_with_token pure integer function next_token_start ( str , i ) result ( pos ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: i integer :: k , n pos = 0 n = len_trim ( str ) k = max ( 1 , i ) do while ( k <= n ) if ( str ( k : k ) /= \" \" . and . str ( k : k ) /= char ( 9 )) then pos = k return end if k = k + 1 end do end function next_token_start pure integer function token_end ( str , i ) result ( pos ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: i integer :: k , n pos = 0 n = len_trim ( str ) if ( i < 1 . or . i > n ) return k = i do while ( k <= n ) if ( str ( k : k ) == \" \" . or . str ( k : k ) == char ( 9 )) then pos = k - 1 return end if k = k + 1 end do pos = n end function token_end end subroutine split_cmd_after_subcmd !> Inject target names into a command line while respecting a `--` delimiter. !! !! `fpm run` and `fpm test` accept optional name patterns. This helper !! inserts those names into the right location: !! - after the `prefix` and any existing `fpm` options, !! - before a `--` delimiter (if present), so that program arguments remain !!   attached to the executed program. function inject_names_into_cmd ( prefix , rest , names ) result ( out ) character ( len =* ), intent ( in ) :: prefix !! Prefix up to and including the subcommand. character ( len =* ), intent ( in ) :: rest !! Remaining arguments after the subcommand. character ( len =* ), intent ( in ) :: names !! Space-separated names to inject. character ( len = :), allocatable :: out character ( len = :), allocatable :: p , r , n , before , after integer :: dd p = trim ( prefix ) r = adjustl ( trim ( rest )) n = trim ( names ) if ( len_trim ( p ) == 0 ) then out = \"\" return end if if ( len_trim ( n ) == 0 ) then if ( len_trim ( r ) == 0 ) then out = p else out = p // \" \" // r end if return end if dd = find_double_dash_delim ( r ) if ( dd > 0 ) then if ( dd > 1 ) then before = trim ( r ( 1 : dd - 1 )) else before = \"\" end if after = trim ( adjustl ( r ( dd :))) else before = trim ( r ) after = \"\" end if out = p if ( len_trim ( before ) > 0 ) out = out // \" \" // before out = out // \" \" // n if ( len_trim ( after ) > 0 ) out = out // \" \" // after contains pure integer function find_double_dash_delim ( str ) result ( pos ) character ( len =* ), intent ( in ) :: str integer :: i , n pos = 0 n = len_trim ( str ) if ( n < 2 ) return do i = 1 , n - 1 if ( str ( i : i + 1 ) == \"--\" ) then if ( is_boundary ( str , i - 1 ) . and . is_boundary ( str , i + 2 )) then pos = i return end if end if end do end function find_double_dash_delim pure logical function is_boundary ( str , j ) result ( ok ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: j integer :: n n = len_trim ( str ) if ( j < 1 ) then ok = . true . else if ( j > n ) then ok = . true . else ok = ( str ( j : j ) == \" \" . or . str ( j : j ) == char ( 9 )) end if end function is_boundary end function inject_names_into_cmd end module watch_cmdsplice","tags":"","url":"sourcefile/watch_cmdsplice.f90.html"},{"title":"watch_feature_factory.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_feature_factory.f90~~EfferentGraph sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_feat_stats.f90 watch_feat_stats.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feat_stats.f90 sourcefile~watch_feature_api.f90 watch_feature_api.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feature_manager.f90 watch_feature_manager.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_manager.f90 sourcefile~watch_log.f90 watch_log.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_log.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_types.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_log.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_api.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_types.f90 sourcefile~watch_log.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_feature_factory.f90~~AfferentGraph sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_factory.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Feature enablement and factory wiring. !! !! Maps feature names (strings) to concrete feature implementations. !! !! Feature selection is user-controlled via: !! - `--watch-feature <name>` flags, and/or !! - `features = [\"...\"]` in `fpm.toml` `[extra.fpm-watch]`. module watch_feature_factory use watch_feature_manager , only : feature_manager_t use watch_types , only : watch_opts_t use watch_log , only : log_warn use watch_feat_stats , only : new_stats_feature use watch_feature_api , only : watch_feature_t implicit none private public enable_features contains !> Enable features requested in watch options. !! !! Unknown feature names are ignored with a warning. subroutine enable_features ( fm , w ) type ( feature_manager_t ), intent ( inout ) :: fm type ( watch_opts_t ), intent ( in ) :: w integer :: i character ( len = :), allocatable :: name if (. not . allocated ( w % enabled_features )) return do i = 1 , size ( w % enabled_features ) name = trim ( w % enabled_features ( i )% s ) if ( len_trim ( name ) == 0 ) cycle select case ( name ) case ( \"stats\" ) call add_stats ( fm ) case default call log_warn ( w , \"unknown feature '\" // name // \"' (ignored)\" ) end select end do end subroutine enable_features !> Factory helper: add the built-in `stats` feature. subroutine add_stats ( fm ) type ( feature_manager_t ), intent ( inout ) :: fm class ( watch_feature_t ), allocatable :: f call new_stats_feature ( f ) call fm % add ( f ) end subroutine add_stats end module watch_feature_factory","tags":"","url":"sourcefile/watch_feature_factory.f90.html"},{"title":"watch_clock.f90 – fpm-watch","text":"Source Code !> Clock utilities for timing measurements. !! !! Provides a small wrapper over `system_clock` that standardizes rate/max !! initialization and offers helpers for deltas and conversion to seconds. !! !! These helpers are intended for lightweight runtime timing, not for strict !! profiling or performance benchmarking. module watch_clock use , intrinsic :: iso_fortran_env , only : int64 implicit none private public clock_init , clock_now , clock_delta , ticks_to_seconds contains !> Initialize `system_clock` parameters. pure subroutine clock_init ( rate , max ) integer ( int64 ), intent ( out ) :: rate , max !! Clock tick rate and maximum tick count as reported by `system_clock`. !! !! If the platform reports non-positive values, fallbacks are applied: !! - `rate` defaults to `1000` ticks/sec. !! - `max` defaults to `huge(1_int64)`. call system_clock ( count_rate = rate , count_max = max ) if ( rate <= 0_int64 ) rate = 1000_int64 if ( max <= 0_int64 ) max = huge ( 1_int64 ) end subroutine clock_init !> Fetch the current clock tick count. subroutine clock_now ( t ) integer ( int64 ), intent ( out ) :: t !! Current tick count from `system_clock`. call system_clock ( t ) end subroutine clock_now !> Compute tick delta between two readings with wraparound handling. !! !! Some `system_clock` implementations wrap at `count_max`. This helper !! treats `t0` and `t1` as readings from the same clock configuration. pure integer ( int64 ) function clock_delta ( t0 , t1 , max ) result ( dt ) integer ( int64 ), intent ( in ) :: t0 , t1 , max !! Start tick, end tick, and maximum tick before wrap. if ( t1 >= t0 ) then dt = t1 - t0 else dt = ( max - t0 + 1_int64 ) + t1 end if end function clock_delta !> Convert ticks to seconds using a specified tick rate. pure real function ticks_to_seconds ( ticks , rate ) result ( secs ) integer ( int64 ), intent ( in ) :: ticks , rate !! Tick delta and tick rate. secs = real ( ticks ) / real ( rate ) end function ticks_to_seconds end module watch_clock","tags":"","url":"sourcefile/watch_clock.f90.html"},{"title":"watch_types.f90 – fpm-watch","text":"Files dependent on this one sourcefile~~watch_types.f90~~AfferentGraph sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_banner.f90 watch_banner.f90 sourcefile~watch_banner.f90->sourcefile~watch_types.f90 sourcefile~watch_cli.f90 watch_cli.f90 sourcefile~watch_cli.f90->sourcefile~watch_types.f90 sourcefile~watch_config.f90 watch_config.f90 sourcefile~watch_cli.f90->sourcefile~watch_config.f90 sourcefile~watch_config.f90->sourcefile~watch_types.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_types.f90 sourcefile~watch_engine.f90->sourcefile~watch_banner.f90 sourcefile~watch_exec.f90 watch_exec.f90 sourcefile~watch_engine.f90->sourcefile~watch_exec.f90 sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_factory.f90 sourcefile~watch_feature_manager.f90 watch_feature_manager.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_manager.f90 sourcefile~watch_fpm_graph.f90 watch_fpm_graph.f90 sourcefile~watch_engine.f90->sourcefile~watch_fpm_graph.f90 sourcefile~watch_log.f90 watch_log.f90 sourcefile~watch_engine.f90->sourcefile~watch_log.f90 sourcefile~watch_exec.f90->sourcefile~watch_types.f90 sourcefile~watch_feat_stats.f90 watch_feat_stats.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_api.f90 watch_feature_api.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_log.f90 sourcefile~watch_feature_api.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feat_stats.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feature_manager.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_log.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_manager.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_types.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_log.f90 sourcefile~watch_log.f90->sourcefile~watch_types.f90 sourcefile~watch_restart.f90 watch_restart.f90 sourcefile~watch_restart.f90->sourcefile~watch_config.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Shared types used throughout `fpm-watch`. !! !! This module defines the configuration records used to pass options and !! `fpm` settings into the engine. module watch_types use , intrinsic :: iso_fortran_env , only : int64 use fpm_strings , only : string_t use fpm_command_line , only : fpm_build_settings implicit none private public watch_opts_t , root_info_t , watch_config_t !> Watcher configuration options. !! !! Values are typically assembled from: !! - hard-coded defaults, !! - `fpm.toml` overrides (`[extra.fpm-watch]`), !! - command-line flags (`--watch-*`). !! !! Time values (`poll`, `debounce`, `rescan`) are in seconds. type watch_opts_t !! Verbosity level: !! - `-1`: quiet (errors only) !! - `0`: normal !! - `1..2`: more detail integer :: verbosity = 0 !! Enable extra debug output and internal timing/status messages. logical :: debug = . false . !! Poll interval (seconds) between change scans. real :: poll = 0.5 !! Debounce interval (seconds) used after the first detected change. real :: debounce = 0.2 !! Optional periodic rescan interval (seconds). `0` disables periodic rescans. real :: rescan = 0.0 !! Run the command once immediately on startup. logical :: run_on_start = . true . !! Print the watched file list once at startup (requires high verbosity). logical :: print_files_once = . false . !! Suppress `fpm` output; keep only `fpm-watch` status lines. logical :: silent_fpm = . false . !! Also watch dependency project sources (can include paths under build dir). logical :: watch_deps = . false . !! Use OS sleep for waiting to minimize idle CPU usage. logical :: low_cpu = . false . !! Glob patterns to ignore. type ( string_t ), allocatable :: ignore (:) !! Glob patterns to include; if empty, includes all. type ( string_t ), allocatable :: include (:) !! Names of optional feature plugins to enable. type ( string_t ), allocatable :: enabled_features (:) !! Run once (init + optional run-on-start) and exit (CI-friendly). logical :: once = . false . end type watch_opts_t !> Root target metadata used for change → target mapping. !! !! The `mask` is a single-bit value used to mark membership of files and !! target closures. type root_info_t character ( len = :), allocatable :: name integer ( int64 ) :: mask = 0_int64 end type root_info_t !> Fully assembled watcher configuration. !! !! This record is the primary input to `watcher_t%init()`. type watch_config_t !! Watcher options. type ( watch_opts_t ) :: w !! Full command line string to execute (e.g., `fpm test -- ...`). character ( len = :), allocatable :: fpm_cmdline !! Selected `fpm` subcommand (`build`, `test`, or `run`). character ( len = :), allocatable :: subcmd !! Typed `fpm` settings corresponding to `subcmd`. class ( fpm_build_settings ), allocatable :: settings !! Cached prefix up to and including the subcommand token (for injection). character ( len = :), allocatable :: cmd_prefix !! Cached remainder after the subcommand token (for injection). character ( len = :), allocatable :: cmd_rest end type watch_config_t end module watch_types","tags":"","url":"sourcefile/watch_types.f90.html"},{"title":"watch_platform.f90 – fpm-watch","text":"Source Code !> Platform-specific helpers. !! !! Provides shell wrapping and null-device paths for portable command execution. !! !! This module is intentionally minimal and uses `fpm_environment:get_os_type` !! for OS detection. module watch_platform use fpm_environment , only : get_os_type , OS_WINDOWS implicit none private public is_windows , shell_wrap , null_device contains !> Return whether the current OS is Windows. logical function is_windows () is_windows = ( get_os_type () == OS_WINDOWS ) end function is_windows !> Return the system null device path. function null_device () result ( p ) character ( len = :), allocatable :: p if ( is_windows ()) then p = \"NUL\" else p = \"/dev/null\" end if end function null_device !> Wrap a command for execution by the platform shell. !! !! - Windows: `cmd /c \"...\"` with doubled quotes !! - POSIX: `sh -c '...'` with standard single-quote escaping function shell_wrap ( cmd ) result ( wrapped ) character ( len =* ), intent ( in ) :: cmd character ( len = :), allocatable :: wrapped if ( is_windows ()) then wrapped = 'cmd /c \"' // escape_quotes_win ( trim ( cmd )) // '\"' else wrapped = \"sh -c '\" // escape_quotes_sh ( trim ( cmd )) // \"'\" end if contains function escape_quotes_win ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: i r = \"\" do i = 1 , len_trim ( s ) if ( s ( i : i ) == '\"' ) then r = r // '\"\"' else r = r // s ( i : i ) end if end do end function escape_quotes_win function escape_quotes_sh ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r integer :: i r = \"\" do i = 1 , len_trim ( s ) if ( s ( i : i ) == \"'\" ) then r = r // \"'\"\"'\"\"'\" else r = r // s ( i : i ) end if end do end function escape_quotes_sh end function shell_wrap end module watch_platform","tags":"","url":"sourcefile/watch_platform.f90.html"},{"title":"watch_exec.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_exec.f90~~EfferentGraph sourcefile~watch_exec.f90 watch_exec.f90 sourcefile~watch_cmdsplice.f90 watch_cmdsplice.f90 sourcefile~watch_exec.f90->sourcefile~watch_cmdsplice.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_exec.f90->sourcefile~watch_types.f90 sourcefile~watch_util.f90 watch_util.f90 sourcefile~watch_exec.f90->sourcefile~watch_util.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_exec.f90~~AfferentGraph sourcefile~watch_exec.f90 watch_exec.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_exec.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Command execution and run reporting. !! !! Provides the user-facing change summary and the mechanics to construct and !! execute the effective `fpm` command. module watch_exec use , intrinsic :: iso_fortran_env , only : int64 , output_unit use watch_types , only : watch_opts_t , root_info_t use watch_util , only : ftoa use fpm_strings , only : string_t , str use fpm_filesystem , only : run use fpm_command_line , only : fpm_build_settings , fpm_test_settings , fpm_run_settings use face , only : colorize implicit none private public report_changes , run_command_and_report , build_run_command contains !> Print a summary of changed files. !! !! The output is intentionally limited (cap=8) to keep logs compact. !! This routine is suppressed in quiet mode (`w%verbosity < 0`). subroutine report_changes ( files , changed_idx , changed_count , w ) type ( string_t ), allocatable , intent ( in ) :: files (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count type ( watch_opts_t ), intent ( in ) :: w integer :: i , cap , idx if ( w % verbosity < 0 ) return cap = 8 write ( output_unit , '(a)' ) & colorize ( \"change     |\" , color_fg = 'yellow_intense' , style = 'bold_on' ) // \"  \" // & colorize ( str ( changed_count ), color_fg = 'yellow_intense' , style = 'bold_on' ) // & \" files (debounced \" // colorize ( ftoa ( w % debounce ), color_fg = 'yellow' ) // \"s)\" if ( changed_count == 0 ) return if (. not . allocated ( files )) return do i = 1 , min ( changed_count , cap ) idx = changed_idx ( i ) if ( idx < 1 . or . idx > size ( files )) cycle write ( output_unit , '(a)' ) \"           |  \" // colorize ( trim ( files ( idx )% s ), color_fg = 'yellow' ) end do if ( changed_count > cap ) then write ( output_unit , '(a)' ) & \"           |  ... +\" // colorize ( str ( changed_count - cap ), color_fg = 'yellow' ) // \" more\" end if end subroutine report_changes !> Execute a command and print pre/post status lines. !! !! This routine is responsible for: !! - Printing a \"run\" line (unless quiet), !! - Executing the command via `fpm_filesystem:run`, !! - Timing the execution with `system_clock`, !! - Printing a final OK/FAIL summary and returning `exitstat` and `secs`. !! !! When `w%silent_fpm` is true, the executed command's output is suppressed !! (but the status lines from `fpm-watch` remain visible). subroutine run_command_and_report ( cmd , w , exitstat , secs ) character ( len =* ), intent ( in ) :: cmd type ( watch_opts_t ), intent ( in ) :: w integer , intent ( out ) :: exitstat real , intent ( out ) :: secs integer ( int64 ) :: rate , t0 , t1 logical :: verbose_run character ( len = :), allocatable :: status_color character ( len = :), allocatable :: status_word call system_clock ( count_rate = rate ) if ( rate <= 0_int64 ) rate = 1000_int64 verbose_run = . not . w % silent_fpm if ( w % verbosity >= 0 ) then if ( w % silent_fpm ) then write ( output_unit , '(a)' ) & colorize ( \"run        |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( cmd ), color_fg = 'white_intense' ) // \"  \" // & colorize ( \"(fpm output silenced)\" , color_fg = 'magenta_intense' , style = 'italics_on' ) else write ( output_unit , '(a)' ) & colorize ( \"run        |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( cmd ), color_fg = 'white_intense' ) end if end if if ( w % verbosity >= 0 ) flush ( output_unit ) call system_clock ( t0 ) call run ( trim ( cmd ), echo = . false ., exitstat = exitstat , verbose = verbose_run ) call system_clock ( t1 ) secs = real ( t1 - t0 ) / real ( rate ) if ( exitstat == 0 ) then status_color = \"green_intense\" status_word = \"OK\" else status_color = \"red_intense\" status_word = \"FAIL\" end if if ( w % verbosity >= 0 ) then write ( output_unit , '(a)' ) \"\" write ( output_unit , '(a)' ) & colorize ( \"done       |\" , color_fg = status_color , style = 'bold_on' ) // & \"  \" // colorize ( status_word , color_fg = status_color , style = 'bold_on' ) // & \"  exit=\" // colorize ( str ( exitstat ), color_fg = status_color , style = 'bold_on' ) // & \"  time=\" // colorize ( ftoa ( secs ), color_fg = 'yellow_intense' ) // \"s\" write ( output_unit , '(a)' ) & colorize ( \"command    |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // \"  \" // & colorize ( trim ( cmd ), color_fg = 'white_intense' ) write ( output_unit , '(a)' ) & colorize ( \"watch      |\" , color_fg = 'cyan_intense' , style = 'bold_on' ) // & \"  waiting (poll=\" // colorize ( ftoa ( w % poll ), color_fg = 'yellow' ) // \"s\" // & \", debounce=\" // colorize ( ftoa ( w % debounce ), color_fg = 'yellow' ) // \"s)  \" // & colorize ( \"Ctrl+C\" , color_fg = 'red_intense' , style = 'bold_on' ) // \" to stop\" end if end subroutine run_command_and_report !> Construct the effective command to run based on changes and target masks. !! !! For `fpm build`, the original command is returned unchanged. !! !! For `fpm run` and `fpm test`, if the user did not already pin names via !! `--name`/positional patterns, this routine can inject a computed set of !! target names corresponding to the changed files. This reduces redundant !! builds and speeds up iterative workflows. function build_run_command ( settings , full_cmdline , cmd_prefix , cmd_rest , roots , file_mask , changed_idx , changed_count ) result ( cmd ) use watch_cmdsplice , only : inject_names_into_cmd class ( fpm_build_settings ), intent ( in ) :: settings character ( len =* ), intent ( in ) :: full_cmdline character ( len =* ), intent ( in ) :: cmd_prefix character ( len =* ), intent ( in ) :: cmd_rest type ( root_info_t ), allocatable , intent ( in ) :: roots (:) integer ( int64 ), allocatable , intent ( in ) :: file_mask (:) integer , intent ( in ) :: changed_idx (:) integer , intent ( in ) :: changed_count character ( len = :), allocatable :: cmd logical :: is_test , is_run integer ( int64 ) :: hitmask character ( len = :), allocatable :: names_str integer :: j , idx logical :: user_pinned_names is_test = . false . is_run = . false . user_pinned_names = . false . select type ( s => settings ) type is ( fpm_test_settings ) is_test = . true . if ( allocated ( s % name )) user_pinned_names = ( size ( s % name ) > 0 ) type is ( fpm_run_settings ) is_run = . true . if ( allocated ( s % name )) user_pinned_names = ( size ( s % name ) > 0 ) class default continue end select if ( user_pinned_names ) then cmd = trim ( full_cmdline ) return end if if (. not . is_test . and . . not . is_run ) then cmd = trim ( full_cmdline ) return end if if (. not . allocated ( roots ) . or . size ( roots ) == 0 ) then cmd = trim ( full_cmdline ) return end if if (. not . allocated ( file_mask )) then cmd = trim ( full_cmdline ) return end if hitmask = 0_int64 do j = 1 , changed_count idx = changed_idx ( j ) if ( idx < 1 . or . idx > size ( file_mask )) cycle hitmask = ior ( hitmask , file_mask ( idx )) end do if ( hitmask == 0_int64 ) then cmd = trim ( full_cmdline ) return end if names_str = join_names_from_mask ( roots , hitmask ) if ( len_trim ( names_str ) == 0 ) then cmd = trim ( full_cmdline ) return end if if ( len_trim ( cmd_prefix ) == 0 ) then cmd = trim ( full_cmdline ) return end if cmd = inject_names_into_cmd ( cmd_prefix , cmd_rest , names_str ) contains function join_names_from_mask ( roots , mask ) result ( s ) type ( root_info_t ), intent ( in ) :: roots (:) integer ( int64 ), intent ( in ) :: mask character ( len = :), allocatable :: s integer :: rr character ( len = :), allocatable :: nm s = \"\" do rr = 1 , size ( roots ) if ( iand ( mask , roots ( rr )% mask ) == 0_int64 ) cycle if (. not . allocated ( roots ( rr )% name )) cycle nm = trim ( roots ( rr )% name ) if ( len_trim ( nm ) == 0 ) cycle if ( len ( s ) > 0 ) s = s // \" \" s = s // nm end do end function join_names_from_mask end function build_run_command end module watch_exec","tags":"","url":"sourcefile/watch_exec.f90.html"},{"title":"watch_filter.f90 – fpm-watch","text":"Files dependent on this one sourcefile~~watch_filter.f90~~AfferentGraph sourcefile~watch_filter.f90 watch_filter.f90 sourcefile~watch_fpm_graph.f90 watch_fpm_graph.f90 sourcefile~watch_fpm_graph.f90->sourcefile~watch_filter.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_fpm_graph.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Watch list filtering and path normalization. !! !! Contains helpers to normalize paths and apply include/ignore globs to the !! computed set of watched files. !! !! Key behaviors: !! - Paths are normalized to use `/` separators. !! - Leading `./` segments are removed for consistent matching. !! - Build directory filtering is handled elsewhere (but helper exists here). module watch_filter use , intrinsic :: iso_fortran_env , only : int64 use fpm_strings , only : string_t , glob use fpm_filesystem , only : basename implicit none private public normalize_path , starts_with , filter_watch_files , is_ignored_path contains !> Normalize a path to a consistent form for matching. !! !! Transformations: !! - Backslashes (`\\`) → slashes (`/`) !! - Strip any leading `./` prefixes (repeatedly) pure function normalize_path ( path ) result ( p ) character ( len =* ), intent ( in ) :: path character ( len = :), allocatable :: p integer :: i p = trim ( path ) do i = 1 , len ( p ) if ( p ( i : i ) == char ( 92 )) p ( i : i ) = \"/\" end do do while ( len ( p ) >= 2 ) if ( p ( 1 : 2 ) == \"./\" ) then p = p ( 3 :) else exit end if end do end function normalize_path !> Check whether a string begins with a given prefix. pure logical function starts_with ( s , prefix ) result ( ok ) character ( len =* ), intent ( in ) :: s , prefix integer :: n n = len_trim ( prefix ) if ( n <= 0 ) then ok = . true . else if ( len_trim ( s ) < n ) then ok = . false . else ok = ( s ( 1 : n ) == prefix ( 1 : n )) end if end function starts_with pure logical function ends_with ( s , suffix ) result ( ok ) character ( len =* ), intent ( in ) :: s , suffix integer :: ns , n ns = len_trim ( suffix ) n = len_trim ( s ) if ( ns <= 0 ) then ok = . true . else if ( n < ns ) then ok = . false . else ok = ( s ( n - ns + 1 : n ) == suffix ( 1 : ns )) end if end function ends_with pure logical function contains_path_fragment ( p , frag ) result ( ok ) character ( len =* ), intent ( in ) :: p , frag character ( len = :), allocatable :: needle ok = . false . if ( len_trim ( frag ) == 0 ) return needle = \"/\" // trim ( frag ) // \"/\" if ( index ( p , needle ) /= 0 ) then ok = . true . return end if if ( ends_with ( p , \"/\" // trim ( frag ))) then ok = . true . return end if end function contains_path_fragment !> Identify paths that should be ignored due to being inside the build directory. !! !! This is used to prevent watch loops from triggering rebuilds due to build !! artifacts changing. When dependency watching is enabled, callers may !! selectively override this behavior. pure logical function is_ignored_path ( path , build_dir ) result ( ignored ) character ( len =* ), intent ( in ) :: path , build_dir character ( len = :), allocatable :: p , b p = normalize_path ( path ) b = normalize_path ( build_dir ) ignored = . false . if ( len_trim ( b ) == 0 ) return if ( p == b ) then ignored = . true . return end if if ( starts_with ( p , b // \"/\" )) then ignored = . true . return end if if ( contains_path_fragment ( p , b )) then ignored = . true . return end if end function is_ignored_path !> Apply include/ignore rules to the watch list. !! !! - If `include` patterns are empty, all files are included by default. !! - If `include` patterns are present, only matching files are kept. !! - If `ignore` patterns match a file, it is removed even if included. !! !! The `masks` array (when present) is filtered in sync with `files`. subroutine filter_watch_files ( files , include , ignore , masks ) type ( string_t ), allocatable , intent ( inout ) :: files (:) type ( string_t ), allocatable , intent ( in ) :: include (:), ignore (:) integer ( int64 ), allocatable , intent ( inout ), optional :: masks (:) logical , allocatable :: keep (:) type ( string_t ), allocatable :: out (:) integer ( int64 ), allocatable :: outm (:) integer :: i , k , n , m if (. not . allocated ( files )) return n = size ( files ) allocate ( keep ( n )) do i = 1 , n keep ( i ) = should_keep ( files ( i )% s , include , ignore ) end do m = count ( keep ) allocate ( out ( m )) if ( present ( masks )) then if (. not . allocated ( masks )) then allocate ( masks ( n )) masks = 0_int64 end if allocate ( outm ( m )) end if k = 0 do i = 1 , n if (. not . keep ( i )) cycle k = k + 1 out ( k )% s = files ( i )% s if ( present ( masks )) outm ( k ) = masks ( i ) end do call move_alloc ( out , files ) if ( present ( masks )) call move_alloc ( outm , masks ) deallocate ( keep ) contains logical function should_keep ( path , include_pats , ignore_pats ) result ( ok ) character ( len =* ), intent ( in ) :: path type ( string_t ), allocatable , intent ( in ) :: include_pats (:), ignore_pats (:) character ( len = :), allocatable :: b b = basename ( trim ( path )) if ( b == \"fpm.toml\" ) then ok = . true . return end if ok = match_include ( path , include_pats ) . and . (. not . match_any ( path , ignore_pats )) end function should_keep logical function match_any ( path , pats ) result ( ok ) character ( len =* ), intent ( in ) :: path type ( string_t ), allocatable , intent ( in ) :: pats (:) integer :: j character ( len = :), allocatable :: pat ok = . false . if (. not . allocated ( pats )) return do j = 1 , size ( pats ) if ( len_trim ( pats ( j )% s ) == 0 ) cycle pat = normalize_path ( trim ( pats ( j )% s )) if ( glob ( pat , trim ( path ))) then ok = . true . return end if end do end function match_any logical function match_include ( path , pats ) result ( ok ) character ( len =* ), intent ( in ) :: path type ( string_t ), allocatable , intent ( in ) :: pats (:) if (. not . allocated ( pats )) then ok = . true . return end if if ( size ( pats ) == 0 ) then ok = . true . return end if ok = match_any ( path , pats ) end function match_include end subroutine filter_watch_files end module watch_filter","tags":"","url":"sourcefile/watch_filter.f90.html"},{"title":"watch_config.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_config.f90~~EfferentGraph sourcefile~watch_config.f90 watch_config.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_config.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_config.f90~~AfferentGraph sourcefile~watch_config.f90 watch_config.f90 sourcefile~watch_cli.f90 watch_cli.f90 sourcefile~watch_cli.f90->sourcefile~watch_config.f90 sourcefile~watch_restart.f90 watch_restart.f90 sourcefile~watch_restart.f90->sourcefile~watch_config.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Project configuration and defaults. !! !! Reads watcher configuration from: !! - Built-in defaults (`set_watch_defaults`) !! - `fpm.toml` under `[extra.fpm-watch]` (`apply_watch_from_manifest`) !! !! Also provides helper routines used by the supervisor (`watch_restart`) for !! auto-restart defaults (delay, max restarts, self path). module watch_config use watch_types , only : watch_opts_t use fpm_strings , only : string_t use fpm_filesystem , only : exists use fpm_error , only : error_t use fpm_toml , only : read_package_file , get_list use tomlf , only : toml_table , toml_stat , get_value implicit none private public set_watch_defaults , apply_watch_from_manifest , normalize_watch_opts , push_feature , get_restart_defaults contains !> Apply built-in defaults to watcher options. !! !! This routine sets conservative defaults intended to work well for most !! projects, and ensures that list fields are always allocated (possibly !! with size zero). subroutine set_watch_defaults ( w ) type ( watch_opts_t ), intent ( inout ) :: w w % verbosity = 0 w % debug = . false . w % poll = 0.5 w % debounce = 0.2 w % rescan = 0.0 w % run_on_start = . true . w % print_files_once = . false . w % silent_fpm = . false . w % watch_deps = . false . w % low_cpu = . false . w % once = . false . if (. not . allocated ( w % ignore )) allocate ( w % ignore ( 0 )) if (. not . allocated ( w % include )) allocate ( w % include ( 0 )) if (. not . allocated ( w % enabled_features )) allocate ( w % enabled_features ( 0 )) end subroutine set_watch_defaults !> Normalize watcher options and clamp to safe bounds. !! !! Clamping prevents pathological values (e.g., negative times, too-small poll !! intervals) from degrading performance or usability. subroutine normalize_watch_opts ( w ) type ( watch_opts_t ), intent ( inout ) :: w if ( w % poll < 0.05 ) w % poll = 0.05 if ( w % debounce < 0.0 ) w % debounce = 0.0 if ( w % rescan < 0.0 ) w % rescan = 0.0 if ( w % verbosity > 2 ) w % verbosity = 2 if ( w % verbosity < - 1 ) w % verbosity = - 1 end subroutine normalize_watch_opts !> Apply configuration overrides from `fpm.toml` `[extra.fpm-watch]`. !! !! Missing keys are ignored; successfully read values override existing !! defaults. subroutine apply_watch_from_manifest ( w ) type ( watch_opts_t ), intent ( inout ) :: w type ( toml_table ), allocatable :: root type ( toml_table ), pointer :: wt logical :: ok call load_watch_table ( root , wt , ok ) if (. not . ok ) return call toml_get_real ( wt , \"poll\" , w % poll ) call toml_get_real ( wt , \"debounce\" , w % debounce ) call toml_get_real ( wt , \"rescan\" , w % rescan ) call toml_get_logical ( wt , \"debug\" , w % debug ) call toml_get_logical ( wt , \"print-files\" , w % print_files_once ) call toml_get_logical ( wt , \"silent-fpm\" , w % silent_fpm ) call toml_get_logical ( wt , \"run-on-start\" , w % run_on_start ) call toml_get_logical ( wt , \"deps\" , w % watch_deps ) call toml_get_logical ( wt , \"low-cpu\" , w % low_cpu ) call toml_get_logical ( wt , \"once\" , w % once ) call toml_get_int ( wt , \"verbosity\" , w % verbosity ) call toml_get_list_strings ( wt , \"ignore\" , w % ignore ) call toml_get_list_strings ( wt , \"include\" , w % include ) call toml_get_list_strings ( wt , \"features\" , w % enabled_features ) call normalize_watch_opts ( w ) end subroutine apply_watch_from_manifest !> Read supervisor defaults from the manifest (when present). !! !! These are used by `watch_restart` and can be configured under !! `[extra.fpm-watch]`. !! !! Keys: !! - `auto-restart` (logical) !! - `restart-delay` (real, seconds) !! - `restart-max` (integer, 0 = unlimited) !! - `self` or `self-exe` (string, explicit path to `fpm-watch`) subroutine get_restart_defaults ( auto_restart , restart_delay , restart_max , self_exe ) logical , intent ( out ) :: auto_restart real , intent ( out ) :: restart_delay integer , intent ( out ) :: restart_max character ( len = :), allocatable , intent ( out ) :: self_exe type ( toml_table ), allocatable :: root type ( toml_table ), pointer :: wt logical :: ok character ( len = :), allocatable :: tmp auto_restart = . false . restart_delay = 1.0 restart_max = 0 self_exe = \"\" call load_watch_table ( root , wt , ok ) if (. not . ok ) return call toml_get_logical ( wt , \"auto-restart\" , auto_restart ) call toml_get_real ( wt , \"restart-delay\" , restart_delay ) call toml_get_int ( wt , \"restart-max\" , restart_max ) tmp = \"\" call toml_get_string ( wt , \"self\" , tmp ) if ( len_trim ( tmp ) == 0 ) call toml_get_string ( wt , \"self-exe\" , tmp ) if ( len_trim ( tmp ) > 0 ) self_exe = trim ( tmp ) if ( restart_delay < 0.0 ) restart_delay = 0.0 if ( restart_max < 0 ) restart_max = 0 end subroutine get_restart_defaults !> Locate and return the `[extra.fpm-watch]` table from `fpm.toml`. !! !! Returns `ok=.false.` when: !! - `fpm.toml` is missing, !! - the TOML cannot be read, !! - the `extra` table is absent, !! - the `fpm-watch` table is absent. subroutine load_watch_table ( root , wt , ok ) type ( toml_table ), allocatable , intent ( out ) :: root type ( toml_table ), pointer , intent ( out ) :: wt logical , intent ( out ) :: ok type ( toml_table ), pointer :: extra type ( error_t ), allocatable :: err integer :: stat ok = . false . wt => null () extra => null () if (. not . exists ( \"fpm.toml\" )) return call read_package_file ( root , \"fpm.toml\" , err ) if ( allocated ( err )) return call get_value ( root , \"extra\" , extra , requested = . false ., stat = stat ) if ( stat /= toml_stat % success ) return if (. not . associated ( extra )) return call get_value ( extra , \"fpm-watch\" , wt , requested = . false ., stat = stat ) if ( stat /= toml_stat % success ) return if (. not . associated ( wt )) return ok = . true . end subroutine load_watch_table !> Read a TOML real value if present. subroutine toml_get_real ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key real , intent ( inout ) :: v real :: tmp integer :: stat tmp = v call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) v = tmp end subroutine toml_get_real !> Read a TOML integer value if present. subroutine toml_get_int ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key integer , intent ( inout ) :: v integer :: tmp , stat tmp = v call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) v = tmp end subroutine toml_get_int !> Read a TOML logical value if present. subroutine toml_get_logical ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key logical , intent ( inout ) :: v logical :: tmp integer :: stat tmp = v call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) v = tmp end subroutine toml_get_logical !> Read a TOML string value if present. subroutine toml_get_string ( table , key , v ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key character ( len = :), allocatable , intent ( inout ) :: v character ( len = :), allocatable :: tmp integer :: stat call get_value ( table , key , tmp , stat = stat ) if ( stat == toml_stat % success ) then if ( allocated ( tmp )) then v = tmp else v = \"\" end if end if end subroutine toml_get_string !> Read a TOML string list into an allocatable `string_t` array. subroutine toml_get_list_strings ( table , key , list ) type ( toml_table ), intent ( inout ) :: table character ( len =* ), intent ( in ) :: key type ( string_t ), allocatable , intent ( inout ) :: list (:) type ( error_t ), allocatable :: err type ( string_t ), allocatable :: tmp (:) if (. not . allocated ( list )) allocate ( list ( 0 )) call get_list ( table , key , tmp , err ) if ( allocated ( err )) then if ( allocated ( tmp )) deallocate ( tmp ) return end if if (. not . allocated ( tmp )) return call move_alloc ( tmp , list ) end subroutine toml_get_list_strings !> Append a feature name to a `string_t` array if not already present. !! !! This is used both for plugin feature names and for `ignore/include` patterns. subroutine push_feature ( features , name ) type ( string_t ), allocatable , intent ( inout ) :: features (:) character ( len =* ), intent ( in ) :: name integer :: n , i type ( string_t ), allocatable :: tmp (:) if ( len_trim ( name ) == 0 ) return if (. not . allocated ( features )) then allocate ( features ( 1 )) features ( 1 )% s = trim ( name ) return end if do i = 1 , size ( features ) if ( trim ( features ( i )% s ) == trim ( name )) return end do n = size ( features ) allocate ( tmp ( n + 1 )) tmp ( 1 : n ) = features tmp ( n + 1 )% s = trim ( name ) call move_alloc ( tmp , features ) end subroutine push_feature end module watch_config","tags":"","url":"sourcefile/watch_config.f90.html"},{"title":"watch_feat_stats.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_feat_stats.f90~~EfferentGraph sourcefile~watch_feat_stats.f90 watch_feat_stats.f90 sourcefile~watch_feature_api.f90 watch_feature_api.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_feature_api.f90 sourcefile~watch_log.f90 watch_log.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_log.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_feat_stats.f90->sourcefile~watch_types.f90 sourcefile~watch_feature_api.f90->sourcefile~watch_types.f90 sourcefile~watch_log.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~watch_feat_stats.f90~~AfferentGraph sourcefile~watch_feat_stats.f90 watch_feat_stats.f90 sourcefile~watch_feature_factory.f90 watch_feature_factory.f90 sourcefile~watch_feature_factory.f90->sourcefile~watch_feat_stats.f90 sourcefile~watch_engine.f90 watch_engine.f90 sourcefile~watch_engine.f90->sourcefile~watch_feature_factory.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Example \"stats\" feature plugin. !! !! This feature demonstrates the plugin system by tracking the number of runs. !! It currently does not print or export statistics; it simply increments an !! internal counter after each run. !! !! The `exitstat` and `seconds` arguments are accepted to conform to the plugin !! interface. Dummy references are used to prevent unused-argument warnings. module watch_feat_stats use watch_feature_api , only : watch_feature_t use watch_types , only : watch_config_t use watch_log , only : log_info implicit none private public new_stats_feature !> A feature that counts how many command runs have completed. type , extends ( watch_feature_t ) :: stats_feature_t integer :: runs = 0 contains procedure :: init => stats_init procedure :: on_after_run => stats_after end type stats_feature_t contains !> Allocate a new stats feature instance. subroutine new_stats_feature ( f ) class ( watch_feature_t ), allocatable , intent ( out ) :: f allocate ( stats_feature_t :: f ) end subroutine new_stats_feature !> Initialize the stats feature. !! !! Currently logs a single \"feature enabled\" message. subroutine stats_init ( self , cfg ) class ( stats_feature_t ), intent ( inout ) :: self type ( watch_config_t ), intent ( in ) :: cfg call log_info ( cfg % w , \"feature enabled: stats\" ) end subroutine stats_init !> Update run counter after each completed command execution. !! !! The exit status and runtime are currently not used by this feature. subroutine stats_after ( self , exitstat , seconds ) class ( stats_feature_t ), intent ( inout ) :: self integer , intent ( in ) :: exitstat real , intent ( in ) :: seconds self % runs = self % runs + 1 if (. false .) then if ( exitstat /= 0 ) continue if ( seconds < 0.0 ) continue end if end subroutine stats_after end module watch_feat_stats","tags":"","url":"sourcefile/watch_feat_stats.f90.html"},{"title":"watch_restart.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_restart.f90~~EfferentGraph sourcefile~watch_restart.f90 watch_restart.f90 sourcefile~watch_cmdline.f90 watch_cmdline.f90 sourcefile~watch_restart.f90->sourcefile~watch_cmdline.f90 sourcefile~watch_config.f90 watch_config.f90 sourcefile~watch_restart.f90->sourcefile~watch_config.f90 sourcefile~watch_time.f90 watch_time.F90 sourcefile~watch_restart.f90->sourcefile~watch_time.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_config.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Supervisor and auto-restart support. !! !! When enabled, `fpm-watch` can run under a supervisor loop that restarts the !! watcher on failure (non-zero exit status). !! !! Configuration sources: !! - CLI flags: !!   - `--watch-auto-restart` !!   - `--watch-restart-delay <sec>` !!   - `--watch-restart-max <n>` !!   - `--watch-self <path>` !! - `fpm.toml` `[extra.fpm-watch]` keys: !!   - `auto-restart`, `restart-delay`, `restart-max`, `self` / `self-exe` !! !! Low CPU mode is also applied here so the supervisor delay sleeps are idle. module watch_restart use , intrinsic :: iso_fortran_env , only : error_unit use watch_time , only : sleep_seconds , set_low_cpu use watch_cmdline , only : get_arg , parse_int , parse_real , quote_arg , starts_with use watch_config , only : get_restart_defaults implicit none private public maybe_supervise contains !> Enter supervisor mode when requested, otherwise return immediately. !! !! If auto-restart is enabled and the current process is not marked as a !! child (`--watch-child`), this routine runs a supervisor loop and does not !! return. subroutine maybe_supervise () logical :: auto_restart , is_child real :: restart_delay integer :: restart_max character ( len = :), allocatable :: self_exe call parse_restart_flags ( auto_restart , restart_delay , restart_max , is_child , self_exe ) if ( auto_restart . and . (. not . is_child )) then call supervisor_loop ( max ( 0.0 , restart_delay ), restart_max , self_exe ) stop 0 end if end subroutine maybe_supervise !> Run the supervisor loop, restarting the child on non-zero exit. !! !! The supervisor will: !! - Execute the child command. !! - Exit if the child returns `0`. !! - Otherwise wait `delay0` seconds and restart, until `max0` is reached. subroutine supervisor_loop ( delay0 , max0 , exe0 ) real , intent ( in ) :: delay0 integer , intent ( in ) :: max0 character ( len =* ), intent ( in ) :: exe0 character ( len = :), allocatable :: child_cmd integer :: code , attempt real :: delay child_cmd = build_child_command ( exe0 ) attempt = 0 delay = max ( 0.0 , delay0 ) do code = 0 call execute_command_line ( child_cmd , exitstat = code ) if ( code == 0 ) exit attempt = attempt + 1 if ( max0 > 0 . and . attempt >= max0 ) then write ( error_unit , '(a)' ) \"fpm-watch: child exited with nonzero status; restart limit reached\" stop code end if write ( error_unit , '(a,i0,a,i0,a,f0.2,a)' ) \"fpm-watch: child crashed/aborted (exit=\" , code , \"), restart #\" , attempt , \" in \" , delay , \"s\" call sleep_seconds ( delay ) end do stop 0 end subroutine supervisor_loop !> Build the command line used to spawn the supervised child. !! !! The child receives `--watch-child` and inherits most argv tokens, with !! supervisor-only flags removed to avoid recursion. function build_child_command ( exe0 ) result ( cmd ) character ( len =* ), intent ( in ) :: exe0 character ( len = :), allocatable :: cmd character ( len = :), allocatable :: exe , a integer :: narg , i logical :: skip_next exe = choose_self_exe ( exe0 ) cmd = quote_arg ( exe ) // \" --watch-child\" narg = command_argument_count () skip_next = . false . do i = 1 , narg a = get_arg ( i ) if ( skip_next ) then skip_next = . false . cycle end if if ( a == \"--watch-auto-restart\" ) cycle if ( a == \"--watch-child\" ) cycle if ( a == \"--watch-restart-delay\" ) then skip_next = . true . cycle end if if ( a == \"--watch-restart-max\" ) then skip_next = . true . cycle end if if ( a == \"--watch-self\" ) then skip_next = . true . cycle end if if ( starts_with ( a , \"--watch-restart-delay=\" )) cycle if ( starts_with ( a , \"--watch-restart-max=\" )) cycle if ( starts_with ( a , \"--watch-self=\" )) cycle cmd = cmd // \" \" // quote_arg ( a ) end do end function build_child_command !> Determine the executable to use when spawning the child watcher. !! !! Precedence: !! 1. Explicit `exe0` argument !! 2. Environment `FPM_WATCH_SELF` !! 3. `argv[0]` !! 4. Fallback `\"fpm-watch\"` function choose_self_exe ( exe0 ) result ( exe ) character ( len =* ), intent ( in ) :: exe0 character ( len = :), allocatable :: exe character ( len = 2048 ) :: buf integer :: n , stat character ( len = :), allocatable :: a0 if ( len_trim ( exe0 ) > 0 ) then exe = trim ( exe0 ) return end if buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"FPM_WATCH_SELF\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) then exe = trim ( buf ( 1 : n )) return end if a0 = get_arg ( 0 ) if ( len_trim ( a0 ) > 0 ) then exe = trim ( a0 ) return end if exe = \"fpm-watch\" end function choose_self_exe !> Parse restart-related flags and apply manifest defaults. !! !! This routine also applies `--watch-low-cpu` to the sleep implementation !! so supervisor delays do not busy-wait. subroutine parse_restart_flags ( auto_restart , restart_delay , restart_max , is_child , self_exe ) logical , intent ( out ) :: auto_restart , is_child real , intent ( out ) :: restart_delay integer , intent ( out ) :: restart_max character ( len = :), allocatable , intent ( out ) :: self_exe integer :: narg , i character ( len = :), allocatable :: a , v call get_restart_defaults ( auto_restart , restart_delay , restart_max , self_exe ) is_child = . false . narg = command_argument_count () i = 1 do while ( i <= narg ) a = get_arg ( i ) if ( a == \"--watch-low-cpu\" ) then call set_low_cpu (. true .) i = i + 1 cycle end if if ( a == \"--watch-no-low-cpu\" ) then call set_low_cpu (. false .) i = i + 1 cycle end if if ( starts_with ( a , \"--watch-low-cpu=\" )) then v = a ( len ( \"--watch-low-cpu=\" ) + 1 :) call set_low_cpu ( parse_bool ( v , . true .)) i = i + 1 cycle end if if ( a == \"--watch-auto-restart\" ) then auto_restart = . true . i = i + 1 cycle end if if ( a == \"--watch-child\" ) then is_child = . true . i = i + 1 cycle end if if ( starts_with ( a , \"--watch-restart-delay=\" )) then v = a ( len ( \"--watch-restart-delay=\" ) + 1 :) restart_delay = parse_real ( v , restart_delay ) i = i + 1 cycle end if if ( starts_with ( a , \"--watch-restart-max=\" )) then v = a ( len ( \"--watch-restart-max=\" ) + 1 :) restart_max = parse_int ( v , restart_max ) i = i + 1 cycle end if if ( starts_with ( a , \"--watch-self=\" )) then self_exe = trim ( a ( len ( \"--watch-self=\" ) + 1 :)) i = i + 1 cycle end if if ( a == \"--watch-restart-delay\" ) then if ( i + 1 <= narg ) then v = get_arg ( i + 1 ) restart_delay = parse_real ( v , restart_delay ) i = i + 2 else i = i + 1 end if cycle end if if ( a == \"--watch-restart-max\" ) then if ( i + 1 <= narg ) then v = get_arg ( i + 1 ) restart_max = parse_int ( v , restart_max ) i = i + 2 else i = i + 1 end if cycle end if if ( a == \"--watch-self\" ) then if ( i + 1 <= narg ) then self_exe = trim ( get_arg ( i + 1 )) i = i + 2 else i = i + 1 end if cycle end if i = i + 1 end do contains pure logical function parse_bool ( s , default ) result ( vb ) character ( len =* ), intent ( in ) :: s logical , intent ( in ) :: default character ( len = :), allocatable :: t t = trim ( adjustl ( lower_ascii ( s ))) select case ( t ) case ( \"1\" , \"true\" , \"on\" , \"yes\" , \"y\" , \"t\" ) vb = . true . case ( \"0\" , \"false\" , \"off\" , \"no\" , \"n\" , \"f\" ) vb = . false . case default vb = default end select end function parse_bool pure function lower_ascii ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = len ( s )) :: r integer :: k , c , da da = iachar ( 'a' ) - iachar ( 'A' ) do k = 1 , len ( s ) c = iachar ( s ( k : k )) if ( c >= iachar ( 'A' ) . and . c <= iachar ( 'Z' )) then r ( k : k ) = achar ( c + da ) else r ( k : k ) = s ( k : k ) end if end do end function lower_ascii end subroutine parse_restart_flags end module watch_restart","tags":"","url":"sourcefile/watch_restart.f90.html"},{"title":"watch_cli.f90 – fpm-watch","text":"This file depends on sourcefile~~watch_cli.f90~~EfferentGraph sourcefile~watch_cli.f90 watch_cli.f90 sourcefile~watch_cmdline.f90 watch_cmdline.f90 sourcefile~watch_cli.f90->sourcefile~watch_cmdline.f90 sourcefile~watch_cmdsplice.f90 watch_cmdsplice.f90 sourcefile~watch_cli.f90->sourcefile~watch_cmdsplice.f90 sourcefile~watch_config.f90 watch_config.f90 sourcefile~watch_cli.f90->sourcefile~watch_config.f90 sourcefile~watch_types.f90 watch_types.f90 sourcefile~watch_cli.f90->sourcefile~watch_types.f90 sourcefile~watch_config.f90->sourcefile~watch_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> Command-line parsing and configuration assembly. !! !! This module: !! - Applies built-in defaults (`set_watch_defaults`), !! - Applies project-level overrides from `fpm.toml` (`apply_watch_from_manifest`), !! - Parses `--watch-*` options and `fpm` subcommand arguments, !! - Produces a `watch_config_t` that drives the watcher engine. !! !! Parsing is deliberately simple and \"argv-token based\": it does not implement !! a full shell parser. The `fpm_cmdline` string is built for display and for !! execution via `execute_command_line` / `fpm_filesystem:run`. module watch_cli use , intrinsic :: iso_fortran_env , only : error_unit use watch_types , only : watch_config_t , watch_opts_t use watch_config , only : set_watch_defaults , apply_watch_from_manifest , normalize_watch_opts , push_feature use watch_cmdline , only : get_arg , join_argv , parse_int , parse_real use fpm_strings , only : string_t use fpm_command_line , only : fpm_build_settings , fpm_run_settings , fpm_test_settings use face , only : colorize implicit none private public parse_cli_config contains !> Parse CLI arguments and build the full watcher configuration. !! !! Produces a `watch_config_t`: !! - `cfg%w` contains watcher options (polling, debounce, flags, etc.) !! - `cfg%settings` holds the typed `fpm` settings for the selected subcommand !! - `cfg%fpm_cmdline` is the effective command string !! - `cfg%cmd_prefix` and `cfg%cmd_rest` are helper fields used to inject !!   target names into `run`/`test` commands. subroutine parse_cli_config ( cfg ) use watch_cmdsplice , only : split_cmd_after_subcmd type ( watch_config_t ), intent ( out ) :: cfg character ( len = :), allocatable :: fpm_cmdline class ( fpm_build_settings ), allocatable :: settings character ( len = :), allocatable :: subcmd call parse_cli ( cfg % w , settings , fpm_cmdline , subcmd ) cfg % fpm_cmdline = fpm_cmdline cfg % subcmd = subcmd call move_alloc ( settings , cfg % settings ) call split_cmd_after_subcmd ( cfg % fpm_cmdline , cfg % cmd_prefix , cfg % cmd_rest ) end subroutine parse_cli_config !> Parse the complete CLI and produce watcher options + typed `fpm` settings. !! !! Parsing order: !! 1. Initialize watcher options from defaults and `fpm.toml`. !! 2. Consume leading `--watch-*` options and verbosity flags (`-q`, `-v`). !! 3. Identify the `fpm` subcommand (`build|test|run`). !! 4. Parse selected `fpm` settings used to build the model (profile, flags, !!    compilers, build-dir, features, and run/test names). !! !! All arguments after the subcommand are also preserved in `fpm_cmdline`. subroutine parse_cli ( w , settings , fpm_cmdline , subcmd ) type ( watch_opts_t ), intent ( out ) :: w class ( fpm_build_settings ), allocatable , intent ( out ) :: settings character ( len = :), allocatable , intent ( out ) :: fpm_cmdline character ( len = :), allocatable , intent ( out ) :: subcmd integer :: narg , i , subcmd_pos character ( len = :), allocatable :: a character ( len = :), allocatable :: profile , build_dir character ( len = :), allocatable :: compiler , c_compiler , cxx_compiler , archiver character ( len = :), allocatable :: flag , cflag , cxxflag , ldflag character ( len = :), allocatable :: runner type ( string_t ), allocatable :: features (:) type ( string_t ), allocatable :: names (:) logical :: prune , example call set_watch_defaults ( w ) call apply_watch_from_manifest ( w ) prune = . true . example = . false . profile = \"\" build_dir = default_build_dir () compiler = \"\" c_compiler = \"\" cxx_compiler = \"\" archiver = \"\" flag = \"\" cflag = \"\" cxxflag = \"\" ldflag = \"\" runner = \"\" allocate ( features ( 0 )) allocate ( names ( 0 )) narg = command_argument_count () if ( narg < 1 ) then call usage_and_stop ( \"missing fpm subcommand (build/test/run)\" ) end if a = get_arg ( 1 ) if ( a == \"--help\" . or . a == \"-h\" ) then call usage_and_stop_ok () end if i = 1 do while ( i <= narg ) a = get_arg ( i ) if ( is_watch_flag ( a )) then call apply_watch_flag ( a , i , narg , w ) i = i + 1 cycle end if if ( a == \"-q\" ) then w % verbosity = - 1 i = i + 1 cycle end if if ( a == \"-v\" ) then w % verbosity = max ( w % verbosity , 1 ) i = i + 1 cycle end if if ( a == \"-vv\" ) then w % verbosity = max ( w % verbosity , 2 ) i = i + 1 cycle end if exit end do if ( i > narg ) call usage_and_stop ( \"missing fpm subcommand (build/test/run)\" ) a = get_arg ( i ) if ( a == \"--help\" . or . a == \"-h\" ) then call usage_and_stop_ok () end if subcmd_pos = i subcmd = get_arg ( subcmd_pos ) if (. not . is_supported_subcmd ( subcmd )) then call usage_and_stop ( \"unsupported subcommand: \" // trim ( subcmd ) // \" (supported: build,test,run)\" ) end if if ( subcmd_pos < narg ) then fpm_cmdline = \"fpm \" // trim ( subcmd ) // \" \" // join_argv ( subcmd_pos + 1 , narg ) else fpm_cmdline = \"fpm \" // trim ( subcmd ) end if i = subcmd_pos + 1 do while ( i <= narg ) a = get_arg ( i ) if ( a == \"--\" ) exit select case ( a ) case ( \"--profile\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--profile requires a value\" ) profile = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--features\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--features requires a value\" ) call add_features_csv ( features , get_arg ( i + 1 )) i = i + 2 cycle case ( \"--build-dir\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--build-dir requires a value\" ) build_dir = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--compiler\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--compiler requires a value\" ) compiler = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--c-compiler\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--c-compiler requires a value\" ) c_compiler = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--cxx-compiler\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--cxx-compiler requires a value\" ) cxx_compiler = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--archiver\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--archiver requires a value\" ) archiver = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--flag requires a value\" ) flag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--c-flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--c-flag requires a value\" ) cflag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--cxx-flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--cxx-flag requires a value\" ) cxxflag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--link-flag\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--link-flag requires a value\" ) ldflag = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--runner\" ) if ( i + 1 > narg ) call usage_and_stop ( \"--runner requires a value\" ) runner = get_arg ( i + 1 ) i = i + 2 cycle case ( \"--prune\" ) prune = . true . i = i + 1 cycle case ( \"--no-prune\" ) prune = . false . i = i + 1 cycle case ( \"--example\" ) example = . true . i = i + 1 cycle case default if ( trim ( subcmd ) == \"run\" . or . trim ( subcmd ) == \"test\" ) then if ( len_trim ( a ) > 0 ) then if ( a ( 1 : 1 ) /= \"-\" ) call push_feature ( names , a ) end if end if i = i + 1 cycle end select end do select case ( trim ( subcmd )) case ( \"build\" ) allocate ( fpm_build_settings :: settings ) call init_build_settings ( settings , build_dir , prune , profile , features , compiler , c_compiler , cxx_compiler , archiver , flag , cflag , cxxflag , ldflag ) case ( \"test\" ) allocate ( fpm_test_settings :: settings ) call init_build_settings ( settings , build_dir , prune , profile , features , compiler , c_compiler , cxx_compiler , archiver , flag , cflag , cxxflag , ldflag ) select type ( s => settings ) type is ( fpm_test_settings ) s % build_tests = . true . if ( len_trim ( runner ) > 0 ) s % runner = trim ( runner ) call set_names ( s , names ) end select case ( \"run\" ) allocate ( fpm_run_settings :: settings ) call init_build_settings ( settings , build_dir , prune , profile , features , compiler , c_compiler , cxx_compiler , archiver , flag , cflag , cxxflag , ldflag ) select type ( s => settings ) type is ( fpm_run_settings ) s % example = example if ( len_trim ( runner ) > 0 ) s % runner = trim ( runner ) call set_names ( s , names ) end select case default call usage_and_stop ( \"unsupported subcommand: \" // trim ( subcmd ) // \" (supported: build,test,run)\" ) end select call normalize_watch_opts ( w ) end subroutine parse_cli !> Return whether a given subcommand token is supported by `fpm-watch`. pure logical function is_supported_subcmd ( s ) result ( ok ) character ( len =* ), intent ( in ) :: s ok = ( trim ( s ) == \"build\" ) . or . ( trim ( s ) == \"test\" ) . or . ( trim ( s ) == \"run\" ) end function is_supported_subcmd !> Detect whether an argv token is a watcher-specific flag. !! !! Watcher flags are of the form `--watch-*` and are consumed by `fpm-watch` !! itself rather than forwarded to `fpm`. pure logical function is_watch_flag ( a ) result ( ok ) character ( len =* ), intent ( in ) :: a ok = ( len_trim ( a ) >= 8 . and . a ( 1 : 8 ) == \"--watch-\" ) end function is_watch_flag !> Apply a single `--watch-*` flag to the watcher options. !! !! Supports both `--flag=value` and `--flag value` styles for flags that take !! a value. !! !! This routine is called while scanning the argv prefix before the `fpm` !! subcommand token. subroutine apply_watch_flag ( a , i , narg , w ) character ( len =* ), intent ( in ) :: a integer , intent ( inout ) :: i integer , intent ( in ) :: narg type ( watch_opts_t ), intent ( inout ) :: w character ( len = :), allocatable :: key , val integer :: eq key = trim ( a ) val = \"\" eq = index ( key , \"=\" ) if ( eq > 0 ) then val = key ( eq + 1 :) key = key ( 1 : eq - 1 ) end if select case ( key ) case ( \"--watch-child\" ) continue case ( \"--watch-auto-restart\" ) continue case ( \"--watch-restart-delay\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 <= narg ) i = i + 1 end if case ( \"--watch-restart-max\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 <= narg ) i = i + 1 end if case ( \"--watch-self\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 <= narg ) i = i + 1 end if case ( \"--watch-deps\" ) if ( len_trim ( val ) > 0 ) then w % watch_deps = parse_bool ( val , . true .) else w % watch_deps = . true . end if case ( \"--watch-no-deps\" ) w % watch_deps = . false . case ( \"--watch-low-cpu\" ) if ( len_trim ( val ) > 0 ) then w % low_cpu = parse_bool ( val , . true .) else w % low_cpu = . true . end if case ( \"--watch-no-low-cpu\" ) w % low_cpu = . false . case ( \"--watch-quiet\" ) w % verbosity = - 1 case ( \"--watch-verbose\" ) if ( len_trim ( val ) > 0 ) then w % verbosity = max ( w % verbosity , parse_int ( val , 1 )) else w % verbosity = max ( w % verbosity , 1 ) end if case ( \"--watch-very-verbose\" ) w % verbosity = max ( w % verbosity , 2 ) case ( \"--watch-debug\" ) w % debug = . true . case ( \"--watch-print-files\" ) w % print_files_once = . true . w % verbosity = max ( w % verbosity , 2 ) case ( \"--watch-silent-fpm\" ) w % silent_fpm = . true . case ( \"--watch-run-on-start\" ) w % run_on_start = . true . case ( \"--watch-no-run-on-start\" ) w % run_on_start = . false . case ( \"--watch-rescan\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-rescan requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if w % rescan = parse_real ( val , w % rescan ) case ( \"--watch-no-rescan\" ) w % rescan = 0.0 case ( \"--watch-ignore\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-ignore requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if call push_feature ( w % ignore , trim ( val )) case ( \"--watch-include\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-include requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if call push_feature ( w % include , trim ( val )) case ( \"--watch-feature\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-feature requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if call push_feature ( w % enabled_features , trim ( val )) case ( \"--watch-poll\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-poll requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if w % poll = parse_real ( val , w % poll ) case ( \"--watch-debounce\" ) if ( len_trim ( val ) == 0 ) then if ( i + 1 > narg ) call usage_and_stop ( \"--watch-debounce requires a value\" ) val = get_arg ( i + 1 ) i = i + 1 end if w % debounce = parse_real ( val , w % debounce ) case ( \"--watch-once\" ) if ( len_trim ( val ) > 0 ) then w % once = parse_bool ( val , . true .) else w % once = . true . end if case ( \"--watch-help\" ) call usage_and_stop_ok () case default call usage_and_stop ( \"unknown watch flag: \" // trim ( a )) end select call normalize_watch_opts ( w ) contains pure logical function parse_bool ( s , default ) result ( v ) character ( len =* ), intent ( in ) :: s logical , intent ( in ) :: default character ( len = :), allocatable :: t t = trim ( adjustl ( lower_ascii ( s ))) select case ( t ) case ( \"1\" , \"true\" , \"on\" , \"yes\" , \"y\" , \"t\" ) v = . true . case ( \"0\" , \"false\" , \"off\" , \"no\" , \"n\" , \"f\" ) v = . false . case default v = default end select end function parse_bool pure function lower_ascii ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = len ( s )) :: r integer :: k , c , da da = iachar ( 'a' ) - iachar ( 'A' ) do k = 1 , len ( s ) c = iachar ( s ( k : k )) if ( c >= iachar ( 'A' ) . and . c <= iachar ( 'Z' )) then r ( k : k ) = achar ( c + da ) else r ( k : k ) = s ( k : k ) end if end do end function lower_ascii end subroutine apply_watch_flag !> Print a usage message and terminate with a non-zero exit status. subroutine usage_and_stop ( msg ) character ( len =* ), intent ( in ) :: msg write ( error_unit , '(a)' ) & colorize ( \"fpm-watch: error:\" , color_fg = 'red_intense' , style = 'bold_on' ) // \" \" // trim ( msg ) write ( error_unit , '(a)' ) \"\" call usage_print_only () stop 2 end subroutine usage_and_stop !> Print a usage message and terminate successfully. subroutine usage_and_stop_ok () call usage_print_only () stop 0 end subroutine usage_and_stop_ok !> Print the `fpm-watch` help text. !! !! The help includes: !! - Watcher options (`--watch-*`), !! - Project configuration (`[extra.fpm-watch]`), !! - Examples and behavioral notes. subroutine usage_print_only () character ( len = :), allocatable :: title title = colorize ( & colorize ( \"fpm-watch — Smart file watcher plugin for fpm projects\" , & color_fg = 'cyan_intense' , style = 'bold_on' ), & style = 'underline_on' ) write ( error_unit , '(a)' ) title write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"USAGE\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch\" ) // \" \" // arg ( \"[watch options]\" ) // \" \" // arg ( \"<build|test|run>\" ) // \" \" // arg ( \"[fpm options]\" ) write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  Everything after \" // arg ( \"<build|test|run>\" ) // \" is passed to \" // cmd ( \"fpm\" ) // \" unchanged.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"WATCH OPTIONS\" ) write ( error_unit , '(a)' ) \"  --watch-help\" write ( error_unit , '(a)' ) \"      Show this help and exit.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-quiet | -q\" write ( error_unit , '(a)' ) \"      Quiet mode (errors only).\" write ( error_unit , '(a)' ) \"  --watch-verbose[=N] | -v\" write ( error_unit , '(a)' ) \"      Increase verbosity. N: 0..2 (default: 1).\" write ( error_unit , '(a)' ) \"  --watch-very-verbose | -vv\" write ( error_unit , '(a)' ) \"      Same as verbosity=2 (prints watch list, more details).\" write ( error_unit , '(a)' ) \"  --watch-debug\" write ( error_unit , '(a)' ) \"      Extra debug logs (watch list rebuilds, counts, keys).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-deps\" write ( error_unit , '(a)' ) \"      Also watch dependency source trees (including deps under build/).\" write ( error_unit , '(a)' ) \"  --watch-no-deps\" write ( error_unit , '(a)' ) \"      Disable dependency watching (default).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-low-cpu\" write ( error_unit , '(a)' ) \"      Use OS sleep instead of busy-waiting (near 0% idle CPU).\" write ( error_unit , '(a)' ) \"  --watch-no-low-cpu\" write ( error_unit , '(a)' ) \"      Disable low CPU mode (default).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-poll <sec>\" write ( error_unit , '(a)' ) \"      Poll interval for file checks. Default: 0.5\" write ( error_unit , '(a)' ) \"  --watch-debounce <sec>\" write ( error_unit , '(a)' ) \"      Wait after first change to coalesce edits. Default: 0.2\" write ( error_unit , '(a)' ) \"  --watch-rescan <sec>\" write ( error_unit , '(a)' ) \"      Rebuild the fpm model periodically (slow on big projects). Default: 0 (off).\" write ( error_unit , '(a)' ) \"  --watch-no-rescan\" write ( error_unit , '(a)' ) \"      Disable periodic rebuild (recommended).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-run-on-start\" write ( error_unit , '(a)' ) \"      Run the command once immediately on startup. Default: on.\" write ( error_unit , '(a)' ) \"  --watch-no-run-on-start\" write ( error_unit , '(a)' ) \"      Only run after a change is detected.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-silent-fpm\" write ( error_unit , '(a)' ) \"      Suppress fpm output; keep only fpm-watch status lines.\" write ( error_unit , '(a)' ) \"  --watch-print-files\" write ( error_unit , '(a)' ) \"      Print the watched file list (limited) at startup.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-ignore <glob>\" write ( error_unit , '(a)' ) \"      Ignore files matching glob (repeatable).\" write ( error_unit , '(a)' ) \"  --watch-include <glob>\" write ( error_unit , '(a)' ) \"      Only watch files matching glob (repeatable). Empty means include all.\" write ( error_unit , '(a)' ) \"  --watch-feature <name>\" write ( error_unit , '(a)' ) \"      Enable optional feature plugin (repeatable).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-auto-restart\" write ( error_unit , '(a)' ) \"      Restart fpm-watch automatically if it crashes.\" write ( error_unit , '(a)' ) \"  --watch-restart-delay <sec>\" write ( error_unit , '(a)' ) \"      Delay before restart. Default: 1.0\" write ( error_unit , '(a)' ) \"  --watch-restart-max <N>\" write ( error_unit , '(a)' ) \"      Maximum restart attempts (0 = unlimited). Default: 0\" write ( error_unit , '(a)' ) \"  --watch-self <path>\" write ( error_unit , '(a)' ) \"      Explicit path to fpm-watch executable (advanced).\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) \"  --watch-once\" write ( error_unit , '(a)' ) \"      Initialize (and optionally run once) then exit. Good for CI.\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"CONFIGURATION (fpm.toml)\" ) write ( error_unit , '(a)' ) \"  \" // arg ( \"[extra.fpm-watch]\" ) // \"  (same names as flags, without the --watch- prefix)\" write ( error_unit , '(a)' ) \"  poll         = 0.5\" write ( error_unit , '(a)' ) \"  debounce     = 0.2\" write ( error_unit , '(a)' ) \"  rescan       = 0.0\" write ( error_unit , '(a)' ) \"  run-on-start = true\" write ( error_unit , '(a)' ) \"  silent-fpm   = false\" write ( error_unit , '(a)' ) \"  print-files  = false\" write ( error_unit , '(a)' ) \"  deps         = false\" write ( error_unit , '(a)' ) \"  low-cpu      = false\" write ( error_unit , '(a)' ) \"  auto-restart = false\" write ( error_unit , '(a)' ) \"  restart-delay= 1.0\" write ( error_unit , '(a)' ) \"  restart-max  = 0\" write ( error_unit , '(a)' ) \"  self         = \"\"\"\"\" write ( error_unit , '(a)' ) \"  debug        = false\" write ( error_unit , '(a)' ) \"  verbosity    = 0\" write ( error_unit , '(a)' ) \"  ignore       = []\" write ( error_unit , '(a)' ) \"  include      = []\" write ( error_unit , '(a)' ) \"  features     = []\" write ( error_unit , '(a)' ) \"  once         = false\" write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"EXAMPLES\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch build\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch --watch-low-cpu test\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch --watch-deps test\" ) // \" \" // arg ( \"--\" ) // \" \" // arg ( \"--list\" ) write ( error_unit , '(a)' ) \"  \" // cmd ( \"fpm-watch --watch-auto-restart test\" ) write ( error_unit , '(a)' ) \"\" write ( error_unit , '(a)' ) sec ( \"NOTES\" ) write ( error_unit , '(a)' ) \"  fpm-watch ignores \" // arg ( \"build/\" ) // \" to avoid infinite rebuild loops.\" write ( error_unit , '(a)' ) \"  Enable \" // arg ( \"deps\" ) // \" only if you want dependency source changes to trigger runs.\" write ( error_unit , '(a)' ) \"  Enable \" // arg ( \"low-cpu\" ) // \" to avoid busy-waiting and reduce idle CPU usage.\" write ( error_unit , '(a)' ) \"  To quit, press Ctrl+C (or create an empty file named \" // arg ( \".fpm-watch.stop\" ) // \").\" write ( error_unit , '(a)' ) \"\" contains function sec ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r r = colorize ( s , color_fg = 'blue_intense' , style = 'bold_on' ) end function sec function cmd ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r r = colorize ( s , color_fg = 'cyan_intense' , style = 'bold_on' ) end function cmd function arg ( s ) result ( r ) character ( len =* ), intent ( in ) :: s character ( len = :), allocatable :: r r = colorize ( s , color_fg = 'yellow_intense' ) end function arg end subroutine usage_print_only !> Populate `settings` with parsed values and environment fallbacks. !! !! This routine centralizes: !! - `build_dir`, `profile`, `features`, !! - Fortran/C/C++ toolchain selection (`FC`, `CC`, `CXX`, `AR`), !! - Common compile and link flags (`--flag`, `--c-flag`, `--cxx-flag`, `--link-flag`). !! !! Environment variables are consulted only when the corresponding CLI option !! is empty. subroutine init_build_settings ( settings , build_dir , prune , profile , features , compiler_in , c_compiler_in , cxx_compiler_in , archiver_in , flag_in , cflag_in , cxxflag_in , ldflag_in ) class ( fpm_build_settings ), intent ( inout ) :: settings character ( len =* ), intent ( in ) :: build_dir logical , intent ( in ) :: prune character ( len =* ), intent ( in ) :: profile type ( string_t ), allocatable , intent ( in ) :: features (:) character ( len =* ), intent ( in ) :: compiler_in , c_compiler_in , cxx_compiler_in , archiver_in character ( len =* ), intent ( in ) :: flag_in , cflag_in , cxxflag_in , ldflag_in character ( len = :), allocatable :: v character ( len = 2048 ) :: buf integer :: n , stat settings % verbose = . false . settings % prune = prune if ( len_trim ( build_dir ) > 0 ) then settings % build_dir = trim ( build_dir ) end if if ( len_trim ( profile ) > 0 ) settings % profile = trim ( profile ) if ( allocated ( settings % features )) deallocate ( settings % features ) if ( allocated ( features )) then if ( size ( features ) > 0 ) then allocate ( settings % features ( size ( features ))) settings % features = features end if end if v = trim ( compiler_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"FC\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) == 0 ) v = \"gfortran\" settings % compiler = trim ( v ) v = trim ( c_compiler_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"CC\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) > 0 ) settings % c_compiler = trim ( v ) v = trim ( cxx_compiler_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"CXX\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) > 0 ) settings % cxx_compiler = trim ( v ) v = trim ( archiver_in ) if ( len_trim ( v ) == 0 ) then buf = \"\" n = 0 stat = 0 call get_environment_variable ( \"AR\" , buf , length = n , status = stat ) if ( stat == 0 . and . n > 0 ) v = trim ( buf ( 1 : n )) end if if ( len_trim ( v ) > 0 ) settings % archiver = trim ( v ) v = trim ( flag_in ) if ( len_trim ( v ) > 0 ) settings % flag = trim ( v ) v = trim ( cflag_in ) if ( len_trim ( v ) > 0 ) settings % cflag = trim ( v ) v = trim ( cxxflag_in ) if ( len_trim ( v ) > 0 ) settings % cxxflag = trim ( v ) v = trim ( ldflag_in ) if ( len_trim ( v ) > 0 ) settings % ldflag = trim ( v ) end subroutine init_build_settings !> Return the default build directory used by `fpm-watch`. pure function default_build_dir () result ( dir ) character ( len = :), allocatable :: dir dir = \"build\" end function default_build_dir !> Transfer collected name patterns into a run/test settings object. !! !! The `names` array contains tokens collected from positional arguments in !! `fpm-watch run/test` invocations. Only non-empty entries are copied. pure subroutine set_names ( s , names ) class ( fpm_run_settings ), intent ( inout ) :: s type ( string_t ), allocatable , intent ( in ) :: names (:) integer :: i , k , n if (. not . allocated ( names )) return n = 0 do i = 1 , size ( names ) if ( len_trim ( names ( i )% s ) > 0 ) n = n + 1 end do if ( n == 0 ) return allocate ( s % name ( n )) k = 0 do i = 1 , size ( names ) if ( len_trim ( names ( i )% s ) == 0 ) cycle k = k + 1 s % name ( k ) = trim ( names ( i )% s ) end do end subroutine set_names !> Parse a comma-separated `--features` value into the features array. !! !! Empty tokens are ignored; whitespace around tokens is stripped. subroutine add_features_csv ( features , csv ) type ( string_t ), allocatable , intent ( inout ) :: features (:) character ( len =* ), intent ( in ) :: csv integer :: n , p , q character ( len = :), allocatable :: s , tok s = trim ( csv ) if ( len_trim ( s ) == 0 ) return p = 1 n = len_trim ( s ) do if ( p > n ) exit q = index ( s ( p :), \",\" ) if ( q == 0 ) then tok = adjustl ( s ( p : n )) call push_feature ( features , trim ( tok )) exit else tok = adjustl ( s ( p : p + q - 2 )) call push_feature ( features , trim ( tok )) p = p + q end if end do end subroutine add_features_csv end module watch_cli","tags":"","url":"sourcefile/watch_cli.f90.html"}]}